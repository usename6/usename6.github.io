---
title: winsock-3
date: 2020-05-05 19:14:59
tags: [C++,网络编程]
categories: [C++,网络编程]
---
一、Windows Socket五种I/O模型
1.1 网络I/O操作模式
1.1.1 同步与异步
同步与异步是一种消息传递机制。比如说两个进程间进行通信，具体可以是CPU和外设进行通信。
同步：在通信过程中，一方只有等待对方发送来数据后，才能做其他事情。
异步：在通信过程中，我可以干其他事情，你来通知我有没有发送到。
一个最简单的例子就是：
我来书店买书，你得等老板把这本书找出来，才能离开。而如果你在京东买，下单后，你还可以出去玩一趟，等到快递通知你，再去取。
1.1.2 阻塞和非阻塞
阻塞和非阻塞这个概念主要在进程、线程级别，和同步与异步概念的层次不同。阻塞和非阻塞通常发生进程进行System call的时候，如果这个System call是通信的话，才会和同步和异步有点关系。
阻塞：如果这个线程中有system call，它必须要等到system call完成后，才能继续执行。为了提高系统的吞吐率，操作系统会把这个线程阻塞，进而执行其他线程。
非阻塞：不用等到system call完成，先返回个值，可以是空或者部分的值，然后这个进程不会被阻塞，会继续被操作系统调用。这样该线程可以执行后续的代码段（一般来说操作系统不会挂起该程序，而是会继续确定system call是否执行OK）提高效率。
**这个非阻塞啊，有个好处，在于这个进程在等待I/O操作的不会挂起。如果挂起了，那我还得唤醒这个进程，然后等待前面进程执行完了，空闲了，我才能调度这个进程，反而更慢。**
关于同步与异步、阻塞与非阻塞的不同，知乎有几个回答不错：
https://www.zhihu.com/question/19732473/answer/241673170
https://www.zhihu.com/question/19732473
**我认为两个最主要的区别在于：同步异步是在消息传递机制上，阻塞非阻塞是在线程调度机制上。两个层面不同，但是也有相近的关系。**
1.2 winsock五种I/O模式
为什么要设计winsock的五种I/O模式？
首先考虑阻塞的I/O模型，例如有一个服务器（A）和一个客户端（B）进行连接，A向B发送数据，由于某些原因，A还没成功发送数据，即还在send函数调用阶段，那么该服务器进程（A）将被阻塞，若另一个客户端（C）向A发送连接请求，那么A将无法处理这个请求。
一个最简单的思路就是：那么我给服务器开多个进程，方便处理多个连接。那么这样的坏处就在于进程内存开销很大，我不可能针对每个连接都开个进程去维护。
还有一个思路，那我就设计服务器成单线程非阻塞。那么我应该如何确定哪些和我连接客户端那些客户端发来请求是我应该处理的。
于是引出了winsock的五种I/O模式。
设置非阻塞的套接字函数
ioctlsocket()
{% codeblock lang:C %}
 int ioctlsocket(
      SOCKET s,             //需要设置非阻塞的套接字
      long cmd,             //命令参数，
      u_long* argp 
); 
{% endcodeblock %}
1.2.1 select模型
select模型，也是IO复用模型。其优势在于能够处理单个线程多个IO请求。


