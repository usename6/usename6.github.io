---
title: KD-tree 练习一：HDU 5992 Finding Hotels
date: 2020-03-26 19:46:11
tags: [ACM,machine learning,K-D tree]
categories: [ACM,machine learning,K-D tree]
---
练习机器学习算法也是练习代码功底，以备后续找工作之用。给个预告，下一节试着用K-D Tree做最近点对。
<!--more-->
HDU 5992 Finding Hotels
题意：给出一个N($N \leq 200000$)个宾馆和M($M \leq 20000$)个顾客，给出每个宾馆在二维地图中的坐标和花费，同时给出每个旅客的二维坐标和旅客能承受最大花费，要求对于每一个旅客，找到满足小于最大花费下，离它欧几里得距离最小的旅馆是哪个，如果有多个旅馆，输出编号最近的那个。
题解：K-D Tree，典型的K-D Tree暴力，与最裸的K-D Tree不同的是，你还需要考虑当前旅馆花费是否小于最小花费，这个本题解法没有优化，就是按照K-D Tree建树顺序去搜索（即尽可能贪心与他欧几里得距离最近的点，然后暴力check），可能本身这样搜索就是一个优化和剪枝。
下面介绍K-D Tree算法，这也是本次学习的核心，K-D Tree就是讲一些K维的数据按照一定顺序进行放置，经过这样放置后对于我们解决K维空间最近邻搜索问题起到一定优化。
最早K-D Tree原型要说的话，应该BST，即二叉搜索树，下面回忆下二叉搜索树的一些基本概念：对于一个二叉树而言，每一个节点分别存储一个数值（与线段树一个不同，线段树是每个节点存储区间信息），从这个节点往下可以引出两个分支，第一个分支是小于该节点的左子树，第二个分支是大于该分支的右子树，这样我们只需要在每个节点进行决策，如果大于当前节点，显然我们不需要花太多时间去搜索左子树，同理小于也是一样的。
K-D Tree是当BST推广到二维的一个概念。对于一个良好的搜索数据结构而言，我们希望对于每一个节点来说，它的左右子树是平衡（深度尽量一致），这样能够避免出现链状的二叉树，比如说：8->9->10->11->12->...->100,当然我们想查找比99大的元素的时候，对于这样一个链状的二叉树而言，几乎是O(N),但如果我取中间的节点作为二叉树的根节点，可能左右子树深度一致，能够尽量避免较大搜索。同时对于我们来说还有一个新问题：这些数据有K个维度，我应该是以什么依据划分左右子树。
于是总结下来，建立一个K-D Tree需要考虑以下问题：
1）如何保证K-D Tree是个左右子树平衡的结构？
2）如何划分子树？
首先解决2）问题，如何划分子树，可以思考一个生活场景，现在你的手里拿着黄瓜，黄瓜长20cm,宽6cm,给你一把刀让你对黄瓜分成2分，你会怎么切？对于一个正常人来说，肯定会对着黄瓜长截一刀，得到两个长10cm,宽6cm的黄瓜。同样对于数据也是一样，当一个数据某个维度相差特别大（即该维度的最小值和最大值差别特别大），我们就可以说数据从这里切分是最好的。而在这里，我们一般用数据的方差去衡量是不是差别很大。当方差较大时候，我们认为数据分别比较广，比较好分，当数据的方差很小，我们认为它们都集中在平均值上，不好区分。于是一个很简单方法，我去检查选了该节点后，剩余的节点的方差在K维表现，当第i维方差较大的时候，我们认为从第i维最好分。当然一个最简单方法就是轮着分，第一次我用第一维，第二次用第二维...第K次用第K维。在这道题中，为了方便我们用轮着分。
接下来解决问题1），如何保证K-D Tree是一个平衡结构。因为我们划分子树是以某一个维度去划分。不关心其他维度，于是我们可以把他看成关于第i维（第i维是当前我们划分子树依据）的一维数组。刚刚也说道对于一个数组，比如说1,2,3,4,5去建立二叉树，如果我们取1或者5作为根节点就会出现链状，即左右子树节点数的差值很大。但是我们取3去做，会发现两边子树的节点数都是2，这样可以保持当前的左右子树平衡。注意到3这个数字的特点是刚好是这个数列的中位数。如果我们每一步划分子树都按照取中位数，是不是都能保证每一步的左右子树划分都是平衡。这样整体的左右子树的划分就是平衡的。
好像光光去说，似乎有点勉强，我们举个例子：
![alt](/images/hdu5992/K-DTree.jpg)
上面分别给出了6个平面中二维点，分别为(7,2)、(5,4)、(2,3)、(4,7)、(9,6)、(8,1)，按照上述规则（轮流+中位数），我们可以得到如下一个K-DTree:
![alt](/images/hdu5992/K-DTree2.jpg)
理解上述建树的过程，我们需要考虑的是：如何查询K-D Tree的最近邻？
与不同二叉树不同的是，通常我们都用二叉树去查询比他小的元素，或者是大的元素。而在K-D Tree，我们大多数是查询在树中哪一个节点离当前的节点的欧几里得距离（曼哈顿距离也行）更近。那么我们应该如何查询？
通过总结，我们一般按照如下规则对K-D Tree进行查询：
a.首先按照类似二叉树的方法，对当前节点，按照划分子树规则，即通过比较该元素与当前子树的根节点的第i维大小，如果比他大则进入右子树查询，如果小则进入左子树查询。
b.但由于我们查询距离最近，那么我们可能会思考一个问题就是另外一个分支是否存在更近的点？于是我们就会想采用一种方法去判断是否有更近的点出现在另外一个分支中。我们采用这个方法就是判断以当前查询的节点为原点，以当前最小欧几里得距离为半径，画出一个超平面圆形，同样我们用一个超平面矩形去包含另外一个分支所有的点，看是不是有交集，如果有交集，那么很有可能有比其还小的一个点。
这个a可能很好理解，这个b似乎有点抽象，让我们用一个图去理解这个问题：
![alt](/images/hdu5992/KD-Tree-Search1.png)
黑色的点表示K-D Tree上的点，分别有(2,3)、(5,4)、(4,7)、(2,7)、(1,8)、(6,9)
按照K-D Tree建树规则，我们很快就确认我们搜索顺序先是：
(2,7)->(5,4)->(4,7)
当回溯至(5,4)节点我们需要检查他的下半部分的分支是否是存在更近的点，于是我们以查询点（图中星星点，(2,5)）为圆心画出一个圆。然后我们发现下半分支就是图中最左下角的矩形，我们发现他们有交集，即可能存在更近的点（事实上确实有）。于是我们就会去搜索下面的分支：
![alt](/images/hdu5992/KD-Tree-Search2.png)
那么现在一个问题，在于我们如何确定矩形和圆是否可能存在交集，最简单的方法就是存下下半分支的按极角排序的最近的点表示矩形左下角，最远的点表示右上角。然后判断是否有交集，但这样太麻烦不好维护，我们注意到当我们回溯到(5,4)的时候，上下分支是依据y坐标划分的，那么(5,4)一定是下面区域中最高的那个点（肯定的，根据建树规则思考）。那么若这个点与(2,5)在y坐标方向的距离小于半径，那必然会有交集，所以我需要去继续搜索下一个分支判断是否有距离更小的元素。
注意：也可能另一个分支不存在最小的元素，但是相交后可能性较大，用其他方法排除是否存在最小的元素可能条件更弱，容易TLE的。

下面给出HDU这个题的code(题解上面已经说了，就一句话按K-D Tree顺序搜索相当于剪枝，速度更快吧)：
{% codeblock lang:C %}
#include <bits/stdc++.h>
#define sq(x) (x)*(x)
using namespace std;
const int MAXN = 2e5+4;
typedef long long LL;
int idx;
inline int read()
{
    int x(0),f(1);
    char ch=getchar();
    while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*f;
}
struct Point
{
    int x[2];
    int w,id;
    const bool operator <(const Point &tp)const
    {
        return x[idx]<tp.x[idx];
    }
};
Point pt[MAXN];
Point q;
typedef pair<LL,Point> PDN;
priority_queue<PDN> que;
int k=2,m=1;
struct KDTree
{
    Point p[MAXN<<2];
    int sz[MAXN<<2];
    void build(int l,int r,int rt,int dep)
    {
        if(l>r)return;
        sz[rt]=r-l;
        sz[rt<<1]=sz[rt<<1|1]=-1;
        idx=dep%2;
        int mid=(l+r)>>1;
        nth_element(pt+l,pt+mid,pt+r+1);
        p[rt]=pt[mid];
        build(l,mid-1,rt<<1,dep+1);
        build(mid+1,r,rt<<1|1,dep+1);
    }
    void query(int rt,int m,int dep,Point q)
    {
        if(sz[rt]==-1)return;
        int idx=dep%k,left=rt<<1,right=rt<<1|1;
        PDN tmp=PDN(0,p[rt]);
        for(int i=0;i<k;i++)tmp.first+=sq(1LL*(p[rt].x[i]-q.x[i]));
        if(q.x[idx]>p[rt].x[idx])swap(left,right);
        if(sz[left]!=-1)query(left,m,dep+1,q);
        bool flag=false;
        if((int)que.size()<m)
        {
            if(p[rt].w<=q.w)
                que.push(tmp);
            flag=true;
        }
        else
        {
            if(tmp.first<que.top().first&&p[rt].w<=q.w)que.pop(),que.push(tmp);
            if(tmp.first==que.top().first&&p[rt].w<=q.w&&p[rt].id<que.top().second.id)que.pop(),que.push(tmp);
            if(sq(q.x[idx]-p[rt].x[idx])<que.top().first)flag=true;  //查询另外部分矩形和圆形是否相交
        }
        if(sz[right]!=-1&&flag)query(right,m,dep+1,q);
    }
}T;
int n,ask;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        n=read();ask=read();
        for(int i=0;i<n;i++)
        {
            pt[i].id=i;
            pt[i].x[0]=read();pt[i].x[1]=read();pt[i].w=read();
        }
        T.build(0,n-1,1,0);
        while(ask--)
        {   q.x[0]=read();q.x[1]=read();q.w=read();
            T.query(1,m,0,q);
            printf("%d %d %d\n",que.top().second.x[0],que.top().second.x[1],que.top().second.w);
            que.pop();
        }
    }
    return 0;
}
{% endcodeblock %}