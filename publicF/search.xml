<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PDD笔试题]]></title>
    <url>%2F2021%2F08%2F02%2FPDD%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[PDD笔试题2021，后台开发Java。质量很高的一套题。A.题意：题解：不难，排序后，一个个比较是否包含就行。code:1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;//结构体的二维排序class Line&#123; int l,r; public Line()&#123;&#125; public Line(int ll,int rr)&#123; l=ll; r=rr; &#125; @Override public String toString()&#123; return "l = " + this.l + ", r = " + this.r; &#125;&#125;public class ProblemA &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int n = cin.nextInt(); Line[] lines = new Line[n]; for(int i=0;i&lt;n;i++)&#123; lines[i] = new Line(); lines[i].l=cin.nextInt(); lines[i].r=cin.nextInt(); &#125; Arrays.sort(lines, new Comparator&lt;Line&gt;() &#123; @Override public int compare(Line o1, Line o2) &#123; if(o1.l == o2.l) return o1.r - o2.r; else return o1.l - o2.l; &#125; &#125;); boolean flag=true; for(int i=1;i&lt;n;i++)&#123; if(lines[i].r&gt;lines[i-1].r)&#123; flag=false; break; &#125; &#125; if(flag) System.out.println("false"); else System.out.println("true"); &#125;&#125; B.题意：题解：按题意模拟，考察Java容器的使用方法。可作为模板。code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;public class ProblemB &#123; static int cnt=0; static int [] c = new int[100005]; static Map&lt;Integer, Integer&gt; hashMap = null; static int setcards(int val)&#123; //O(1)的复杂度 if(hashMap.containsKey(val))&#123; int p = hashMap.get(val); if(p&gt;cnt)&#123; c[++cnt]=val; //set hashMap.put(val,cnt); return 0; &#125; int num = cnt-p+2; cnt=p-1; //只有前p-1有效 return num; &#125; c[++cnt]=val; hashMap.put(val,cnt); return 0; &#125; public static void main(String[] args) &#123; int [] a = new int[100005]; int [] b = new int[100005]; Scanner cin = new Scanner(System.in); int N = cin.nextInt(); for(int i=1;i&lt;=N;i++)a[i]=cin.nextInt(); for(int i=1;i&lt;=N;i++)b[i]=cin.nextInt(); cnt = 0; int count1=0,count2=0,ans1=0,ans2=0; hashMap = new HashMap&lt;Integer, Integer&gt;(); while(count1&lt;N||count2&lt;N)&#123; while(count1&lt;N)&#123; count1++; int tag=setcards(a[count1]); if(tag&lt;=0)break; ans1+=tag; &#125; while(count2&lt;N)&#123; count2++; int tag=setcards(b[count2]); if(tag&lt;=0)break; ans2+=tag; &#125; &#125; for(int i=1;i&lt;=cnt;i++)&#123; if(c[i]%2!=0)ans1++; else ans2++; &#125; System.out.println(ans1+" "+ans2); &#125;&#125;例子：1234567891011121314151617181920212223242526272829303132333435363738394041Input:41 2 3 41 2 3 4Output4 4Input:42 3 1 21 4 3 4Output:7 1Input:42 3 1 21 4 4 4Output:6 2Input:31 2 34 5 1Output:0 6Input:31 2 34 5 6Output:3 3Input:51 2 5 1 34 3 3 4 3Output:4 6 C.题意：题解:数学题，需要推出通项公式：若一个数在集合$S$中，那么有：(1)式： S_{i} = S_{i-1} * C^{k_{i}} + t_{i} * B, i=1,2,...N(2)式： S_{i-1} = S_{i-2} * C^{k_{i-1}} + t_{i-1} * B, i=1,2,...N联合(1)和(2)，得： S_{i} = （S_{i-2} * C^{k_{i-1}} + t_{i-1} * B) * C^{k_{i}} + t{i} * B, i=1,2,...N化简有： S_{i} = S_{i-2} * C^{k_{i-1}+k_{i}} + (t_{i-1} * C^{k_{i}} + t{i}) * B, i=1,2,...N我们令$ KK = k{i-1} + k{i} $,并且令$ TT = (t{i-1} * C^{k{i}} + t{i}) $, 这里显然KK和TT可以取到N上的任意整数。那么就会得到： S_{i} = S_{i-2} * C^{KK} + TT * B化简得到通项： S_{i} = S_{0} * C^{K} + T * B故只需要枚举$K$，然后判断$(Q - C^{k}*A) % B == 0$即可。特殊地若C=1，那么只需判断 $ (Q % B) == A $code：1234567891011121314151617181920212223242526272829303132import java.util.*;public class ProblemC &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int T=cin.nextInt(); while(T&gt;0)&#123; T--; int A = cin.nextInt(); int B = cin.nextInt(); int C = cin.nextInt(); int Q = cin.nextInt(); if(C==1)&#123; if(Q%B==A) System.out.println("1"); else System.out.println("0"); &#125; else&#123; int res=1; boolean tag=false; for(int i=0;i&lt;=32;i++)&#123; if(res&gt;Q)break; if((Q-res*A)%B==0)&#123; tag=true; break; &#125; res=res*C; &#125; if(tag) System.out.println("1"); else System.out.println("0"); &#125; &#125; &#125;&#125; D.题意:题解:贪心，首先数字被分的越多，乘积越小。数字越少，越大。故这里肯定是将这些数分成两个数合理。这题的结论是让两个数的差值尽可能小。（这个结论是猜的，证明暂时略）code:12345678910111213141516171819202122232425262728293031323334import java.math.BigInteger;import java.util.Scanner;public class ProblemD &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int []cnts = new int[10]; int []a = new int[100005]; for(int i=0;i&lt;10;i++)cnts[i]=cin.nextInt(); BigInteger A = new BigInteger("0"); BigInteger B = new BigInteger("0"); int cnt=0; for(int i=9;i&gt;=0;i--)&#123; for(int j=1;j&lt;=cnts[i];j++)&#123; a[++cnt]=i; &#125; &#125; for(int i=1;i&lt;=cnt;i+=2)&#123; if(A.compareTo(B)&lt;=0)&#123; A = A.multiply(BigInteger.valueOf(10)); A = A.add(BigInteger.valueOf(a[i])); B = B.multiply(BigInteger.valueOf(10)); B = B.add(BigInteger.valueOf(a[i+1])); &#125; else&#123; A = A.multiply(BigInteger.valueOf(10)); A = A.add(BigInteger.valueOf(a[i+1])); B = B.multiply(BigInteger.valueOf(10)); B = B.add(BigInteger.valueOf(a[i])); &#125; &#125; System.out.println(A.multiply(B)); &#125;&#125;]]></content>
      <categories>
        <category>Java 笔试题</category>
      </categories>
      <tags>
        <tag>Java 笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐式马尔科夫的学习]]></title>
    <url>%2F2020%2F04%2F29%2F%E9%9A%90%E5%BC%8F%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%2F</url>
    <content type="text"><![CDATA[学习一下隐式马尔科夫这个问题。（好像除了参数估计，就是个概率DP啊，摔一、基本概念所有可能状态集合： Q = (q_1, q_2, ... , q_n)所有可观测集合： V = (v_1, v_2, ... , v_M)长度为T的状态序列：I = (i_1, i_2, ... , i_T)长度为T的观测序列：O = (o_1, o_2, ... , o_T)初始概率分布： \pi = (\pi_{1}, \pi_{2}, ... , \pi_{n})其中： \pi_{i} = P(i_t=q_i) , i=1,2,...N状态转移矩阵： A = [a_{ij}]其中： a_{ij} = P(i_{t+1} = q_j | i_t = qi), i=1,2,...,N; j=1,2,...,N.观测转移矩阵： B = [b_{ij}]其中： b_{ij} = P(o_t = v_j | i_t = q_i), i=1,2...,N;j=1,2,...,M两个基本假设：1）齐次马尔科夫性假设：即假设隐藏的马尔科夫链在任意时刻t的状态只依赖于前一个时刻的状态。与其他时刻状态及观测无关，也与t时刻无关。2）观测独立假设：即假设任意时刻观测只依赖于该时刻的马尔科夫链的状态，与其他观测及状态无关。具体例子，请参考《统计学习方法》 第10章隐式马尔科夫的第一节，对着例子思考，这些概念会很清晰。三个基本问题：a. 概率计算，给定观测序列，计算在参数\lambda下的该观测序列的概率是多少？b. 参数估计，给定观测序列，估计参数c. 预测，给定观测序列，预测导致对应隐藏状态是多少。二、概率计算问题2.1 前向概率计算定义foward[i][j]表示第j时刻，状态为i的概率是多少？初值：foward[i][1] = \pi[i] \times b[i][o_1]转移方程： foward[i][t] = \sum_{j=1}^N{(foward[j][t-1] \times a[j][i])} \times b[i][o_t] , t \gt 1最终结果： ans = \sum_{i=1}^N forward[i][T]2.2 后向概率计算定义backward[i][j]表示从j+1时刻起，状态为i的概率是多少？初值： backward[i][T] = 1转移方程： backward[i][t] = \sum_{j=1}^N{(backward[j][t+1] \times a[j][i])} \times b[j][o_{t+1}] , t \lt T最终结果： ans = \sum_{i=1}^N{(\pi_i \times b[i][o_1] \times backward[i][1])}注：因为T+1以后的结果不再关心，所以可以虚拟出一个节点，将所有状态节点概率流入这个节点，所以这个节点的概率是1，结合后向概率的概念，所以backward[i][T]被初始化为1。三、参数估计（简单介绍，暂时略过，在学习最大似然估计和最大后验估计等等参数估计方法，会补充说明）主要是对转移状态矩阵和观测转移矩阵的估计，根据输入的训练数据的输入（是否包括状态序列），又分为有监督和无监督型学习方法。四、预测问题4.1 近似算法这个算法很简单，是一种贪心算法，就是每个时刻都选择一个概率最大的状态作为该时刻的估计状态。首先定义：前向概率： \alpha_{t}(i) = forward[i][t]后向概率: \beta_{t}(i) = backward[i][t]那么时刻t处于状态q_i的概率\gamma_{t}(i) = \frac{\alpha_{t}(i) \times \beta_{t}(i)}{\sum_{j=1}^N{\alpha_{t}(j) \times \beta_{t}(j)}}那么得到最有可能的状态 I_{t} = arg\,\max_{1 \le i \le N} [\gamma_{t}(i)]4.2 维比特算法这个算法就是概率DP：定义DP[i][t]表示t时刻下，状态为q_i的概率。初值： DP[i][1] = \pi_{i} \times b[i][o_1]转移: DP[i][t] = max(DP[j][t-1] \times b[j][o_{t-1}] \times a[j][t])，t \lt T最终结果：ans = max(DP[i][T])然后在回溯求得这个路径就行了。用C++ 搞搞这个代码，python的版本太多了。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#define MAXN 100class HMM&#123;public: int N, M, T; //N表示可能的状态数，M表示可能的观测数，T表示时间 int O[MAXN]; //输入观测序列 double forward[MAXN][MAXN], backward[MAXN][MAXN], pi[MAXN]; //forward表示前向概率，backward表示后向概率 double A[MAXN][MAXN], B[MAXN][MAXN]; //A状态转移矩阵，B观测转移矩阵 double DP[MAXN][MAXN]; //Predict中的中间结果 int mark[MAXN][MAXN]; int L[MAXN]; //Predict序列值 HMM()&#123;&#125; void Input() &#123; //输入状态转移矩阵 for (int i = 1; i &lt;= N; i++) for (int j = 1; j &lt;= N; j++) std::cin &gt;&gt; A[i][j]; //输入观测转移矩阵 for (int i = 1; i &lt;= N; i++) for (int j = 1; j &lt;= M; j++) std::cin &gt;&gt; B[i][j]; //输入初始概率 for (int i = 1; i &lt;= N; i++) std::cin &gt;&gt; pi[i]; for (int i = 1; i &lt;= T; i++) std::cin &gt;&gt; O[i]; &#125; HMM(int n,int m,int t) &#123; N = n; M = m; T = t; Input(); &#125; void init_forward() &#123; for (int i = 1; i &lt;= N; i++) forward[i][1] = pi[i] * B[i][O[1]]; &#125; void init_backward() &#123; for (int i = 1; i &lt;= N; i++) backward[i][T] = 1; &#125; void init_predict() &#123; for (int i = 1; i &lt;= N; i++) DP[i][1] = pi[i] * B[i][O[1]]; &#125; void solve() &#123; for (int t = 2; t &lt;= T; t++) &#123; for (int i = 1; i &lt;= N; i++) &#123; mark[i][t] = 0; DP[i][t] = 0; for (int j = 1; j &lt;= N; j++) &#123; double tmp = DP[j][t-1] * A[j][i] * B[i][O[t]]; if (DP[i][t] &lt; tmp) &#123; DP[i][t] = tmp; mark[i][t] = j; &#125; &#125; &#125; &#125; double ans = 0.0; for (int i = 1; i &lt;= N; i++) &#123; if (ans &lt; DP[i][T]) &#123; ans = DP[i][T]; mark[0][T + 1] = i; &#125; &#125; &#125; double forward_cal() &#123; init_forward(); for (int t = 2; t &lt;= T; t++) &#123; for (int i = 1; i &lt;= N; i++) &#123; forward[i][t] = 0; for (int j = 1; j &lt;= N; j++) &#123; forward[i][t] += forward[j][t - 1] * A[j][i] * B[i][O[t]]; // j--&gt;i，且i的状态取o[t] &#125; &#125; &#125; double ans = 0.0; for (int i = 1; i &lt;= N; i++) ans = ans + forward[i][T]; return ans; &#125; double backward_cal() &#123; init_backward(); for (int t = T - 1; t &gt; 0; t--) &#123; for (int i = 1; i &lt;= N; i++) &#123; backward[i][t] = 0; for (int j = 1; j &lt;= N; j++) &#123; backward[i][t] += backward[j][t + 1] * A[i][j] * B[j][O[t+1]]; &#125; &#125; &#125; double ans = 0.0; for (int i = 1; i &lt;= N; i++) ans = ans + backward[i][1] * pi[i] * B[i][O[1]]; return ans; &#125; void get_list(int t,int pre) &#123; L[t] = mark[pre][t + 1]; if (t&gt;1) get_list(t - 1, L[t]); &#125; void output() &#123; for (int i = 1; i &lt;= T; i++) std::cout &lt;&lt; L[i] &lt;&lt; " "; std::cout &lt;&lt; "\n"; &#125; void predict() &#123; //初始化 init_predict(); solve(); get_list(T, 0); output(); &#125;&#125;;int main()&#123; HMM work=HMM(3, 2, 3); std::cout &lt;&lt; work.forward_cal() &lt;&lt; "\n"; std::cout &lt;&lt; work.backward_cal() &lt;&lt; "\n"; work.predict(); system("pause"); return 0;&#125;/*0.5 0.2 0.30.3 0.5 0.20.2 0.3 0.50.5 0.50.4 0.60.7 0.30.2 0.4 0.41 2 1*/书中例子：1234567891011121314151617Input:0.5 0.2 0.30.3 0.5 0.20.2 0.3 0.50.5 0.50.4 0.60.7 0.30.2 0.4 0.41 2 1Output:0.1302180.1302183 3 3]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 网络编程（二） --- TCP传输]]></title>
    <url>%2F2020%2F04%2F28%2Fwinsock-2%2F</url>
    <content type="text"><![CDATA[国际投资学作业公布了，要写小论文，然后还得赶毕设，最近有可能会咕咕一段时间？一、TCP 传输的基本概念1.1 TCP报文格式在本节，我们重点关注的是SYN、ACK、FIN选项。1）SYN介绍先介绍一个概念叫ISN（Initial Sequence Number），在三次连接过程中，客户端和服务端在建立TCP连接时，双方都会发送SYN报文，并初始化序号。那么为什么需要初始化序列号呢？可以举一例说明。假设服务端（A），客户端（B）建立连接，分别使用固定序列号1和2。当A和B建立TCP连接后，B由于一部分原因重启了，那么这条TCP连接将被A废弃。但可能因为网络延迟，B发送给A的数据还在传输，并未送达A。那么在B重启后，B在重新和A建立TCP连接，在发送新的数据包，那这样就会出现A端既接收了废弃连接数据包、同样也接收新数据连接包，导致错误发生。且注意ISN一般不能取固定值，若ISN固定了，攻击者很容易知道该客户端的ISN是多少，那他就可以根据需要创建和客户端（B）相同的IP和端口，并建立相同的ISN，这样的话就可以进行攻击。SYN，又称同步序列编号（Synchronize Sequence Numbers），该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。（检查的目的就是防止对废弃连接得到数据包进行错误解释，上面已经说明了）。参考：https://zhuanlan.zhihu.com/p/86426969?utm_source=qq&amp;utm_medium=social&amp;utm_oi=852178998824955904ACK：确认标志，又称（Acknowledgement Number），提示远端系统服务端已经成功接收客户端发送的sequence，期待下一个sequence的到来。FIN: 主要用于结束一个TCP连接。1.2 三次握手具体地：第一次握手：客户端给服务端发送一个SYN报文，并指明客户端的初始序列号(ISN-c),此时客户端处于SYN_SEND状态。同步位SYN = 1,seq = x。注意：不能携带数据。第二次握手：服务端接收到客户端的SYN报文后，会以自己SYN、ACK的报文作为应答，同时指明了自己的初始序列号(ISN-s)。服务端处于SYN_REVD状态。SYN = 1，seq = y, ACK = x+1第三次握手：客户端接收到SYN数据报之后，会同服务器一样，以SYN、ACK报文作为应答，此时客户端处于ESTABLISHED状态。服务端接收到客户端发来的SYN、ACK报文后，也会处于ESTABLISHED状态。此时双方成功建立连接。第三次握手可以携带数据，第一、第二次不行。为什么要三次握手？回答这个问题，需要知道三次握手每一次握手的目的是什么？第一次握手：服务端能够得出结论：客户端的发送能力、服务端的接收能力都是正常的。第二次握手：客户端能够得出结论：服务端的发送、发送能力、客户端的发送、接收能力都是正常的。如果仅仅只是第二次握手，其实服务端并不知道客户端的接收能力是怎么样的。所以需要客户端对这个报文进行响应。第三次握手：服务端能够得出结论：客户端的发送接收能力、服务端的发送接收能力正常。所以我们需要经过三次握手才能得出这样的结论。1.3 四次挥手第一次挥手：客户端发送FIN报文，报文中会指定一个序列号，此时客户端处于FIN_WAIT1状态。即在发出释放连接的报文后，停止发送数据，并进入FIN_WAIT1，并等待服务端的确认。第二次挥手：服务端接收FIN报文，发送ACK报文响应客户端发送的FIN报文，通知客户端已经收到报文。此时服务器进入CLOSE_WAIT的状态。TCP连接进入半关闭状态（客户端到服务端关闭）。客户端收到服务端的确认后，进入FIN_WAIT2状态，这时主要等待的是服务端发出的连接释放报文段。第三次挥手：当服务端也想断开连接了（比如说没什么事情要告诉客户端了），服务端也会发送一个FIN报文，并指定一个序列号，此时服务端也处于LAST_ACK的状态。这时候服务端等待客户端的确认。第四次挥手：客户端收到来自服务端的FIN报文后，发送一个ACK报文作为应答，此时客户端进入TIME_WAIT状态。（此时TCP连接还没有被释放掉） 需要经过2 MSL后，客户端进入CLOSED状态。那么有几个问题需要考虑下：a. 为什么要进行四次挥手？第一次、第二次挥手仅仅表示客户端（服务端）不再发送数据，服务端（客户端）可以关闭对客户端（服务端）的接收。而第三次、第四次则是服务端（客户端）不再发送数据。如果仅仅只是两次挥手就关闭所有连接，可能对方某些想要发送数据被迫中断，容易导致错误的发生。b. 为什么要等待两个MSLTIME_WAIT状态设置为2MSL的等待事件。（其中MSL表示Maximum Segment Lifetime，表示任何报文段被丢弃前在网络内的最长时间。）。因为若服务端（客户端）没有收到客户端（服务端）发来ACK请求，可以再重发一次FIN报文，申请断开所有连接。首先服务端（客户端）至多需要经过一个MSL后才能判断是否接收到客户端（服务端）发来ACK，若没有接收到，则需要重新发送FIN报文，而FIN报文到达客户端（服务端）。所以客户端需要等待2MSL，才能判断是否需要关闭连接。若2MSL内，没有收到任何报文，则可以关闭连接。1.4 超时重传RTO,Retransmission TimeOut，若对方超过RTO都没有接收到消息，可以申请向我方申请重传。这个RTO不宜过大，若太大了，则会使网络的吞吐率变小，若RTO太小，有些延迟较大的报文则会被认为丢失，造成不必要重传。一般来说，RTO设置依赖于RTT（Round Trip Time），往返时延，这个往返时延可以通过一些算法进行估算，从而设置RTO。1.5 TCP连接涉及的状态二、winsock - TCP2.1 状态转换图简单介绍在winsock中，TCP的三次握手和四次挥手在winsock中哪些阶段体现。1）首先服务端初始化socket后，调用listen函数，进入监听状态。2）客户端初始化socket后，首先调用connect函数，相当于发送SYN J。3）服务端监听到这个信号后，在accept阻塞，然后进行后续两次握手（前一次在监听的时候已经做了）。注：3）的具体过程，在上述状态图已经解释，这里不再详细说明。4）三次握手之后，新建连接套接字，并返回这个套接字，accept不再被阻塞。四次挥手：上述过程，主要是客户端发送FIN先被服务端接收的时候结果。上述情况是服务端先申请关闭连接，可以发现和上面状态刚好反过来。上述情况是同时到达的情况。]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神经网络学习(一) --- 卷积部分]]></title>
    <url>%2F2020%2F04%2F22%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C1%2F</url>
    <content type="text"><![CDATA[烂笔头疗法，学习下神经网络的卷积部分，（只是理论部分，改天有时间实操几个问题。。一、卷积1.1 卷积的概念摆个图，应该就懂了（逃卷积的作用：在于能提供和挖掘物体的某些共有特征先放一张图在下面，然后介绍一些专有名词：input_channel: 输入数据的channel个数，对应每个kernel(filter)有多少个channel。output_channel:输出数据(feature map)的channel个数，对应有多少个kernel(filter)。kernel(filter): 卷积核，如图所示，黄色的部分padding: 在图片最外圈补零。如果padding等于，就相当于补两圈0，最后得到输入的size为(h+2,w+2)。stride:卷积核每次移动的补偿，上图卷积核stride为1。feature map:最后得到的输出。如何计算feature map的size outputsize=(inputsize-kernelsize+2 \times padding)/stride+11.2 特殊的卷积 —— 1x1卷积的作用1）channel-wise full connection （跨通道信息结合）可以按照将feature map中的(x,y)的不同channel连接起来，这样相比全连接层参数更少，更节省空间。在16年CVPR 《Context Encoders: Feature Learning by Inpainting》有提及。如果想保持输入和输出size一样，使用全连接的参数比1x1卷积多。2）升维、降维：这主要是指channel维度。二、反卷积（转置卷积）2.1 反卷积的概念反卷积主要作用，举个我现在正在图像修补的任务来说，图像修补主要采用类似Encoder-Decoder的结构，Encoder主要采用卷积将语义信息编码，在decoder阶段主要使用反卷积（转置卷积）进行解码，还原原图的分辨率。我认为这种结构应该常见于类似UNet的网络的结构。（或是图像修补任务中）。那么反卷积是什么呢？下图是反卷积的常见的过程。在这里,$ kernel_size = 3, padding = 1, stride = 2$。那么你可能会觉得好奇，按照正常卷积那套，这里的stride不应该是1吗。这里就是反卷积和卷积的不同。反卷积的stride并不代表每次点乘后需要将kernel移动多少个单位，而是代表我需要在input里面插入每两列、每两行插入stride-1的列（行）的0。注：padding决定边界插入多少列（行）的0。下图给个stride为1的反卷积，这个实际上和卷积的参数是相同。（$padding=2,stride=1,kernelsize=3$）2.2 如何计算反卷积的output_size反卷积的output_size其实可以先算出中间插入0后新的input_size，再利用stride=1、padding、kernel_size计算新的feature_map的大小。知乎硬是没看懂。。。（那个取mod不是搞笑吗，不是变成蛋生鸡还是鸡生蛋的问题了吗？那这样我还不如直接模拟，或者就考虑没有余数的情况）https://www.zhihu.com/question/48279880反正正常情况：$ ((inputsize - 1) \times stride + 2 \times padding - kernelsize) / 1$,(化简过，别怀疑为什么没有+1)。三、空洞卷积(膨胀卷积)3.1 空洞卷积的概念还是给个图感受下：dilate=2，kernel_size=3,padding=0。3.2 感受野概念及应用感受野就是当前的feature map的每一个节点和多少个输入节点相关。例如下图，倒数第二层的feature map每个节点由输入的两个节点构成。那么相当于感受野是2。我们上面（蓝色）的图的倒数第3层节点感受野是4，而在第二层跳过一个节点做连接的感受野是5，感受野增大，主要是跳过一些节点后，重复感受野区域减小了，非重复区域增多，所以导致感受野整体增大。图像修补应用：感受野通常应用在目标检测、语义分割、图像修补等领域。例如基于anchor的目标检测，如果卷积捕捉的语义太小，那么很有可能不足以表征整个anchor的语义无法进行正确的目标检测。例如盲人摸大象，你只摸到象腿，能猜出这个是象吗？对于图像修补，如果捕捉语义太小，很有可能捕捉的仍是空洞的语义，这样必然会导致结果更加模糊。如下图所示：不过以上的推理都是理论的感受野，并不是在卷积过程中真正的感受野。由于在卷积过程中，事实上会有些节点重复编码到一个feature map的节点中，这样该节点对feature map的这个节点贡献较大。所以并不是感受野中每个节点对feature map的某一节点影响是等同的。一般是呈现高斯分布（在感受野中间的节点值对该feature map的这个节点影响较大）。来源：2016 NIPS 《Understanding the Effective Receptive Field in Deep Convolutional Neural Networks》一个本人觉得讲的不错解释：https://zhuanlan.zhihu.com/p/402671313.3 空洞卷积与卷积的区别普通卷积也可以增加感受野，通常由两种操作：a.卷积后增加池化层b.卷积加stridea操作的缺点在于池化层增加参数和计算的复杂度，而且损失了更多的信息。b操作的缺点在于加入stride后，感受野的增加是延迟的。不能在当前层起效。比如说你当前进行stride=2的卷积，那么想要增加感受野，必须在这之后再加一层卷积，这层卷积后得到feature map比原来经过stride=1卷积后在卷积的feature map感受野大。而空洞卷积则不存在上述问题，即空洞能及时的进行感受野增大，能保证用较小的参数、损失较小的信息实现feature map的感受野的增加增加。五、depthwise卷积、pointwise卷积首先我们要知道常规卷积的操作是怎么样，如下图所示：而事实上，我们可以拆分成两步：Depthwise Convolution与Pointwise Convolution。首先是Depthwise Convolution：如下图所示，有多少个input_channel，就有多少个深度卷积核(channel都是1)，且每个深度卷积核只和对应的channel的输入进行卷积。而后是Pointwise Convolution:如下图所示，output_channel = filter_count，而每一个卷积核的size为1 x 1 x input_channel。可以发现：原来参数个数为：$3 \times 3 \times 3 \times 4 = 108$而现在的参数: $3 \times 3 \times 3 + 1 \times 1 \times 4 = 31 $参数近乎减少到原来的1/3，让我们再来看卷积的计算次数（只关注乘法，因为乘法消耗的CPU or GPU时间周期更大）：原来： $origincnt = H \times W \times 4 \times 3 \times 3 $而现在：$curcnt = H \times W \times 3 \times 3 \times 3 + H \times W \times 4 \times 1 \times 1 $乘法次数大幅度减少。这样能够大幅度减少参数和卷积次数，大大降低时间复杂度和空间复杂度。是一种优化的方式。六、其他卷积部分卷积最早是由ECCV 2018年的一篇论文《Image Inpainting for Irregular Holes Using Partial Convolutions》。由NVIDIA提出来一种概念，他们团队认为普通卷积没有考虑每个节点对该区域影响权重，而错误将每个节点视为等同，这样容易导致填补过程的歧义（我口胡的：可以理解为动态规划的具有后效性，比如说当前有缺失像素A和缺失像素B，卷积核先利用缺失像素B的信息先将缺失像素A进行补洞，而后利用缺失像素A的信息再对缺失像素B进行补洞，这样容易混乱，如果我们加入权值，就可以令B像素对A像素填充权重更小以避免这钟情况的发生。），这因为这种特性，所以可以使用部分卷积有利于对非规则区域的像素进行填充。（因为如果直接卷积，容易导致补洞的过拟合，如把很多没用的区域考虑进去了，出现模糊的现象。）具体方法如下：门卷积是在部分卷积上的改进版本。由Yu、Adobe Research、ByteDance Research的团队在ICCV(oral)《Free-Form Image Inpainting with Gated Convolution》提出来一项技术。Yu认为部分卷积并不能很准确区分那些像素是有效的，那些像素对该区域的语义信息编码、或者是补洞是有效的。例如说下面两个Patch，在部分卷积中则会视为等同： \begin {pmatrix} 1 & 1 & 1 \\ 1 & 1 & 1\\ 1 & 1 & 1 \end {pmatrix} \begin {pmatrix} 0 & 0 & 0 \\ 0 & 0 & 1\\ 0 & 0 & 1 \end {pmatrix}其中0表示missing pixel，而1表示known pixel。很明显上面的区域更容易看成（编码）一个known region，对补洞的贡献更大。而下面的区域更容易被编码成unkown region，对补洞贡献要小一些，而在部分卷积中这两者是等同，明显不合理，当然作者还举了其他不合理的地方，这里不一一列出了。（大概在文中Introduction的第四段）]]></content>
      <categories>
        <category>神经网络，machine learning</category>
      </categories>
      <tags>
        <tag>神经网络，machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 网络编程（一） --- 初识socket]]></title>
    <url>%2F2020%2F04%2F21%2Fwinsock-1%2F</url>
    <content type="text"><![CDATA[这周组会真的是灾难，还得要优化代码，真是难受。。。一、背景1.1 OSI、TCP/IP网络模型越高层服务对象越高，低级服务交给底层去完成，这样每一层只需要关注自己即可。1.2 网络编程位置可以看到Socket网络编程主要是为传输层和网络层服务。传输层：端到端的传输方式。（即主机应用程序之间的传输方式）。协议主要有面向连接的TCP和面向无连接的UDP协议。网络层：点到点的通信，通过路由选择算法，选择合适路径，经由多个路由器之后，传输到目的节点的网络上。再由数据链路层和物理层传递到对应的主机（MAC地址）上。也就是说SOCKET编程能够实现进程和进程之间面向连接和面向无连接的功能。二、什么是Socket2.1 Socket的概念首先先得说明一个故事，简单说明网络通信的过程。假设有一个家庭A，成员有小明、小花、小聪。每个人都有一个自己发送和接收邮箱。每个人只能读取自己邮箱的文件。家庭B，成员有小哥、小弟两人，同样每个人也有一个自己的发送和接收邮箱。家庭A位于H区。家庭B位于S区。如果小明想和小哥通信。那会经历以下几个过程。a.首先将写好的信件，放入自己发送邮箱中。b.然后通知快递员来拿，快递员先将邮件传到H区的传输中心。c.接着再由汽车，经由Q区、W区、I区（H区与S区的最短路径）传输中心，达到S区传输中心。d.接下来再通知S区快递员，让S区快递员将邮件送入到家庭B对应小哥的接收邮箱中。这实际上类似于网络通信的过程。家庭A，家庭B ——&gt; 主机。小明，小花，小聪，小哥，小弟 ——&gt; 进程。发送邮箱，接收邮箱 ——-&gt; 端口。H区、Q区、W区、I区、S区传输中心 —-&gt; 网关和路由器。汽车 —-&gt; 网络层的传输的过程。快递小哥 ——&gt; 数据链路层，物理层传输到网关的过程。从网络通信的角度理解，这里socket指的是端口，即发送邮箱和接收邮箱，进程只需要把数据交付给邮箱，他可以选择如何交付，比如说加急交付等。这是他可以操作的过程。但是传输的过程并不是由他控制。而是由快递员和汽车（操作系统、线路等等控制）。简单的说，socket通过将IP地址和端口号绑定起来，用来唯一表示主机中的进程通信的端口。是应用层和传输层之间的端口（API）。从操作系统角度理解，socket指的是操作系统类似文件的一种资源。用句柄表示。2.2 socket的好处1）方便调试。（只需要关注进程，传输交由操作系统）2）方便编写代码。（只需要关注进程，传输交由操作系统）3）屏蔽了底层复杂的网络操作。2.3 socket的种类一共分为三种：字节流套接字（TCP）、数据报套接字（UDP）、原始套接字（IP）。三、初识winsocket3.1 认识头文件 ——— winsock.h导入投文件1#include &lt;winsock.h&gt;注意：在Visual studio中需要导入12#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#pragma commet(lib, "Ws2_32.lib")第二个目的可以简单解释下：主要和程序的编译运行相关。.h 文件指明了函数接口在哪？ —- 编译需要用.lib 文件指明了链接器调用的函数在哪个dll中 —- 链接时需要用.dll 可执行代码 —- 运行时用。在程序中必须依次指定这三个文件的路径，否则无法正确执行。3.2 初始化winsocketWSAStartup (WORD wVersionRequested,LPWSADATA lpWSAData)(1)wVersionRequested: 高阶字节指定小版本（修订本）号，低位字节指定主版本号。这里的版本号指的都是socket的版本号。Eg.WORD sockVersion = MAKEWORD(minorVer, majorVer); //其中minorVer = majorVer = 2，表示采用winsock2的API。(2)IpWSAData指定WSADATA数据结构的指针，用来接收Window sockets实现的细节（即dll库中的细节）。在WSAStartup调用后将对WSAdata进行一次初始化。WSADATA的结构具体如下：123456789typedef struct WSAData &#123; WORD wVersion; // 库文件建议应用程序使用的版本 WORD wHighVersion; // 库文件支持的最高版本 char szDescription[WSADESCRIPTION_LEN+1]; // 库描述字符串 char szSystemStatus[WSASYS_STATUS_LEN+1]; // 系统状态字符串 unsigned short iMaxSockets; // 同时支持的最大套接字的数量 unsigned short iMaxUdpDg; // 2.0版中已废弃的参数 char * lpVendorInfo; // 2.0版中已废弃的参数&#125; WSADATA, * LPWSADATA;(3)返回值：整型，成功返回0.不成功则返回以下错误码：(这里注意：不能使用GetLastError()得到错误的信息。)a.WSASYSNOTREADY: 当前网络还没有准备好进行通信b.WSAVERNOTSUPPORTED：套接字无法支持此应用程序。c.WSAEPROCLIM：任务数超过winsock的支持上限。（这块怀疑是和iMaxSockets有关系）。d.WSAEFAULT：WSAdata是一个非法的指针。(4)函数的功能：此函数被调用的时，可以通过所设置的环境变量找到winsock.dll文件;检查winsock.dll的版本号是否符合要求，符合则返回0（盲猜不符合返回WSAVERNOTSUPPORTED）;实现winsock和应用程序绑定（这块可以理解为编译链接运行的过程）。3.3 终止Winsockint WSACleanup(void)函数(1)参数是void,这点和WSAStartup不同(2)返回值：整型，0表示成功失败返回SOCKETERROR，注意这里可以GetLastError()得到错误信息（这是与WSAStartup的第二个不同点）。(3)函数的功能：中止对WinSock.dll的调用，释放引用动态链接库时占用的系统资源。3.4 创建套接字1int socket(int domain, int type, int protocol); domain：表示的地址族，WinSock可支持AF_INET（IPV4）。type：用以指定套接字的类型，刚刚也提到过了，一般包括三种类型：a.SOCK_STREAM流套接字，为TCP提供有连接的可靠传输。b.SOCK_DGRAM数据报套接字，使用UDP提供无连接的不可靠传输。c.SOCK_RAW原始套接字，提供底层IP的接口。protocol:指定使用的协议，如IPPROTO_TCP，值得注意的是当type指为SOCK_STREAM和SOCK_DGRAM时的时候，实际上protocol也被指定了，此时我们可以将值设置为0。返回值：函数执行失败返回INVALID_SOCKET（即-1），可以通过调用WSAGetLastError取得错误代码。值得注意的是：SOCK类型是一个整型描述符（句柄），是一个指向内部数据结构的指针，我们在后期调用的时候导入这个整型描述符，相当于控制和操作这个socket3.5 关闭套接字1int closesocket(SOCKET s); // 参数是要关闭的套接字的句柄 3.6 绑定套接字到指定IP地址首先要明白Winsock的寻址方式是怎么样的，由于要兼容多个协议，所以我们需要设计一个通用的数据结构存储这个地址。这个通用的数据结构就是sockaddr。1234struct sockaddr &#123; u_short sa_family; //地址家族，AF_xx char sa_data[14]; //14个字节的协议地址&#125;;在介绍下sockaddr_in。123456struct sockaddr_in &#123; short sin_family; //地址家族，eg.AF_INET,AF_INET6 u_short sin_port; //端口号 struct in_addr sin_addr; //用于存储IP地址，这个等下详细介绍下 char sin_zero[8]; //填充字节使得sockaddr_in和sockaddr保持大小。&#125;;注意到这里还有一个in_addr的结构体，主要是用于存储IP地址，其结构如下：12345678910111213struct in_addr &#123; union &#123; struct &#123; u_char s_b1,s_b2,s_b3,s_b4; &#125; S_un_b; struct &#123; u_short s_w1,s_w2; &#125; S_un_w; u_long S_addr; &#125; S_un;#define s_addr S_un.S_addr /* can be used for most tcp &amp; ip code */#define s_host S_un.S_un_b.s_b2 /* host on imp */#define s_net S_un.S_un_b.s_b1 /* network */#define s_imp S_un.S_un_w.s_w2 /* imp */#define s_impno S_un.S_un_b.s_b4 /* imp # */#define s_lh S_un.S_un_b.s_b3 /* logical host */&#125;;难点： 1）区分sockaddr、sockaddr_in、in_addr一般来说sockaddr和sockaddr_in的包含数据内容是一致，但是能够操作这两个结构体的对象不一样，sockaddr一般是在accept,getsockname之类函数中使用，而sockaddr_in则是用户进行操作和修改。一般来说我们需要先对sockaddr_in赋值，在使用函数的时候可能需要将sockaddr_in强制转化为sockaddr,以便于使用。这里我的理解是，填充的时候要按照具体规则来，而调用的函数的时候，不同的协议的处理方式可能具有相似性，如果重写函数的话，似乎太浪费空间和笔墨，所以统一用sockaddr作为接口，处理的时候，我们需要将sockaddr_in转化为sockaddr进行处理。而in_addr则表示sockaddr中地址参数。三者关系如下图所示：2）如何给in_addr赋值首先要地址是以什么样的顺序存入数据结构中。TCP/IP统一规定使用大端传输数据，也称为网络字节顺序。上述sockaddr和sockaddr_in除了sin_family（不是协议的一部分），其他所有值都要按网络字节顺序存储。注：大端存储是什么，就是将高位数据存储到低位空间中。eg.12servAddr.sin_addr.S_un.S_addr = inet_addr("127.0.0.1"); sin.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//(ULONG)0x00000000简单介绍以上两种赋值方式：inet_addr：可以将点分十进制的字符串转换为为一个长整型的数。htonl: 可以将32位字节顺序转化为网络的字节顺序，刚刚也提到了除了sin_family，其他的值全部要按照网络的字节顺序来存储。附：INADDR_ANY表示转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。一般服务器会使用INADDR_ANY。其他函数还有htons、htonl、ntohs、ntohl等。不再赘述。（太懒了，逃回到如何将套接字绑定到指定网络地址上，一般我们是用connect()或者listen()函数调用。值得注意的是在服务端，用于监听客户端连接请求套接字一定要绑定，而客户端不一定需要绑定。12345int bind ( SOCKET s, //socket的句柄 const struct sockaddr * name, //网络地址，之前介绍那些，不过我们只能对sockaddr_in赋值，如果使用需要强制转化sockaddr_in变成sockaddr处理 int namelen //sockaddr的长度，直接sizeof(name)就ojbk);返回值：成功为0，否则是SOCKET_ERROR。3.7 设置套接字进入监听状态条件：字节流套接字，服务端，是一种被动连接模式。1234int listen（ SOCKET s, /*已绑定的套接字句柄*/ int backlog /*等待连接队列长度*/)3.8 接收连接请求从监听套接字的等待队列中抽取连接请求，建立新的套接字与该客户端的套接字建立连接，交换数据。12345SOCKET accept(SOCKET s, //服务端处的监听套接字struct sockaddr* addr, //出口参数，客户端地址结构int* addrlen //出口参数，客户端地址长度);返回值：如果连接成功返回新的套接字描述符，否则返回INVALID_SOCKET。3.9 请求连接函数客户端请求与服务端建立连接。12345int connect ( SOCKET s, //客户端的套接字 const struct sockaddr * name, //客户端的地址结构 int namelen //客户端的sockaddr长度);返回值：成功返回0，否则返回SOCKET_ERROR。根据3.7 ~ 3.9节内容，我们可以对客户端的状态进行总结。when 客户端发出connect（请求连接） —-&gt; 服务端则会监听到该连接，将会采取三个动作： 1）TCP三次握手成功后，调用accept函数，然后讲该连接丢入已连接队列中。 2）将其丢入到等待连接队列中。 3）将其扔出去。（具体三次握手下细化的状态转移问题，我想等学习了三次握手再说，先甩一个感觉不错链接： https://blog.csdn.net/kongxian2007/article/details/491538013.10 收发数据123456int send ( SOCKET s, //若是服务器，则该选项是accpet建立对应的套接字。客户端则为建立连接的套接字 const char * buf, //发送数据的缓冲区 int len, //缓冲区中的数据长度 int flags //调用执行方式，一般置为0);返回值成功：返回实际发送的字节数失败：返回SOCKET_ERROR请注意send的成功调用并不代表数据发送成功，仅仅表示能成功送入缓冲区123456int recv ( SOCKET s, //建立连接套接字 char * buf, //接收缓冲区 int len, //缓冲区长度 int flags //选项，一般为0);返回值：成功：返回实际接收的字节数连接已终止：0失败：返回SOCKET_ERROR下面的代码很有可能会出现一个问题，如果是循环接收服务端发送的数据，如果接收到的是这样数据：aaaaaaabbbb实际上客户端接收的是：aaaaaaabbb最后一个数据少了b，这是因为第三个参数在每一次调用前都在发生变化，从4到3，所以导致第三次接收缓冲区只能接收”bbb”。1int nRecv = recv(s, buff, sizeof(buf), 0);正确的写法可以是这样：定义一个常数即可。1int nRecv = recv(s, buff, 256, 0); 实验：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//////////////////////////////////////////////////// TCPServer.cpp文件#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#include &lt;WinSock2.h&gt;#pragma commet(lib, "Ws2_32.lib")#include "../common/InitSock.h"#include &lt;stdio.h&gt;#include &lt;iostream&gt;CInitSock initSock; // 初始化Winsock库sockaddr_in server, client;using namespace std;int main()&#123; WORD ws_version = MAKEWORD(2, 2); WSADATA wsaData; WSAStartup(ws_version,&amp;wsaData); // 创建套节字 SOCKET sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (sListen == INVALID_SOCKET) &#123; printf("Failed socket() \n"); return 0; &#125; // 填充sockaddr_in结构 sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(4567); sin.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//(ULONG)0x00000000 //output 1 Create int server_len = sizeof(server); getsockname(sListen, (sockaddr *)&amp;server, &amp;server_len); cout &lt;&lt; "the Create Stage of Socket IP:" &lt;&lt; inet_ntoa(server.sin_addr) &lt;&lt; ":" &lt;&lt; ntohs(server.sin_port) &lt;&lt; endl; // 绑定这个套节字到一个本地地址 if (bind(sListen, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR) &#123; printf("Failed bind() \n"); return 0; &#125; //output 2 Bind memset(&amp;server, 0, sizeof(server)); server_len = sizeof(server); getsockname(sListen, (sockaddr *)&amp;server, &amp;server_len); cout &lt;&lt; "the Bind Stage of Socket IP:" &lt;&lt; inet_ntoa(server.sin_addr) &lt;&lt; ":" &lt;&lt; ntohs(server.sin_port) &lt;&lt; endl; // 进入监听模式 if (listen(sListen, 2) == SOCKET_ERROR) &#123; printf("Failed listen() \n"); return 0; &#125; //output 3 listen memset(&amp;server, 0, sizeof(server)); server_len = sizeof(server); getsockname(sListen, (sockaddr *)&amp;server, &amp;server_len); cout &lt;&lt; "the Listen Stage of Socket IP:" &lt;&lt; inet_ntoa(server.sin_addr) &lt;&lt; ":" &lt;&lt; ntohs(server.sin_port) &lt;&lt; endl; // 循环接受客户的连接请求 sockaddr_in remoteAddr; int nAddrLen = sizeof(remoteAddr); SOCKET sClient; char szText[] = " TCP Server Demo! \r\n"; while (TRUE) &#123; // 接受一个新连接 sClient = accept(sListen, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrLen); if (sClient == INVALID_SOCKET) &#123; printf("Failed accept()"); continue; &#125; memset(&amp;server, 0, sizeof(server)); server_len = sizeof(server); getsockname(sListen, (sockaddr *)&amp;server, &amp;server_len); cout &lt;&lt; "the accept Stage of Socket IP:" &lt;&lt; endl; cout &lt;&lt; "Server IP:" &lt;&lt; inet_ntoa(server.sin_addr) &lt;&lt; ":" &lt;&lt; ntohs(server.sin_port) &lt;&lt; endl; memset(&amp;client, 0, sizeof(client)); int client_len = sizeof(client); getsockname(sClient, (sockaddr *)&amp;client, &amp;client_len); cout &lt;&lt; "Client IP:" &lt;&lt; inet_ntoa(client.sin_addr) &lt;&lt; ":" &lt;&lt; ntohs(client.sin_port) &lt;&lt; endl; printf(" 接受到一个连接：%s \r\n", inet_ntoa(remoteAddr.sin_addr)); // 向客户端发送数据 send(sClient, szText, strlen(szText), 0); // 关闭同客户端的连接 closesocket(sClient); &#125; // 关闭监听套节字 closesocket(sListen); WSACleanup(); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//////////////////////////////////////////////////////////// TCPClient.cpp文件#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#include &lt;WinSock2.h&gt;#pragma commet(lib, "Ws2_32.lib")#include "../common/InitSock.h"#include &lt;stdio.h&gt;#include &lt;iostream&gt;CInitSock initSock; // 初始化Winsock库sockaddr_in client;using namespace std;int main()&#123; WORD ws_version = MAKEWORD(2, 2); WSADATA wsaData; WSAStartup(ws_version, &amp;wsaData); // 创建套节字 SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (s == INVALID_SOCKET) &#123; printf(" Failed socket() \n"); return 0; &#125; // 也可以在这里调用bind函数绑定一个本地地址 // 否则系统将会自动安排 // 填写远程地址信息 sockaddr_in servAddr; servAddr.sin_family = AF_INET; servAddr.sin_port = htons(4567); // 注意，这里要填写服务器程序（TCPServer程序）所在机器的IP地址 // 如果你的计算机没有联网，直接使用127.0.0.1即可 servAddr.sin_addr.S_un.S_addr = inet_addr("127.0.0.1"); int client_len = sizeof(client); getsockname(s, (sockaddr *)&amp;client, &amp;client_len); cout &lt;&lt; "the Create Stage of Socket IP:" &lt;&lt; inet_ntoa(client.sin_addr) &lt;&lt; ":" &lt;&lt; ntohs(client.sin_port) &lt;&lt; endl; if (connect(s, (sockaddr*)&amp;servAddr, sizeof(servAddr)) == -1) &#123; printf(" Failed connect() \n"); return 0; &#125; memset(&amp;client, 0, sizeof(client)); client_len = sizeof(client); getsockname(s, (sockaddr *)&amp;client, &amp;client_len); cout &lt;&lt; "the Create Stage of Socket IP:" &lt;&lt; inet_ntoa(client.sin_addr) &lt;&lt; ":" &lt;&lt; ntohs(client.sin_port) &lt;&lt; endl; // 接收数据 char buff[256]; int nRecv = recv(s, buff, 256, 0); if (nRecv &gt; 0) &#123; buff[nRecv] = '\0'; printf(" 接收到数据：%s", buff); &#125; // 关闭套节字 closesocket(s); WSACleanup(); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率图模型学习1 --- 初入概率图]]></title>
    <url>%2F2020%2F04%2F11%2F%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B-%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[本节复习之前打过一种类型的ACM题，概率图模型。也是为之后的马尔科夫随机场、条件马尔科夫随机场、隐式马尔科夫做准备。HDU 5955题意很简单，就是一群人坐在一起，这群人给出一个长度为N的序列（序列的每一个数是1~6中的一个），扔无数次色子直到其中一个序列出现为止。然后让你判断每一个人猜中的概率是多少。题解：在此之前，得介绍一种数据结构，叫AC自动机。简单下介绍一下：给出四个单词：”ABC”、”BD”、”BCD”、”C”首先建立字典树，如下图所示：fail指针是如何建立的：首先fail指针建立的目的就是为了剪枝，我们不希望我匹配失误后，还要跳回根节点继续匹配，我们希望能够一个前缀使得它和当前我们失配的后缀是相同，这样我们只需要把失配后缀的最后元素指向前缀最后的元素继续匹配就行。这里针对第四层叶子节点C来说，即上图的4号节点的fail指针。4号节点匹配到“ABC”单词的最后，明显属于失配的节点（因为没发继续往下走了。），我们发现”ABC“的后缀“BC”和“BCD”前缀”BC“是相同的，且我们发现”ABC“的后缀“C”和“C”前缀”C“也是相同的，那么我们应该选择哪个，这里采用一个贪心的策略，每次寻找较大的后缀，故最后fail指针会指向7号节点。那么这里就有一个问题，在于怎么样是最大的后缀呢，我们发现可以从父亲节点失配节点寻找是否有一个儿子节点值和该失配节点相同。在这个例子中，4号节点的父亲节点是3，,3的fail指针是5，那么我们只要检查5号节点是否存在一个儿子节点的值是C，即7号节点。如果我们每一个节点都按照上述策略去匹配，必然能保证我们每次失配寻找都是一个最大后缀。当这个最大后缀不满足我们会继续找一个次大的最大后缀，直至所有后缀找完。给一个乱搞的解法，也是现场很多人过的解法：AC自动机+矩阵快速幂。首先考虑一个简单的情况，分别给出两个序列：“1234” “2345”，最多扔6次（不是无数次），两个人猜中的概率是多少。首先根据给出序列建立AC自动机：设出现“1234”序列为事件A，“2345”为事件B，扔了i次为事件$ Q_i $，那么A事件发生概率为 P(A) = \sum_{i=4}^6 P(A \bigcap Q_{i})同理B事件发生的概率为 P(B) = \sum_{i=4}^6 P(B \bigcap Q_{i})但是我们发现这样算似乎有点繁琐，因为我们想要得到最多六次的结果，就得计算3次概率再相加。我们希望能不能只用算一次就能得到结果。仔细思考，当我们第四次投掷出一个序列的时候，实际上第五次、第六次结果是什么都不关心了。于是我们可以把第四次就投掷出序列“1234” 等价于 6次投掷出“1234xy”,其中$x,y \in [1,6] $，同理五次投掷出序列”1234”可以看成”x1234y”。于是我们可以把式子改成： P(A) = \sum_{x=1}^6 \sum_{y=1}^6 P(1234xy) + \sum_{x=1}^6 \sum_{y=1}^6 P(x1234y)但是在上一个AC自动机中，当我们投掷出“1234”的4的时候，根据fail指针，如果下一个是5，那么我们将跳转到“2345”的5,这样会出现歧义。为了避免这样的歧义出现，我们需要对AC自动机进行一个个小小调整：这样不管下一次投掷的是什么，我都会继续跳转到4这个节点。同理当我投掷出”2345”这个序列的时候，我也会跳转到5。防止歧义的出现。（从这里看出4和5的自连接的条件概率是100%）那么接下来我们只需要利用概率DP求解这个问题就可以了，转移方程为 dp[i][k] = dp[i][k] + \frac{1}{6} \times dp[j][k-1] , (j,i) \in E求解6次即可。接下来我们回到本节问题，本节问题是求无穷次，无穷次不好办啊，但是实际上我们发现当我们迭代到一定次数的时候，结果会慢慢收敛到某一个值，也就是说当给定精度要求，我们并不需要迭代无数次，只需要迭代有限次的次数。PS:这个确实不知道为啥？本还以为是马尔科夫的细致平稳条件，但看了下细致平稳的条件的要求，似乎本题不满足任意状态可达的要求。看来这个做法确实有点乱搞乱来的感觉。。。（2333）这个题，大概应该是在$2^{30}$左右的时候，精度就够了，当然肯定是不能循环这么多次，直接就用矩阵快速幂就可以做完这个题了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;#define MAXN 135using namespace std;const double eps = 1e-9;struct Trie&#123; int next[MAXN][7],fail[MAXN],ed[MAXN]; int root,L,cnt; int newnode() &#123; for(int i=1;i&lt;=6;i++) next[L][i]=-1; ed[L++]=0; return L-1; &#125; void init() &#123; L=0; root=newnode(); &#125; void Insert(int *buf,int len) &#123; int now=root; for(int i=0;i&lt;len;i++) &#123; int id=buf[i]; if(next[now][id]==-1) next[now][id]=newnode(); now=next[now][id]; &#125; ed[now]=1; &#125; void build() &#123; queue&lt;int&gt; q; fail[root]=root; for(int i=1;i&lt;=6;i++) &#123; if(next[root][i]==-1) next[root][i]=root; else &#123; fail[next[root][i]]=root; q.push(next[root][i]); &#125; &#125; while(!q.empty()) &#123; int now=q.front(); q.pop(); if(ed[fail[now]]) ed[now]=1; for(int i=1;i&lt;=6;i++) &#123; if(next[now][i]==-1) next[now][i]=next[fail[now]][i]; else &#123; fail[next[now][i]]=next[fail[now]][i]; q.push(next[now][i]); &#125; &#125; &#125; &#125;&#125;;Trie AC;int N;struct Matrix&#123; double mat[MAXN][MAXN];&#125;;Matrix unit;Matrix operator *(Matrix a,Matrix b)&#123; Matrix ans; memset(ans.mat,0,sizeof(ans.mat)); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) for(int k=1;k&lt;=N;k++) ans.mat[i][j]=(ans.mat[i][j]+a.mat[i][k]*b.mat[k][j]); return ans;&#125;int n,len;int buf[MAXN];Matrix tmp;int main()&#123; int t; scanf("%d",&amp;t); for(int i=0;i&lt;MAXN;i++)unit.mat[i][i]=1; while(t--) &#123; scanf("%d%d",&amp;n,&amp;len); AC.init(); for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;len;j++) scanf("%d",&amp;buf[j]); AC.Insert(buf,len); &#125; AC.build(); memset(tmp.mat,0,sizeof(tmp.mat)); N=AC.L; for(int i=0;i&lt;N;i++) &#123; if(AC.ed[i]) &#123; tmp.mat[i+1][i+1]=1; continue; &#125; for(int j=1;j&lt;=6;j++) &#123; int id=AC.next[i][j]; tmp.mat[i+1][id+1]+=1.0/6; &#125; &#125; for(int i=1;i&lt;=30;i++) tmp=tmp*tmp; int cnt=0; for(int i=0;i&lt;N;i++) &#123; if(AC.ed[i]) cnt++,printf("%.6f%c",tmp.mat[1][i+1],cnt==n?'\n':' '); &#125; &#125; return 0;&#125;接下来介绍这个题普遍流传的解法：AC自动机+高斯消元。首先说明下高斯消元的合理性：首先考虑一个简单的情况，分别给出两个序列：“12” “23”，然后我们由此建立AC自动机，如下：我们发现这个AC自动机有个特点在于任意节点互相可达，这样则会满足马尔科夫的细致平稳条件，即$ \lim \limits_{N \to \infty} DP[i][N] = x_i $，最后会收敛一个值。同样根据刚刚的推论，为了求解方便，我们同样需要把AC自动机改造下，这个时候我们只需要去掉”12”的2的fail指针。同时去掉”23”的3的fail指针。这样完成构造。刚刚已经说了这个结果是收敛，那么当$N \to \infty$时候，必然会满足下列式子：（PS：左边”12”分别为1、2号节点，右边”23”分别为3、4号节点，其中注意的是由于概率和是1，所以我们需要指定一个常数1流入根节点。） \left\{ \begin{aligned} a_{01} \times x_1 + a_{02} \times x_2 + a_{03} \times x_3 + a_{04} \times x_{4} &= x_0 \times -a_{00} - 1\\ a_{10} \times x_0 + a_{12} \times x_2 + a_{13} \times x_3 + a_{14} \times x_{4} &= x_1 \times -a_{11} \\ a_{20} \times x_0 + a_{21} \times x_1 + a_{23} \times x_3 + a_{24} \times x_{4} &= x_2 \times -a_{22} \\ a_{30} \times x_0 + a_{31} \times x_1 + a_{32} \times x_2 + a_{34} \times x_{4} &= x_3 \times -a_{33} \\ a_{40} \times x_0 + a_{41} \times x_1 + a_{42} \times x_2 + a_{43} \times x_{3} &= x_4 \times -a_{44} \end{aligned} \right.其中，方程的增广矩阵如下： \left [ \begin {array} {ccccc|c} a_{00} & a_{01} & a_{02} & a_{03} & a_{04} & -1\\ a_{10} & a_{11} & a_{12} & a_{13} & a_{14} & 0\\ a_{20} & a_{21} & a_{22} & a_{23} & a_{24} & 0\\ a_{30} & a_{31} & a_{32} & a_{33} & a_{34} & 0\\ a_{40} & a_{41} & a_{42} & a_{43} & a_{44} & 0 \end {array} \right ]于是我们只需要模拟AC自动机求出A矩阵后，再利用高斯消元即可。高斯消元：https://oi-wiki.org/math/gauss/（这个有时间再好好学习，先贴一个原来写的代码，写的很丑，凑合着看）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;#define MAXN 135using namespace std;const double eps = 1e-9;struct Trie&#123; int next[MAXN][7],fail[MAXN],ed[MAXN]; int root,L,cnt; int newnode() &#123; for(int i=1;i&lt;=6;i++) next[L][i]=-1; ed[L++]=0; return L-1; &#125; void init() &#123; L=0; root=newnode(); &#125; void Insert(int *buf,int len) &#123; int now=root; for(int i=0;i&lt;len;i++) &#123; int id=buf[i]; if(next[now][id]==-1) next[now][id]=newnode(); now=next[now][id]; &#125; ed[now]=1; &#125; void build() &#123; queue&lt;int&gt; q; fail[root]=root; for(int i=1;i&lt;=6;i++) &#123; if(next[root][i]==-1) next[root][i]=root; else &#123; fail[next[root][i]]=root; q.push(next[root][i]); &#125; &#125; while(!q.empty()) &#123; int now=q.front(); q.pop(); if(ed[fail[now]]) ed[now]=1; for(int i=1;i&lt;=6;i++) &#123; if(next[now][i]==-1) next[now][i]=next[fail[now]][i]; else &#123; fail[next[now][i]]=next[fail[now]][i]; q.push(next[now][i]); &#125; &#125; &#125; &#125;&#125;;Trie AC;int n,len;int buf[MAXN];int equ,var;double a[MAXN][MAXN],x[MAXN];int Gauss()&#123; int i,j,k,col,max_r; for(k = 0,col = 0;k &lt; equ &amp;&amp; col &lt; var;k++,col++) &#123; max_r = k; for(i = k+1;i &lt; equ;i++) if(fabs(a[i][col]) &gt; fabs(a[max_r][col])) max_r = i; if(fabs(a[max_r][col]) &lt; eps)return 0; if(k != max_r) &#123; for(j = col;j &lt; var;j++) swap(a[k][j],a[max_r][j]); swap(x[k],x[max_r]); &#125; x[k]/=a[k][col]; for(j = col+1;j &lt; var;j++)a[k][j]/=a[k][col]; a[k][col] = 1; for(int i = 0;i &lt; equ;i++) if(i != k) &#123; x[i] -= x[k]*a[i][k]; for(j = col+1;j &lt; var;j++)a[i][j] -= a[k][j]*a[i][col]; a[i][col] = 0; &#125; &#125; return 1;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d",&amp;n,&amp;len); AC.init(); for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;len;j++) scanf("%d",&amp;buf[j]); AC.Insert(buf,len); &#125; AC.build(); int N=AC.L; //printf("N=%d\n",N); var=equ=AC.L; memset(a,0,sizeof(a)); memset(x,0,sizeof(x)); for(int i=0;i&lt;N;i++)a[i][i]=-1; x[0]=-1; for(int i=0;i&lt;N;i++) &#123; if(AC.ed[i])continue; for(int j=1;j&lt;=6;j++) &#123; int id=AC.next[i][j]; a[id][i]+=1.0/6; &#125; &#125;// for(int i=0;i&lt;N;i++)// &#123;// for(int j=0;j&lt;N;j++)// printf("%.6lf ",a[i][j]);// puts("");// &#125; Gauss(); int cnt=0; for(int i=0;i&lt;N;i++) &#123; if(AC.ed[i]) &#123; cnt++; printf("%.6lf%c",x[i],cnt==n?'\n':' '); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>machine learning</category>
        <category>概率图</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>machine learning</tag>
        <tag>概率图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C ++ 多线程编程2 ——— 同步与互斥]]></title>
    <url>%2F2020%2F04%2F07%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[突然看到一句很好的话，知人者智，自知者明。也算勉励自己吧。1）创建一个信号量创建信号量主要采用CreateSemaphore函数，函数原型如下：123456HANDLE WINAPI CreateSemaphore( _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes _In_ LONG lInitialCount, _In_ LONG lMaximumCount, _In_opt_ LPCTSTR lpName );a.lpSemaphoreAttributes这个参数应该算是老朋友了(详细见C++多线程编程1 —- 创建线程)，上个星期刚刚见过的，表示这个线程的安全属性是多少，如果为NULL表示默认的安全属性。b.lInitialCount表示信号量的初始值，取值范围为[0,lMaximumCount]。c.lMaximumCount表示该信号量的最大值。与b相对应。d.lpName表示信号量的名称。这里讲解下，LPCTSTR是指向常量字符串的长指针，等同于const TCHAR的指针。TCHAR主要取决你的工程代码中是否定义宏UNICODE有所不同。如果定义了UNICODE，TCHAR = wchar_t，否则是char。返回值是指向信号量的句柄（这里体现了句柄不仅仅可以管理进程还可以管理其他的资源），如果创建信号量与已有信号量重名，那么返回已经存在的信号量句柄。 （有待考察）。 2）打开信号量。打开一个已有的信号量我们一般是用OpenSemaphore函数来进行。这个一般是通过名字打开一个信号量。函数原型如下：12345HANDLE OpenSemaphoreW( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);a.dwDesiredAccess对该信号量的访问权，如果这个访问权不允许当前进程对这个信号量进行操作，那么这个函数执行将会失败。b.bInheritHandle是否被继承，如果为true，那么该线程创建的信号们将会继承已有的信号（不太清楚继承的是什么？），为false，则不会继承。c.lpName打开信号量的名字。更多请了解：https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-opensemaphorew 3）获得信号占有权3.1 WaitForSingleObject函数在window操作系统中，线程具有两个非常重要的状态：“授信状态”、“非授信状态”。当进程处于非授信状态的时候，进程被阻塞，当处于授信状态时候，就相当于被唤醒。说白了这个操作就类似于PV操作的P操作，申请进入临界区。123DWORD WaitForSingleObject(HANDLE hObject, //指明一个内核对象的句柄DWORD dwMilliseconds); //等待时间a.hObject这个参数表示该进程在等待的信号量的句柄。b.dwMilliseconds表示需要等待的时间（单位为毫秒），可以传递INFINITE表示将无限等待下去。如果等待超时将返回WAIT_TIMEOUT,如果失败则返回WAIT_FAILED,正常执行返回WAIT_OBJECT_0。可以用switch case语句判断该进程的状况。3.2 WaitForMultipleObjects函数这个函数与之前的WaitForSingleObject函数最大不同在于，WaitForSingleObject人如其名，一个进程只能等待一个信号。而WaitForMultipleObjects函数可以实现一个进程等待多个信号的功能。函数的原型如下：123456DWORD WaitForMultipleObjects(DWORD nCount, // number of handles in the handle arrayCONST HANDLE *lpHandles, // pointer to the object-handle arrayBOOL fWaitAll, // wait flagDWORD dwMilliseconds // time-out interval in milliseconds);a.nCount表示指定列表中句柄的数量，最大值为MAXIMUM_WAIT_OBJECTS（64）。b.lpHandles指定信号量列表的头指针。c.fWaitAll人如其名，表示是否等待全部的HANDLE发出指令，如果为true,则等到所有的HANDLE对该进程发出信号才能继续执行，否则只需要任何一个HANDLE对该进程发出信号即可。d.dwMilliseconds同上不解释了。返回值：WAIT_ABANDONED_0表示所有HANDLE都发出消息。这个和普通的WAIT_OBJECT_0不同在于：通常在WAIT_ABANDONED中都存在一个互斥量，即控制进程间的互斥关系（例如进程A和进程B间是互斥的访问共享变量a，那么就可以设置一个互斥的信号量），那么很有可能会出现一种情况，就是有一个进程意外终止了，但是他没有释放这个互斥量，这样我们就称为信号遗忘。WAIT_TIMEOUT表示超时。WAIT_OBJECT_0表示所有HANDLE都发出消息。 4）信号量的释放信号量的释放主要用ReleaseSemaphore函数来进行控制，与刚刚的两个函数WaitForSingleObject、WaitForMultipleObjects两个函数相对应，属于PV操作的V操作。函数的原型如下：12345BOOL WINAPI ReleaseSemaphore( _In_ HANDLE hSemaphore, _In_ LONG lReleaseCount, _Out_opt_ LPLONG lpPreviousCount);a.hSemaphore表示释放的信号量的句柄。b.lReleaseCount简单说表示V操作释放多少次。或者这个互斥量释放了多少个。与创建进程的lInitialCount相对应。c.lpPreviousCount指向上一次计数结果的指针，不需要可以设置为NULL。 实战：A.生产者消费者模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;windows.h&gt;#include &lt;iostream&gt;#include&lt;process.h&gt;const int num = 5;char plate[10]; //表示盘子,P表示Proudct，N表示None，E表示吃int p, e;HANDLE empty; //表示盘子中空的位置的信号量HANDLE mutex; //生产者消费者互斥访问盘子HANDLE full; //表示盘子中多余苹果的信号量bool get_status(DWORD flag)&#123; bool pflag = true; switch (flag) &#123; case WAIT_OBJECT_0: pflag = true; break; case WAIT_FAILED: pflag = false; std::cout &lt;&lt; "fail to wait\n"; std::cout &lt;&lt; GetLastError() &lt;&lt; "\n"; break; case WAIT_TIMEOUT: pflag = false; std::cout &lt;&lt; "Time out\n"; break; &#125; return pflag;&#125;void P(HANDLE hSemp)&#123; DWORD flag = WaitForSingleObject(hSemp, INFINITE); bool pflag=get_status(flag); if (!pflag)std::cout &lt;&lt; "P is fail!\n";&#125;void V(HANDLE hSemp)&#123; bool pflag = ReleaseSemaphore(hSemp, 1, NULL); if (!pflag)std::cout &lt;&lt; "V is fail!\n";&#125;void show_plate()&#123; std::cout &lt;&lt; plate &lt;&lt; "\n";&#125;void init_plate()&#123; for (int i = 0; i &lt; num; i++) plate[i] = 'N'; plate[num] = '\0'; show_plate();&#125;DWORD WINAPI Product_Apple(LPVOID lpParamter) //生产者进程&#123; for (int i = 1; i &lt;= 10;i++) &#123; P(empty); P(mutex); plate[(p++) % num] = 'P'; show_plate(); V(mutex); V(full); &#125; return 1;&#125;DWORD WINAPI cost_Apple(LPVOID lpParamter) //消费者进程&#123; for (int i = 1; i &lt;= 10; i++) &#123; P(full); P(mutex); plate[(e++) % num] = 'E'; show_plate(); V(mutex); V(empty); &#125; return 1;&#125;int main()&#123; init_plate(); //初始化盘子 //创建信号量 empty = CreateSemaphore(NULL, num, num, NULL); //初始为3个空位，最多有3个空位。 full = CreateSemaphore(NULL, 0, num, NULL); mutex = CreateSemaphore(NULL, 1, 1, NULL); //互斥访问Apple变量 //创建进程 HANDLE ThreadHandle[2]; ThreadHandle[0] = CreateThread(NULL, 0, Product_Apple, NULL, 0, NULL); //生产者子线程 ThreadHandle[1] = CreateThread(NULL, 0, cost_Apple, NULL, 0, NULL); //消费者子线程 WaitForMultipleObjects(2, ThreadHandle, TRUE, INFINITE); //这句话控制了主线程和子线程的同步关系 Sleep(30000); CloseHandle(empty); CloseHandle(full); CloseHandle(mutex); CloseHandle(ThreadHandle[0]); CloseHandle(ThreadHandle[1]); return 0;&#125;结果：坑点：如果不加WaitForMultipleObjects这个函数的话，主线程不会被阻塞，很可能先执行CloseHandle的函数，导致子线程或者信号量先被销毁了。若是信号量销毁则可能出现5号错误码（无法访问），6号错误码（非法的HANDLE）。B.读者写者模型 —- 读者优先1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;windows.h&gt;#include &lt;iostream&gt;#include&lt;process.h&gt;const int num = 5;char plate[10]; //表示盘子,P表示Proudct，N表示None，E表示吃int readcnt;int ticket=6;HANDLE mutex; //控制读者间互斥，因为readcnt是共享变量HANDLE wr; //控制读者和写者，写者和写者的互斥bool get_status(DWORD flag)&#123; bool pflag = true; switch (flag) &#123; case WAIT_OBJECT_0: pflag = true; break; case WAIT_FAILED: pflag = false; std::cout &lt;&lt; "fail to wait\n"; std::cout &lt;&lt; GetLastError() &lt;&lt; "\n"; break; case WAIT_TIMEOUT: pflag = false; std::cout &lt;&lt; "Time out\n"; break; &#125; return pflag;&#125;void P(HANDLE hSemp)&#123; DWORD flag = WaitForSingleObject(hSemp, INFINITE); bool pflag = get_status(flag); if (!pflag)std::cout &lt;&lt; "P is fail!\n";&#125;void V(HANDLE hSemp)&#123; bool pflag = ReleaseSemaphore(hSemp, 1, NULL); if (!pflag)std::cout &lt;&lt; "V is fail!\n";&#125;DWORD WINAPI reader(LPVOID lpParameter)&#123; P(mutex); if (readcnt == 0) P(wr); std::cout &lt;&lt; "read Process ID" &lt;&lt; GetCurrentThreadId() &lt;&lt; ":" &lt;&lt; ticket &lt;&lt; "\n"; readcnt++; V(mutex); P(mutex); readcnt--; if (readcnt == 0) V(wr); V(mutex); return 1;&#125;DWORD WINAPI writer(LPVOID lpParameter)&#123; P(wr); ticket--; //票数-1 std::cout &lt;&lt; "writer Process ID" &lt;&lt; GetCurrentThreadId() &lt;&lt; ":" &lt;&lt; ticket &lt;&lt; "\n"; V(wr); return 1;&#125;int main()&#123; mutex = CreateSemaphore(NULL, 1, 1, NULL); wr = CreateSemaphore(NULL, 1, 1, NULL); HANDLE ThreadHandle[4]; for (int i = 0; i &lt; 2; i++) &#123; ThreadHandle[i] = CreateThread(NULL, 0, reader, NULL, 0, NULL); ThreadHandle[i + 2] = CreateThread(NULL, 0, writer, NULL, 0, NULL); &#125; WaitForMultipleObjects(4, ThreadHandle, TRUE, INFINITE); //这句话控制了主线程和子线程的同步关系 std::cout &lt;&lt; ticket &lt;&lt; "\n"; Sleep(30000); CloseHandle(mutex); CloseHandle(wr); for (int i = 0; i &lt; 4;i++)CloseHandle(ThreadHandle[i]); return 0;&#125;写者优先是一样的方法，不再赘述。]]></content>
      <categories>
        <category>C++</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平面最近点对]]></title>
    <url>%2F2020%2F04%2F01%2F%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[平面最近点对，给出N个二维平面上的点，求空间欧几里得距离最近的一对点，并输出这样欧几里得距离。来源：洛谷P1429首先给出KD-Tree做法，直接暴力就好了，只有一个特例要处理下，就是同样位置的点可能会出现两次，这样的距离是0。通过这道题，感觉自己更加理解K-D Tree了（大误？），但感觉K-D Tree有点劲啊，这啥优化都没有，就这样搜下去都可以，这玩意复杂度是个啥啊？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;#define sq(x) (x)*(x)using namespace std;const int MAXN = 2e5+4;int idx;inline int read()&#123; int x(0),f(1); char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10+ch-'0',ch=getchar(); return x*f;&#125;struct Point&#123; int x[2]; int mm[2],mx[2]; int w, id; const bool operator &lt;(const Point &amp;tp)const &#123; return x[idx]&lt;tp.x[idx]; &#125;&#125;;Point pt[MAXN];typedef pair&lt;double,Point&gt; PDN;priority_queue&lt;PDN&gt; que;int k=2,m=1;struct KDTree&#123; Point p[MAXN&lt;&lt;2]; int sz[MAXN&lt;&lt;2]; int tag; void build(int l,int r,int rt,int dep) &#123; if(l&gt;r)return; sz[rt]=r-l; sz[rt&lt;&lt;1]=sz[rt&lt;&lt;1|1]=-1; idx=dep%k; int mid=(l+r)&gt;&gt;1; nth_element(pt+l,pt+mid,pt+r+1); p[rt]=pt[mid]; p[rt].mm[0]=p[rt].mx[0]=p[rt].x[0];p[rt].mm[1]=p[rt].mx[1]=p[rt].x[1]; build(l,mid-1,rt&lt;&lt;1,dep+1); build(mid+1,r,rt&lt;&lt;1|1,dep+1); if(l!=r) &#123; p[rt].mm[0]=min(min(p[rt&lt;&lt;1].mm[0],p[rt&lt;&lt;1|1].mm[0]),p[rt].mm[0]); p[rt].mm[1]=min(min(p[rt&lt;&lt;1].mm[1],p[rt&lt;&lt;1|1].mm[1]),p[rt].mm[1]); p[rt].mx[0]=max(max(p[rt&lt;&lt;1].mx[0],p[rt&lt;&lt;1|1].mx[0]),p[rt].mx[0]); p[rt].mx[1]=max(max(p[rt&lt;&lt;1].mx[1],p[rt&lt;&lt;1|1].mx[1]),p[rt].mx[1]); &#125; &#125; void query(int rt,int m,int dep,Point q) &#123; if(sz[rt]==-1)return; idx=dep%k; //printf("(%d,%d)\n",p[rt].x[0],p[rt].x[1]); int left=rt&lt;&lt;1,right=rt&lt;&lt;1|1; PDN tmp=PDN(0,p[rt]); for(int i=0;i&lt;k;i++)tmp.first+=sq(1.0*(p[rt].x[i]-q.x[i])); if(q.x[idx]&gt;p[rt].x[idx])swap(left,right); if(sz[left]!=-1)query(left,m,dep+1,q); bool flag=false; if((int)que.size()&lt;m) &#123; if((q.x[0]!=p[rt].x[0]||q.x[1]!=p[rt].x[1]))que.push(tmp); if(q.x[0]==p[rt].x[0]&amp;&amp;q.x[1]==p[rt].x[1])tag++; flag=true; &#125; else &#123; if(tmp.first&lt;que.top().first) &#123; if(q.x[0]!=p[rt].x[0]&amp;&amp;q.x[1]!=p[rt].x[1])que.pop(),que.push(tmp); if(q.x[0]==p[rt].x[0]&amp;&amp;q.x[1]==p[rt].x[1])tag++; &#125; if(sq(1.0*q.x[idx]-p[rt].x[idx])&lt;que.top().first)flag=true; /*double mm_dist=min(sq(q.x[0]-p[rt].mm[0]),sq(q.x[0]-p[rt].mx[0])); if(mm_dist&gt;que.top().first)flag=false; mm_dist=min(sq(q.x[1]-p[rt].mm[1]),sq(q.x[1]-p[rt].mx[1])); if(mm_dist&gt;que.top().first)flag=false;*/ &#125; if(sz[right]!=-1&amp;&amp;flag)query(right,m,dep+1,q); &#125;&#125;T;int n;double ans=1e18;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)scanf("%d%d",&amp;pt[i].x[0],&amp;pt[i].x[1]); T.build(0,n-1,1,0); for(int i=0;i&lt;n;i++) &#123; //printf("cur query:(%d,%d)\n",pt[i].x[0],pt[i].x[1]); T.tag=0; T.query(1,1,0,pt[i]); if(T.tag&gt;1) &#123; ans=0.0; break; &#125; ans=min(que.top().first,ans); que.pop(); &#125; printf("%.4lf\n",sqrt(ans)); return 0;&#125; 当然还有一个法二，也是一个流行的方法，是指分治。首先给个90分的做法（嘛，这也是11个测试点前面10个测试点太水了），首先先对x按第一关键字排序，而后对y按第二关键字排序，对排好序的点进行分治：1）对于区间[l,r]来说，我们寻找[p[l].x,p[r].x]的中点的x坐标记为mid_x，以其作为分界线将区间分半，递归求解每一个区间的最近点对的距离。递归结束的条件是区间上所有点的x坐标相等，如果只有一个点注意这时候最近点对的距离是无穷大（边界条件），否则用只需枚举这个点相邻的点来判断是否为最近点对。2）合并的区间很简单，在左半部分找到距离mid_x最近的left_x，在右半部分找到距离最近的right_x，（找可以用二分找），然后在left_x和right_x这两条直线上双指针扫描。单纯只对x这样做肯定是不行的，可以举一个反例：1234543 1006 02 507 51如果只按照x坐标去，先排序得到：(2,50)、(3,100)、(6,0)、(7,51)。首先取mid_x=4进行划分，这样将会划分成(2,50)和(3,100)为左半部分，其余点为右半部分，在合并这两个区间的时候，按照我们的算法，我们只会取离x=4最近(3,100)，和右半部分的(6,0)进行求解，但是实际上在合并过程还有一个最近点对没有考虑(2,50)和(7,51)。所以我们需要再对y坐标在做一边上述操作，当然最后还是不能满分的(笑)。给一个90分的答案：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define sq(x) (x)*(x)using namespace std;const int MAXN = 2e5+4;const double INF = 1e18;struct Point&#123; int x,y; const bool operator &lt;(const Point &amp;tp) &#123; if(x==tp.x)return y&lt;tp.y; return x&lt;tp.x; &#125;&#125;;int n;Point p[MAXN];int getmid(int x,int l,int r)&#123; int ans=l; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if(p[mid].x&lt;=x)l=mid+1,ans=mid; else r=mid-1; &#125; if(p[l].x&lt;=x&amp;&amp;l==r)ans=l; return ans;&#125;double Merge(int l,int r,int mid) //双指针扫描&#123; int i=l,j=mid+1; double ans=1e18; while(i&lt;=mid&amp;&amp;j&lt;=r) &#123; double dist=sq(1.0*p[i].x-p[j].x)+sq(1.0*p[i].y-p[j].y); //printf("dist=%.4lf\n",dist); ans=min(dist,ans); if(p[i].y&gt;p[j].y)j++; else i++; &#125; return ans;&#125;double solve(int l,int r)&#123; if(p[l].x==p[r].x) &#123; double ans=INF; for(int i=l;i&lt;r;i++) ans=min(ans,sq(1.0*p[i].x-p[i+1].x)+sq(1.0*p[i].y-p[i+1].y)); return ans; &#125; int x=(p[l].x+p[r].x)&gt;&gt;1; int pos=getmid(x,l,r); double lmm=solve(l,pos); double rmm=solve(pos+1,r); int ll=getmid(p[pos].x-1,l,pos); if(ll&lt;pos&amp;&amp;p[ll].x&lt;p[pos].x)ll++; int rr=getmid(p[pos+1].x+1,pos+1,r); //printf("rr=%d\n",rr); //printf("%d %d\n",p[pos+1].x+1,p[rr].x); if(rr&gt;pos+1&amp;&amp;p[rr].x==p[pos+1].x+1)rr--; //printf("lmm=%.4lf rmm=%.4lf\n",lmm,rmm); //int ch; //scanf("%d",&amp;ch); //printf("[%d,%d] : %d\n",ll,rr,pos); double lrm=Merge(ll,rr,pos); //printf("lrm=%.4lf\n",lrm); double ans=min(min(lmm,rmm),lrm); return ans;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;p[i].x,&amp;p[i].y); sort(p+1,p+1+n); //printf("\n\n"); //for(int i=1;i&lt;=n;i++)printf("%d %d\n",p[i].x,p[i].y); double ans=solve(1,n); for(int i=1;i&lt;=n;i++)swap(p[i].x,p[i].y); sort(p+1,p+1+n); double ans1=solve(1,n); ans=min(ans,ans1); printf("%.4lf\n",sqrt(ans)); return 0;&#125;为什么这样只能90分，尽管我们x和y的情况都考虑了，但这并不是正确的贪心，给出一个反例：1234567610 10016 00 509 4950 5117 52在这个例子中，我们发现答案并不是在x中距离最近的点，或者y中距离最近的点钟产生，而是在次近点中产生，即(9,49)和(17,52)那么，我们就要思考怎么样才是正确的剪枝，正确的降低复杂度，我们知道肯定是不能$O(n^2)$去枚举，那要爆炸的。。。我们注意到答案很有可能回在以mid_x为划分分别向左和右扩张d(d是当前左区间和右区间的最小distance),如下图所示：当然还可以继续化简答案，当固定一个点，去枚举这个点是否存在更近最近点对的时候，我们只需要检查和它距离为d这段区间$（y_0-d,y_0+d）$答案，所以对于一个点，我们最多check 2d x 2d这样一个正方形。然后由于左区间的点和右区间点各点之间距离一定大于等于d，因此我们最多只需要枚举12个点，为什么是12个点，可以看下面那个这张图：我们取2d x 2d右边的部分，如果我们要把一组点放在这个2d x d的部分，并且要求任意两点间的距离大于等于d，最多能放多少个点。也就是在上图中，我们最多能放多少个点，首先我们将这个矩形的长2d划分成3等分，也就是2/3d，宽划分2等分，也就是1/2d，这样我们能把这个矩形划分成6个小部分，注意到每一个矩形的对角线是小于d，也就是说在同一个矩形中，我们不能放进两个点，因为这样会破坏任意两点距离大于等于d的条件，故不行。故一个小矩形只能放1个点。故在2d x 2d的矩形中，我们可以放12个点，也就是说我们最多只需要暴力check 12个点即可。最后复杂度是$O(nlog^2n)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define sq(x) (x)*(x)using namespace std;const int MAXN=2e5+6;const double INF=1e18;struct Point&#123; int x,y;&#125;;bool cmp1(Point a,Point b)&#123; if(a.x==b.x)return a.y&gt;b.y; return a.x&gt;b.x;&#125;bool cmp2(Point a,Point b)&#123; if(a.y==b.y)return a.x&gt;b.x; return a.y&gt;b.y;&#125;int n;Point p[MAXN];Point q[MAXN];double solve(int l,int r)&#123; double ans=INF; if(l==r)return ans; if(r-l==1)return sq(1.0*(p[l].x-p[r].x))+sq(1.0*(p[l].y-p[r].y)); int mid=(l+r)&gt;&gt;1; double lm=solve(l,mid); double rm=solve(mid+1,r); //merge ans=min(lm,rm); int cnt=0; for(int i=l;i&lt;=r;i++) if(abs(p[i].x-p[mid].x)&lt;=ans)q[++cnt]=p[i]; sort(q+1,q+cnt+1,cmp2); for(int i=1;i&lt;=cnt;i++) &#123; for(int j=i+1;j&lt;=cnt;j++) &#123; if(fabs(1.0*(q[j].y-q[i].y))&gt;sqrt(ans))break; double dist=sq(1.0*(q[i].x-q[j].x))+sq(1.0*(q[i].y-q[j].y)); ans=min(ans,dist); &#125; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;p[i].x,&amp;p[i].y); sort(p+1,p+1+n,cmp1); double ans=solve(1,n); printf("%.4lf\n",sqrt(ans)); return 0;&#125;给几组数据，备用debug:1234567891011121314151617181920212223242526272829303132333435363738394041424344//Test 1 样例31 11 22 11.0000//Test 2 是否溢出31 10 01000000000 10000000001.4142//Test 3 重复点41 11 11 22 10.0000//Test 4 刚刚双指针提到的bug43 1006 02 507 515.0990//Test 5 双指针的bug 2610 10016 00 509 4950 5117 528.5440]]></content>
      <categories>
        <category>ACM</category>
        <category>machine learning</category>
        <category>K-D tree</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>machine learning</tag>
        <tag>K-D tree</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C ++ 多线程编程1 ——— 创建线程]]></title>
    <url>%2F2020%2F03%2F26%2FC-plus-plus-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%80-%E2%80%94%E2%80%94%E2%80%94-%E5%AD%A6%E4%B9%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[学习多线程，紧跟脚步，不做眼高手低，稳扎稳打1）HANDLE的定义1typedef void *HANDLE;从中我们可以发现HANDLE的定义，它实际上表示一个void型的指针，使用这样的指针有个好处在于：void型指针可以强制转化为任意类型的指针，因此我们可以用他指向任意的数据结构。那么我们就会思考HANDLE的作用是什么呢？这里参考了下stackoverflow的某位大佬（Lawrence Dol）的话：来源：https://stackoverflow.com/questions/902967/what-is-a-windows-handlea.句柄的重定向 如下图所示，当我们想访问一个进程里面的对象的时候，我们先访问HANDLE得到一个这个进程的对象表(即指向这个进所有对象的内存空间的指针数组),内核通过处理这个对象表的元素，完成对进程的控制。比如说重定向，因为大多数操作系统采用了虚拟内存，那这样的话一个进程所有对象的内存地址并不是固定的。所以操作系统可以利用这样特效，更改这个对象表的指针指向，完成重定向，实现虚拟内存实现。b.隐藏某些信息 从(a)我们可以知道，句柄可以帮助操作系统实现虚拟内存，重定向的功能。但是仔细思考，要想实现虚拟内存，我们直接访问这个进程的对象表不行吗，为什么一定通过一个指针去访问一个对象表。这就涉及到操作系统的安全的内容。我们知道操作系统的调度是受到保护的，如果用户对其进行修改，会不会破坏原有操作系统的调度，可能会导致操作系统崩溃。于是我们需要设一个HANDLE，指向这段需要保护的空间，这样用户就没有办法对其进行直接修改。看似这是一个笨操作，事实上是为了保证操作系统的安全性。 还有一个好处，从API开发者角度考虑这个问题，如果我们设计了HANDLE指针当做这个API的返回值，这样用户就不知道我们实际返回值的定义是什么，就没办法得知我们这个结构体或者类的定义是什么？就没办法对这个结构体进行操作，比如取数据（都不知道这个结构体里面的成员变量有哪些，怎么提取？）。这是一个很好的安全措施，给一个例子说明： 下图是一个关于Widget这个结构体的一个函数 123456Widget * GetWidget (std::string name)&#123; Widget *w; w = findWidget(name); return w;&#125; 上述函数的返回值为Widget *,当我们在main函数调用这个GetWidget的时候，我们首先要定义Widget的指针这个变量，这样就相当于暴露了这个结构体名字，用户可以通过这个名字查询查询到Widget的成员变量。 但是如果我们这样定义： 1234567typedef void *HANDLEHANDLE GetWidget (std::string name)&#123; Widget *w; w = findWidget(name); return reinterpret_cast&lt;HANDLE&gt;(w);&#125; 那这样的话，我们在主函数调用GetWidget的时候，只需要定义HANDLE这个变量即可，这样用户只知道这个返回值返回的是HANDLE，即使暴露这个名字，也只能找到HANDLE的定义，无法确认这个HANDLE内部的实际意义是什么。当然我一直有个疑惑在于如果我知道了GetWidget函数不就可以知道实际返回的Widget，那这样不缺失了保护的意义？难道是它把这个GetWidget藏的很深？不让用户看见？2）如何创建线程当我们学会了HANDLE作用，了解了在Window操作系统中，是怎么样利用HANDLE实现对进程、资源等的控制（重定向，虚拟内存管理），怎么样保护Window的内核资源不被随意更改。那么我们就要了解在用户层面上是如何创建线程的。12345678HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)下面简单介绍几个参数：a.lpThreadAttributes LPSECURITY_ATTRIBUTES lpThreadAttributes,表示指向SECURITY_ATTRIBUTES型态的指针。设置为NULL表示默认安全性，此时不可被子线程继承。给出其定义如下： 12345typedef struct _SECURITY_ATTRIBUTES &#123; DWORD nLength; //nLength表示，这个结构所占的空间是多少 LPVOID lpSecurityDescriptor; //安全描述符，可以控制用户对线程的访问，如果该值为NULL，则表示用户对这个进程访问权限是默认的。 BOOL bInheritHandle; //该控制属性能否被子进程继承。&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES; 因此，由上述定义可知，如果我们想创建子线程也继承父进程下用户访问权限，那么我们不能设置为NULL，而是设置一个新的LPSECURITY_ATTRIBUTES，并设置其中的成员变量bInheritHandle为True即可。b.dwStackSize 线程堆栈的初始化大小，由用户设定。一个线程所有函数都要依赖于这个栈，比如参数的存储，使用。如果设置为0，那么将线程堆栈设置为默认大小（1MB）。c.lpStartAddress 指向线程函数的指针。这里允许多个线程指向同一个函数。（PS:可以实验下）。d.lpParameter 传给多线程函数的参数。LPVOID是一个空指针类型，可以对在线程函数进行内部强制转化转化到你想要类型，然后再执行。最常见的可以为这个线程函数进行一个结构体，然后我们将这个结构体指针传进去。如果只有一个参数可以传递一个对象的指针即可。e.dwCreationFlags 控制线程的创建方式，这里给出了两种创建方式： 1.CREATE_SUSPENDED，这个进程会以挂起（suspended）状态创建，并且进程函数不会被执行，除非ResumeThread这个函数被调用。 2.STACK_SIZE_PARAM_IS_A_RESERVATION，为这个线程提供了设置预留栈，这个参数和前面dwStackSize有关，如果这个标志未指定的话，dwStackSize应该会设置为预留栈的大小，如果为指定，dwStackSize将指定为默认的值。 3.0表示创建后立即激活。 PS：可以分别实验下上面三种创建方式。f.lpThreadId 返回新线程的ID，如果设置为NULL，则不返回新线程的ID。 实践：创建一个含参数的新线程：123456789101112131415161718192021222324252627282930313233#include &lt;windows.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#define sq(x) (x)*(x)struct Point&#123; int x, y; Point()&#123;&#125; Point(int _x, int _y) :x(_x), y(_y)&#123;&#125;&#125;;struct Input&#123; Point p1, p2; &#125;;inline double get_dist(Point p, Point q)&#123; return sqrt(sq(p.x - q.x) + sq(p.y - q.y));&#125;DWORD WINAPI Fun(LPVOID lpParamter)&#123; Input *cur = (Input *)lpParamter; Point p = cur-&gt;p1; Point q = cur-&gt;p2; std::cout &lt;&lt; get_dist(p, q) &lt;&lt; "\n"; return 0;&#125;int main()&#123; Input in; in.p1 = Point(1, 1); in.p2 = Point(2, 2); HANDLE hthread = CreateThread(NULL, 0, Fun, (LPVOID)(&amp;in), 0, NULL); system("pause"); return 0;&#125; 栈空间这块，不知道为什么是随机的数值，这里不清楚变量是不是顺序存储在内存里面，好像跟我想的不一样，先给代码吧，以后再考虑。。。123456789101112131415161718192021#define _CRT_SECURE_NO_WARNINGS#include &lt;windows.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#define sq(x) (x)*(x)DWORD WINAPI Test(PVOID lpParamter)&#123; DWORD dwRet = 0; printf("%-3d:0x%x\n", lpParamter, &amp;dwRet); return dwRet;&#125;int main()&#123; DWORD dwTid; printf("Main:0x%x\n", &amp;dwTid); for (int i = 0; i &lt; 2;i++) CreateThread(NULL, 4, Test, (PVOID)(i), STACK_SIZE_PARAM_IS_A_RESERVATION, NULL); Sleep(6000); return 0;&#125; 3）CloseHandle函数销毁线程用void CloseHandle(HANDLE thread); 4)GetCurrentThreadId函数得到当前线程的PID，int GetCurrentThreadId(). 以上是多线程的基本内容，下一节介绍window.h的临界区，并尝试基本的生产者消费者模型的编程。]]></content>
      <categories>
        <category>C++</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KD-tree 练习一：HDU 5992 Finding Hotels]]></title>
    <url>%2F2020%2F03%2F26%2FKD-tree-%E7%BB%83%E4%B9%A0%E4%B8%80%EF%BC%9AHDU-5992-Finding-Hotels%2F</url>
    <content type="text"><![CDATA[练习机器学习算法也是练习代码功底，以备后续找工作之用。给个预告，下一节试着用K-D Tree做最近点对。HDU 5992 Finding Hotels题意：给出一个N($N \leq 200000$)个宾馆和M($M \leq 20000$)个顾客，给出每个宾馆在二维地图中的坐标和花费，同时给出每个旅客的二维坐标和旅客能承受最大花费，要求对于每一个旅客，找到满足小于最大花费下，离它欧几里得距离最小的旅馆是哪个，如果有多个旅馆，输出编号最近的那个。题解：K-D Tree，典型的K-D Tree暴力，与最裸的K-D Tree不同的是，你还需要考虑当前旅馆花费是否小于最小花费，这个本题解法没有优化，就是按照K-D Tree建树顺序去搜索（即尽可能贪心与他欧几里得距离最近的点，然后暴力check），可能本身这样搜索就是一个优化和剪枝。下面介绍K-D Tree算法，这也是本次学习的核心，K-D Tree就是讲一些K维的数据按照一定顺序进行放置，经过这样放置后对于我们解决K维空间最近邻搜索问题起到一定优化。最早K-D Tree原型要说的话，应该BST，即二叉搜索树，下面回忆下二叉搜索树的一些基本概念：对于一个二叉树而言，每一个节点分别存储一个数值（与线段树一个不同，线段树是每个节点存储区间信息），从这个节点往下可以引出两个分支，第一个分支是小于该节点的左子树，第二个分支是大于该分支的右子树，这样我们只需要在每个节点进行决策，如果大于当前节点，显然我们不需要花太多时间去搜索左子树，同理小于也是一样的。K-D Tree是当BST推广到二维的一个概念。对于一个良好的搜索数据结构而言，我们希望对于每一个节点来说，它的左右子树是平衡（深度尽量一致），这样能够避免出现链状的二叉树，比如说：8-&gt;9-&gt;10-&gt;11-&gt;12-&gt;…-&gt;100,当然我们想查找比99大的元素的时候，对于这样一个链状的二叉树而言，几乎是O(N),但如果我取中间的节点作为二叉树的根节点，可能左右子树深度一致，能够尽量避免较大搜索。同时对于我们来说还有一个新问题：这些数据有K个维度，我应该是以什么依据划分左右子树。于是总结下来，建立一个K-D Tree需要考虑以下问题：1）如何保证K-D Tree是个左右子树平衡的结构？2）如何划分子树？首先解决2）问题，如何划分子树，可以思考一个生活场景，现在你的手里拿着黄瓜，黄瓜长20cm,宽6cm,给你一把刀让你对黄瓜分成2分，你会怎么切？对于一个正常人来说，肯定会对着黄瓜长截一刀，得到两个长10cm,宽6cm的黄瓜。同样对于数据也是一样，当一个数据某个维度相差特别大（即该维度的最小值和最大值差别特别大），我们就可以说数据从这里切分是最好的。而在这里，我们一般用数据的方差去衡量是不是差别很大。当方差较大时候，我们认为数据分别比较广，比较好分，当数据的方差很小，我们认为它们都集中在平均值上，不好区分。于是一个很简单方法，我去检查选了该节点后，剩余的节点的方差在K维表现，当第i维方差较大的时候，我们认为从第i维最好分。当然一个最简单方法就是轮着分，第一次我用第一维，第二次用第二维…第K次用第K维。在这道题中，为了方便我们用轮着分。接下来解决问题1），如何保证K-D Tree是一个平衡结构。因为我们划分子树是以某一个维度去划分。不关心其他维度，于是我们可以把他看成关于第i维（第i维是当前我们划分子树依据）的一维数组。刚刚也说道对于一个数组，比如说1,2,3,4,5去建立二叉树，如果我们取1或者5作为根节点就会出现链状，即左右子树节点数的差值很大。但是我们取3去做，会发现两边子树的节点数都是2，这样可以保持当前的左右子树平衡。注意到3这个数字的特点是刚好是这个数列的中位数。如果我们每一步划分子树都按照取中位数，是不是都能保证每一步的左右子树划分都是平衡。这样整体的左右子树的划分就是平衡的。好像光光去说，似乎有点勉强，我们举个例子：上面分别给出了6个平面中二维点，分别为(7,2)、(5,4)、(2,3)、(4,7)、(9,6)、(8,1)，按照上述规则（轮流+中位数），我们可以得到如下一个K-DTree:理解上述建树的过程，我们需要考虑的是：如何查询K-D Tree的最近邻？与不同二叉树不同的是，通常我们都用二叉树去查询比他小的元素，或者是大的元素。而在K-D Tree，我们大多数是查询在树中哪一个节点离当前的节点的欧几里得距离（曼哈顿距离也行）更近。那么我们应该如何查询？通过总结，我们一般按照如下规则对K-D Tree进行查询：a.首先按照类似二叉树的方法，对当前节点，按照划分子树规则，即通过比较该元素与当前子树的根节点的第i维大小，如果比他大则进入右子树查询，如果小则进入左子树查询。b.但由于我们查询距离最近，那么我们可能会思考一个问题就是另外一个分支是否存在更近的点？于是我们就会想采用一种方法去判断是否有更近的点出现在另外一个分支中。我们采用这个方法就是判断以当前查询的节点为原点，以当前最小欧几里得距离为半径，画出一个超平面圆形，同样我们用一个超平面矩形去包含另外一个分支所有的点，看是不是有交集，如果有交集，那么很有可能有比其还小的一个点。这个a可能很好理解，这个b似乎有点抽象，让我们用一个图去理解这个问题：黑色的点表示K-D Tree上的点，分别有(2,3)、(5,4)、(4,7)、(2,7)、(1,8)、(6,9)按照K-D Tree建树规则，我们很快就确认我们搜索顺序先是：(2,7)-&gt;(5,4)-&gt;(4,7)当回溯至(5,4)节点我们需要检查他的下半部分的分支是否是存在更近的点，于是我们以查询点（图中星星点，(2,5)）为圆心画出一个圆。然后我们发现下半分支就是图中最左下角的矩形，我们发现他们有交集，即可能存在更近的点（事实上确实有）。于是我们就会去搜索下面的分支：那么现在一个问题，在于我们如何确定矩形和圆是否可能存在交集，最简单的方法就是存下下半分支的按极角排序的最近的点表示矩形左下角，最远的点表示右上角。然后判断是否有交集，但这样太麻烦不好维护，我们注意到当我们回溯到(5,4)的时候，上下分支是依据y坐标划分的，那么(5,4)一定是下面区域中最高的那个点（肯定的，根据建树规则思考）。那么若这个点与(2,5)在y坐标方向的距离小于半径，那必然会有交集，所以我需要去继续搜索下一个分支判断是否有距离更小的元素。注意：也可能另一个分支不存在最小的元素，但是相交后可能性较大，用其他方法排除是否存在最小的元素可能条件更弱，容易TLE的。 下面给出HDU这个题的code(题解上面已经说了，就一句话按K-D Tree顺序搜索相当于剪枝，速度更快吧)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;#define sq(x) (x)*(x)using namespace std;const int MAXN = 2e5+4;typedef long long LL;int idx;inline int read()&#123; int x(0),f(1); char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123;if (ch=='-') f=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar(); return x*f;&#125;struct Point&#123; int x[2]; int w,id; const bool operator &lt;(const Point &amp;tp)const &#123; return x[idx]&lt;tp.x[idx]; &#125;&#125;;Point pt[MAXN];Point q;typedef pair&lt;LL,Point&gt; PDN;priority_queue&lt;PDN&gt; que;int k=2,m=1;struct KDTree&#123; Point p[MAXN&lt;&lt;2]; int sz[MAXN&lt;&lt;2]; void build(int l,int r,int rt,int dep) &#123; if(l&gt;r)return; sz[rt]=r-l; sz[rt&lt;&lt;1]=sz[rt&lt;&lt;1|1]=-1; idx=dep%2; int mid=(l+r)&gt;&gt;1; nth_element(pt+l,pt+mid,pt+r+1); p[rt]=pt[mid]; build(l,mid-1,rt&lt;&lt;1,dep+1); build(mid+1,r,rt&lt;&lt;1|1,dep+1); &#125; void query(int rt,int m,int dep,Point q) &#123; if(sz[rt]==-1)return; int idx=dep%k,left=rt&lt;&lt;1,right=rt&lt;&lt;1|1; PDN tmp=PDN(0,p[rt]); for(int i=0;i&lt;k;i++)tmp.first+=sq(1LL*(p[rt].x[i]-q.x[i])); if(q.x[idx]&gt;p[rt].x[idx])swap(left,right); if(sz[left]!=-1)query(left,m,dep+1,q); bool flag=false; if((int)que.size()&lt;m) &#123; if(p[rt].w&lt;=q.w) que.push(tmp); flag=true; &#125; else &#123; if(tmp.first&lt;que.top().first&amp;&amp;p[rt].w&lt;=q.w)que.pop(),que.push(tmp); if(tmp.first==que.top().first&amp;&amp;p[rt].w&lt;=q.w&amp;&amp;p[rt].id&lt;que.top().second.id)que.pop(),que.push(tmp); if(sq(q.x[idx]-p[rt].x[idx])&lt;que.top().first)flag=true; //查询另外部分矩形和圆形是否相交 &#125; if(sz[right]!=-1&amp;&amp;flag)query(right,m,dep+1,q); &#125;&#125;T;int n,ask;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; n=read();ask=read(); for(int i=0;i&lt;n;i++) &#123; pt[i].id=i; pt[i].x[0]=read();pt[i].x[1]=read();pt[i].w=read(); &#125; T.build(0,n-1,1,0); while(ask--) &#123; q.x[0]=read();q.x[1]=read();q.w=read(); T.query(1,m,0,q); printf("%d %d %d\n",que.top().second.x[0],que.top().second.x[1],que.top().second.w); que.pop(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>machine learning</category>
        <category>K-D tree</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>machine learning</tag>
        <tag>K-D tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯18春招机试]]></title>
    <url>%2F2020%2F03%2F21%2F%E8%85%BE%E8%AE%AF18%E6%98%A5%E6%8B%9B%E6%9C%BA%E8%AF%95%2F</url>
    <content type="text"><![CDATA[好久没有更blog，也好久没编程了，先做个简单慢慢学习。A题小Q定义了一种数列称为翻转数列:给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4…, 每隔m个符号翻转一次, 最初符号为’-‘;。例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.小Q现在希望你能帮他算算前n项和为多少。 题解：稍微有点技巧的数学题？这个题有个条件很关键就是n能被2m整除，如果n不能被2m整除，那这个题要考虑的case还蛮多的。考虑个最简单的模型：N是一个远大于2的偶数（本题中N一定是偶数），m=1很容易想到： \sum_{i=1}^N{i} - 2 * \sum_{j=1}^{N/2}{(1+(j-1)*2)}其实发现可以前面两个式子可以利用等差数列前N项和公式化简为： \frac{N * (N+1)}{2} - \frac{N * N}{2}将m推广至小于N的任意数后其实也不难，就相当于后面的减数变成m个等差数列之和，每个等差数列的公差为2m于是可以得到 \frac{N * (N+1)}{2} - (\frac{N * (M+1)}{2} + \frac{N * N}{2} - N * M)1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; LL ans = n*(n+1)/2 - ((n*(m+1))/2 + (n*n/2 - n*m)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; B题牛牛和羊羊正在玩一个纸牌游戏。这个游戏一共有n张纸牌, 第i张纸牌上写着数字ai。牛牛和羊羊轮流抽牌, 牛牛先抽, 每次抽牌他们可以从纸牌堆中任意选择一张抽出, 直到纸牌被抽完。他们的得分等于他们抽到的纸牌数字总和。现在假设牛牛和羊羊都采用最优策略, 请你计算出游戏结束后牛牛得分减去羊羊得分等于多少。 题解：水题1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;typedef long long LL;int n,a[MAXN];LL ans;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); sort(a+1,a+1+n); LL tmp=1; for(int i=n;i&gt;0;i--) &#123; ans = ans + a[i] * tmp; tmp = tmp * -1; &#125; printf("%lld\n",ans); return 0;&#125; C题小Q的父母要出差N天，走之前给小Q留下了M块巧克力。小Q决定每天吃的巧克力数量不少于前一天吃的一半，但是他又不想在父母回来之前的某一天没有巧克力吃，请问他第一天最多能吃多少块巧克力 题解：这个题，最直观的想法就是暴力，然后在找到第一个满足条件就break，可是这样容易超时。因为这个第一个可能会很大。于是我们仔细思考，发现这个题具有二分性质：即满足条件下的最大（小）解于是就可以二分，check直接暴力check即可，复杂度为O(mlogn)123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n,m;bool check(int tp)&#123; int ans=0; for(int i=1;i&lt;=m;i++) &#123; ans=ans+tp; if(ans&gt;n)return false; if(tp&amp;1)tp=tp/2+1; else tp=tp/2; &#125; return true;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); int l=1,r=n,mid,ans; while(l&lt;r) &#123; mid=(l+r)&gt;&gt;1; //printf("[%d %d]\n",l,r); //printf("mid=%d\n",mid); if(check(mid)) l=mid+1,ans=mid; else r=mid-1; &#125; if(l==r&amp;&amp;check(l))ans=l; printf("%d\n",ans); return 0;&#125; D题小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌组成一个总长度正好为K的歌单，每首歌最多只能在歌单中出现一次，在不考虑歌单内歌曲的先后顺序的情况下，请问有多少种组成歌单的方法。 题解：简单组合数学，暴力即可，因为这里数据很小，不需要费马求逆元，直接用杨辉三角形即可。1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define MAXN 105using namespace std;typedef long long LL;const LL mod=1e9+7;LL k;LL A,X,B,Y;LL C[MAXN][MAXN];void init()&#123; for(int i=1;i&lt;=100;i++)C[i][0]=C[i][i]=1; for(int i=1;i&lt;=100;i++) for(int j=1;j&lt;i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;&#125;int main()&#123; init(); scanf("%lld",&amp;k); scanf("%lld%lld%lld%lld",&amp;A,&amp;X,&amp;B,&amp;Y); LL sum=0,ans=0; for(int i=0;i&lt;=X;i++) &#123; if(sum&lt;=k) &#123; LL left=k-sum; //printf("left = %I64d\n",left); if(left%B==0&amp;&amp;(left/B)&lt;=Y)ans=(ans+C[X][i]*C[Y][left/B]%mod)%mod; &#125; else break; sum=sum+A; &#125; printf("%lld\n",ans); return 0;&#125; E题(好题) 小Q的公司最近接到m个任务, 第i个任务需要xi的时间去完成, 难度等级为yi。小Q拥有n台机器, 每台机器最长工作时间zi, 机器等级wi。对于一个任务,它只能交由一台机器来完成, 如果安排给它的机器的最长工作时间小于任务需要的时间, 则不能完成,如果完成这个任务将获得200 xi + 3 yi收益。 对于一台机器,它一天只能完成一个任务, 如果它的机器等级小于安排给它的任务难度等级, 则不能完成。 小Q想在今天尽可能的去完成任务, 即完成的任务数量最大。如果有多种安排方案,小Q还想找到收益最大的那个方案。小Q需要你来帮助他计算一下。 题解：题目出错了，应该改为怎么样才能让任务数最大，并且计算使得任务数最大的花费是多少。按任务数去贪心来做，先对每个任务和机器按照时间从大到小，时间相同按等级从大到小。经过上述排序后，扫描排序后的每一个任务，扫描机器集合直到不存在机器比当前任务花费长则结束，如果存在一个机器比它时间长，则把它加入集合S，然后判断这个集合中是否存在比该机器等级高的机器，如果有则表示该机器可以被匹配，并且从匹配集合中选一个最小的等级从S集合中删去，计算花费。对于下一个机器来说，同样扫描除S集合以外的所有机器直到不存在机器比当前任务花费长则结束，并按上述一样的操作加入S集合，然后判断这个集合中是否存在比该机器等级高的机器，如果有则表示该机器可以被匹配，同样从匹配集合中选一个最小的等级从S集合中删去，计算花费。这是一种二步贪心的策略，优先匹配时间长且等级高的，因为这部分选择少不容易浪费（否则你按小的任务去匹配和一个与它时间相差较大的机器，那肯定浪费了），对于等级低机器，因为集合S的机器必然满足它的条件，但是得优先（必须这样匹配，不然也会导致浪费）选接近它等级，不然容易浪费。且优先匹配时间大的机器，还可以利用上一次没有匹配的机器，从而减少扫描的时间。可以想成，我贪心按任务时间从高到低的顺序去处理这个问题以避免浪费，选用任务的时间X去筛选出满足当前机器可能可行集S，而后我在可行集合S中优先选择最小满足条件的等级（因为此时可行集合的时间X已经不重要，对下一步的影响不如y对下一步的影响）这样的做法的好处在于：省时（nxm的复杂度，且不重复扫描，比它高的优先统计进去了）的一种贪心，且不需要较麻烦的二维排序一种错误且复杂的思路：仅仅只考虑当前机器的匹配策略，用暴力方法去找与(x,y)欧几里得距离最小，事实上没有这个必要是欧几里得距离最小，这种方法繁琐，且很有可能是错的。举一例即可。2 210 1013 97 108 9 我们会发现8 9这个机器，按照取欧几里得最小去匹配的话，优先匹配10 10，而此时7 10没办法被匹配。事实上正确答案应该是8 9匹配13 9，而7 10匹配10 10。是一种二步贪心的思想。 这个题并未在赛场上想出正解，以下代码借鉴了腾讯的正解进行编写。。。，说明小伙子贪心能力不行啊。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;typedef long long LL;struct Node&#123; int x,y; Node()&#123;&#125;; Node(int a,int b):x(a),y(b)&#123;&#125;; const bool operator &lt;(const Node &amp;tp) &#123; if(tp.x==x)return tp.y&lt;y; return tp.x&lt;x; &#125;&#125;;int n,m;Node p[MAXN],q[MAXN];int cnt[105];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;q[i].x,&amp;q[i].y); for(int i=1;i&lt;=m;i++)scanf("%d%d",&amp;p[i].x,&amp;p[i].y); //printf("\n\n"); sort(q+1,q+1+n); sort(p+1,p+1+m); // for(int i=1;i&lt;=m;i++) // printf("%d %d\n",p[i].x,p[i].y); //printf("\n\n"); //for(int i=1;i&lt;=n;i++) // printf("%d %d\n",q[i].x,q[i].y); LL ans=0; int tot=0; for(int i=1,j=1;i&lt;=m;i++) &#123; //printf("i=%d %d %d\n",i,p[i].x,p[i].y); while(j&lt;=n&amp;&amp;q[j].x&gt;=p[i].x) &#123; cnt[q[j].y]++; //printf("[%d,%d]\n",q[j].x,q[j].y); j++; &#125; for(int k=p[i].y;k&lt;=100;k++) &#123; if(cnt[k]) &#123; tot++; cnt[k]--; ans=ans+(200*p[i].x+3*p[i].y); break; &#125; &#125; &#125; printf("%d %lld\n",tot,ans); return 0;&#125; F题画家小Q又开始他的艺术创作。小Q拿出了一块有NxM像素格的画板, 画板初始状态是空白的,用’X’表示。小Q有他独特的绘画技巧,每次小Q会选择一条斜线, 如果斜线的方向形如’/‘,即斜率为1,小Q会选择这条斜线中的一段格子,都涂画为蓝色,用’B’表示;如果对角线的方向形如’\’,即斜率为-1,小Q会选择这条斜线中的一段格子,都涂画为黄色,用’Y’表示。如果一个格子既被蓝色涂画过又被黄色涂画过,那么这个格子就会变成绿色,用’G’表示。小Q已经有想画出的作品的样子, 请你帮他计算一下他最少需要多少次操作完成这幅画。 暴力，case很多，直接两边dfs会因为没办法处理G而死循环这个注意了（注释就是没有考虑这个挂了一发）。。。给几个反例参考：6 5XBGBXYBBYBBGGXXXYYBGXYBGGYYXYX答案：18如果是12的，你是不是没考虑孤立的G点 4 4GXXXXGXXXXGXXXXG答案：5先画Y一笔，剩下的画B四笔。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;#define MAXN 53using namespace std;int n,m;char mp[MAXN][MAXN];int used[MAXN][MAXN];void dfs1(int x,int y)&#123; if(used[x][y]==2&amp;&amp;mp[x][y]=='G')used[x][y]=3; else if(!used[x][y])used[x][y]=1; int xx,yy; xx=x-1;yy=y+1; if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;((mp[xx][yy]!='Y'&amp;&amp;!used[xx][yy])||(mp[xx][yy]=='G'))) dfs1(xx,yy);&#125;void dfs2(int x,int y)&#123; //printf("(%d,%d)\n",x,y); if(used[x][y]==2&amp;&amp;mp[x][y]=='G')used[x][y]=3; else if(!used[x][y])used[x][y]=1; int xx,yy; xx=x+1;yy=y-1; if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;((mp[xx][yy]!='Y'&amp;&amp;!used[xx][yy])||(mp[xx][yy]=='G'))) dfs2(xx,yy);&#125;void dfs3(int x,int y)&#123; //printf("(%d,%d)\n",x,y); if(used[x][y]==1&amp;&amp;mp[x][y]=='G')used[x][y]=3; else if(!used[x][y])used[x][y]=2; int xx,yy; xx=x+1;yy=y+1; if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;((mp[xx][yy]!='B'&amp;&amp;!used[xx][yy])||(mp[xx][yy]=='G'))) dfs3(xx,yy);&#125;void dfs4(int x,int y)&#123; //printf("(%d,%d)\n",x,y); if(used[x][y]==1&amp;&amp;mp[x][y]=='G')used[x][y]=3; else if(!used[x][y])used[x][y]=2; int xx,yy; xx=x-1;yy=y-1; if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;((mp[xx][yy]!='B'&amp;&amp;!used[xx][yy])||(mp[xx][yy]=='G'))) dfs4(xx,yy);&#125;/*void dfs(int x,int y,int tag)&#123; used[x][y]=true; int xx,yy; printf("(%d,%d) %d\n",x,y,tag); if(!tag) //BLUE &#123; xx=x-1;yy=y+1; //printf("now:(%d,%d)\n",xx,yy); if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;(mp[xx][yy]!='Y'&amp;&amp;!used[xx][yy])||(mp[xx][yy]=='G')) dfs(xx,yy,0); xx=x+1;yy=y-1; //printf("now:(%d,%d)\n",xx,yy); if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;mp[xx][yy]!='Y'&amp;&amp;!used[xx][yy]||(mp[xx][yy]=='G')) dfs(xx,yy,0); &#125; else //YELLOW &#123; xx=x+1;yy=y+1; //printf("now:(%d,%d)\n",xx,yy); if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;mp[xx][yy]!='B'&amp;&amp;!used[xx][yy]||(mp[xx][yy]=='G')) dfs(xx,yy,1); xx=x-1;yy=y-1; //printf("now:(%d,%d)\n",xx,yy); if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;mp[xx][yy]!='B'&amp;&amp;!used[xx][yy]||(mp[xx][yy]=='G')) dfs(xx,yy,1); &#125;&#125;*/int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%s",mp[i]+1); int cnt=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; if(!used[i][j]&amp;&amp;mp[i][j]!='X'&amp;&amp;mp[i][j]!='G') &#123; //printf("start:%d %d\n",i,j); cnt++; if(mp[i][j]=='B') &#123; dfs1(i,j); dfs2(i,j); &#125; else &#123; dfs3(i,j); dfs4(i,j); &#125; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; //if(mp[i][j]=='G') // printf("(%d,%d):%d\n",i,j,used[i][j]); if(mp[i][j]=='G'&amp;&amp;used[i][j]!=3) &#123; if(used[i][j]==2||used[i][j]==0) &#123; dfs1(i,j); dfs2(i,j); cnt++; &#125; //printf("(%d,%d):%d\n",i,j,used[i][j]); if(used[i][j]==0||used[i][j]==1) &#123; dfs3(i,j); dfs4(i,j); cnt++; &#125; &#125; &#125; &#125; printf("%d\n",cnt); return 0;&#125;]]></content>
      <categories>
        <category>机试</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #525 div2]]></title>
    <url>%2F2018%2F12%2F06%2FCodeforces-Round-525-div2%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/contest/1088codeforces 525 div2 题解 By usename6A. Ehab and another construction problemhttp://codeforces.com/contest/1088/problem/A题意：给你一个x，问你在[1,x]范围是否存在两个数a,b，使得$a*b&gt;x$，且$ \frac{a}{b} &lt; x $暴力枚举即可12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; int x; scanf("%d",&amp;x); bool flag=false; for(int b=1;b&lt;=x;b++) &#123; for(int a=b;a&lt;=x;a+=b) &#123; if(a*b&gt;x&amp;&amp;a/b&lt;x) &#123; printf("%d %d\n",a,b); flag=true; break; &#125; &#125; if(flag)break; &#125; if(!flag)printf("-1\n"); return 0;&#125; B. Ehab and subtractionhttp://codeforces.com/contest/1088/problem/B题意：给你一个长度为n的数组，你可以对它做K次操作，每次选出里面最小非0数，然后用这个数减去所有数，如果最后这个数组只剩0，那么输出0排序，利用前缀累加的性质，乱搞一发就行。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 100005using namespace std;typedef long long LL;LL a[MAXN];int main()&#123; int n,k; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]); sort(a+1,a+1+n); LL sum=0; printf("%lld\n",a[1]); int cnt=1; for(int i=1;i&lt;=n;i++) &#123; if(cnt==k)break; a[i]=max(a[i]-sum,0LL); if(a[i]==0)continue; sum=sum+a[i]; int id=upper_bound(a+1,a+1+n,sum)-a; printf("%lld\n",max(0LL,a[id]-sum)); cnt++; if(cnt==k)break; &#125; for(int i=cnt+1;i&lt;=k;i++) printf("0\n"); return 0;&#125; C. Ehab and a 2-operation taskhttp://codeforces.com/contest/1088/problem/C题意：给你长度为n的数组，然后你可以每次对这个元素进行两个操作，1 x y,表示1~x这段都加y2 x y,表示1~x这段都mody然后你最多能操作n+1次，问你怎么做能把他变成一个递增序列 简单题，注意是对前缀操作，那我可以指定最后一次对全体数mod n,那么就简单了，那么我可以先对长度为n的做一次前缀操作，使得最后一个数mod n等于n-1，然后遗传对长度为n-1，操作，直到第一个数为止，最后我在把所有的数mod n,这样的序列一定是递增的。1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define MAXN 100005using namespace std;int a[MAXN];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); a[i]%=n; &#125; printf("%d\n",n+1); for(int i=n;i&gt;=1;i--) &#123; int d=i-1-a[i]; if(d&lt;0)d+=n; printf("1 %d %d\n",i,d); for(int j=1;j&lt;=i;j++) a[j]=(a[j]+d)%n; &#125; printf("2 %d %d\n",n,n); return 0;&#125; D. Ehab and another another xor problemhttp://codeforces.com/contest/1088/problem/D题意：交互题，这个题是这样，让你猜数字，你可以输入a,b，要你猜c,d，系统会返回给你一系列的值a ^ c b ^ d (填写&gt; 、 &lt; 、=)如果是a ^ c &gt; b ^ d 那么返回值为1如果是a ^ c &lt; b ^ d 那么返回值为-1相等返回值为0还是一样，你最多只能进行62次操作，但c , d保证是小于$2^{30}$这题看到62次询问，会想到的位操作，每次查询位，假设你现在猜两个数字的最高位是什么？1.如果这两个数字的最高位相同，那么你分别对最高位去异或1：1）如果这两个数的都是1，那么第一个查询结果一定是-12）如果这两个数都是0，不需要做任何操作2.如果两个数字都不相同，首先设定一个flag表示当前这两个数字大小比较1）如果flag = 1,那么必然a是12）否则b是1 如何每次都使得查的是最高位，假设我已经猜出了a的29~i-1的位，那么我只需要那些这些数去异或原数，那么得到一定是i位是最高位，前面的位数都是0flag的修改，因为flag表示当前除去29~i-1位，i~1位的c和d的比较，所以若第i位相同，我则不需要改变flag,如果第i位不相同，那么我就要改变flag,将c,d当前最高位去掉，使得他们最高位第i位不受任何影响，则异或用查询1的结果去更新即可。12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;inline int ask(int c,int d)&#123; printf("? %d %d\n",c,d); fflush(stdout); int res; scanf("%d",&amp;res); return res;&#125;int main()&#123; int a=0,b=0,flag; flag=ask(a,b); for(int i=29;i&gt;=0;i--) &#123; int f1=ask(a^(1&lt;&lt;i),b); int f2=ask(a,b^(1&lt;&lt;i)); if(f1==f2) &#123; if(flag==1)a=a^(1&lt;&lt;i); else if(flag==-1)b=b^(1&lt;&lt;i); flag=f1; &#125; else if(f1==-1)a=a^(1&lt;&lt;i),b=b^(1&lt;&lt;i); &#125; printf("! %d %d\n",a,b);&#125; E. Ehab and a component choosing problemhttp://codeforces.com/contest/1088/problem/E题意：给你一个n个节点的树，让你求选K个联通快，首先要最大化比例值，即联通块的权值和/k的值，其次最大化K的值如果最大化比例，乍一看有点像01分数规划，但这里选的是联通快，而不是单独节点，这里我们放弃联通块的想法，考虑一种思路没错，就是贪心。设b是平均值若选了k个联通块，权值分别为$a{1}，a{2}，a{3}，a{4}…a{k}$那么$b=1/k*(a{1}+a{2}+…a{k})$即里面$a{i}$可以用b替换如果此时要增加平均值则必须满足$a{k+1}&gt;=b$，那么就是平均值才会增加，于是不如贪心的选最大值，然后找到和最大值相同的有多少个然后这个题就变成如何找最大联通块的问题，可以用树形DP解决，首先思考两个个问题：1.如何求解树上最大联通快2.如何求解树上最大联通快的个数3.如何求解不相交最大联通块个数可以定义状态dp[i]表示以i为根节点的子树的最大联通块的值大小，注意i必须选那么dp[i]=max(dp[i],dp[i]+dp[j]) 这里j是i的儿子节点，往上递归就行，这样就解决了如何求解最大联通块的问题。统计也是如此，当某个子树的联通块的大小等于最大值mx，则令其为0，这样保证了不相交。然后统计一下等于mx的联通快的个数有多少个，这题就做完了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define MAXN 300005using namespace std;typedef long long LL;struct Edge&#123;int v,next;&#125;;int head[MAXN],tot,w[MAXN];Edge e[MAXN&lt;&lt;1];inline void add(int u,int v)&#123; e[tot].v=v; e[tot].next=head[u]; head[u]=tot++;&#125;int n,cnt;LL mx;LL DP(int u,int pre,bool flag)&#123; LL sum=w[u]; for(int i=head[u];i!=-1;i=e[i].next) &#123; int v=e[i].v; if(v!=pre) sum=max(sum,sum+DP(v,u,flag)); &#125; if(!flag)mx=max(mx,sum); if(sum==mx&amp;&amp;flag) &#123; cnt++; return 0; &#125; return sum;&#125;int main()&#123; scanf("%d",&amp;n); memset(head,-1,sizeof(head)); tot=0; for(int i=1;i&lt;=n;i++)scanf("%d",&amp;w[i]); for(int i=1;i&lt;n;i++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v); add(v,u); &#125; mx=-1e9; DP(1,1,false); DP(1,1,true); printf("%I64d %d\n",cnt*mx,cnt); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的裁剪算法&&曲线算法]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%9B%BE%E7%9A%84%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95%E5%92%8C%E6%9B%B2%E7%BA%BF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[裁剪算法，首先先状压下线段和边界的状态，然后根据斜截式暴力判断一下就好了，没什么难度，单纯模拟暴力，图形学马上就考试，毛线不懂怎么办啊，还没修界面，还没补青岛，还没搞数据库实验，数模还没看（队友会不会打我。。。）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include "graphics.h" // 引用所需要的图形库#include &lt;algorithm&gt;#define TOP 1#define BOTTOM 2#define RIGHT 4#define LEFT 8#define x first#define y secondusing namespace std;const int XL=100,XR=300,YB=100,YT=300;int encode(int x,int y)&#123; int code=0; if(y&lt;YB)code=code|BOTTOM; if(y&gt;YT)code=code|TOP; if(x&lt;XL)code=code|LEFT; if(x&gt;XR)code=code|RIGHT; return code;&#125;void DisplayLine(int x1, int y1, int x2, int y2, int color) //中点划线&#123; int x = x1, y = y1; int a = y1 - y2, b = x2 - x1; int cx = (b &gt;= 0 ? 1 : (b = -b, -1)); int cy = (a &lt;= 0 ? 1 : (a = -a, -1)); putpixel(x, y, color); int d, d1, d2; if (-a &lt;= b) // 斜率绝对值 &lt;= 1 &#123; d = 2 * a + b; d1 = 2 * a; d2 = 2 * (a + b); while(x != x2) &#123; if (d &lt; 0) y += cy, d += d2; else d += d1; x += cx; putpixel(x, y, color); &#125; &#125; else // 斜率绝对值 &gt; 1 &#123; d = 2 * b + a; d1 = 2 * b; d2 = 2 * (a + b); while(y != y2) &#123; if(d &lt; 0) d += d1; else x += cx, d += d2; y += cy; putpixel(x, y, color); &#125; &#125;&#125;pair&lt;int,int&gt; solve(int x1,int y1,int x2,int y2)&#123; //circle(300,200,100); int x=x1,y=y1; int code=encode(x,y); while(code) &#123; if(code&amp;TOP) &#123; y=YT; x=(x1-x2)*(y-y1)/(y1-y2)+x1; &#125; if(code&amp;BOTTOM) &#123; y=YB; x=(x1-x2)*(y-y1)/(y1-y2)+x1; &#125; if(code&amp;LEFT) &#123; x=XL; y=(y1-y2)*(x-x1)/(x1-x2)+y1; &#125; if(code&amp;RIGHT) &#123; x=XR; y=(y1-y2)*(x-x1)/(x1-x2)+y1; &#125; code=encode(x,y); &#125; //circle(300,200,50); return pair&lt;int,int&gt;(x,y);&#125;void cur_line(int x1,int y1,int x2,int y2)&#123; pair&lt;int,int&gt; s=solve(x1,y1,x2,y2); pair&lt;int,int&gt; e=solve(x2,y2,x1,y1); DisplayLine(s.x,s.y,e.x,e.y,GREEN);&#125;int main()&#123; initgraph(600, 600); //初始化，显示一个窗口，这里和BGI略有区别 setcaption("裁剪算法"); //设置窗口标题。 DisplayLine(100,100,100,300,RED); DisplayLine(100,300,300,300,RED); DisplayLine(300,100,300,300,RED); DisplayLine(100,100,300,100,RED); DisplayLine(0,0,500,500,BLUE); cur_line(0,0,500,500); getch(); //暂停一下等待用户按键 closegraph(); //关闭图形界面 return 0;&#125;]]></content>
      <categories>
        <category>图形学，裁剪算法</category>
        <category>曲线</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>裁剪算法</tag>
        <tag>曲线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形的填充算法]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%9B%BE%E5%BD%A2%E7%9A%84%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[填充算法一共有三种：一种是扫描线算法，扫描线算法挺简单的，如果取y轴平行线做扫描线，把交点的x坐标丢进y扫描线就行，用几个vector维护，然后有几个条件：扫描在当前点之前到奇数个点，那就不在凸包里面，如果有偶数个点，则反之，然后这其中如果有交点是顶点则分类讨论，如果多边形上连接该点的两条边在扫描线同侧，则加2，否则加1，然后还是应用之前的条件看是否在凸包内部即可边填充就是取反，从交点开始扫，然后每次对右边取反就完事种子填充更简单，就看有没有打到边界，dfs就行，只要图形不是很大，都不会爆栈吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include "graphics.h" // 引用所需要的图形库#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int used[505][505];int mark[505][505];bool vis[505][505];struct Point&#123; int x,y; Point()&#123;&#125; Point(int a,int b):x(a),y(b)&#123;&#125; bool operator &lt;(const Point &amp;tp) &#123; if(x==tp.x)return y&lt;tp.y; return x&lt;tp.x; &#125;&#125;;vector&lt;Point&gt; G;vector&lt;int&gt; Line[505];vector&lt;Point&gt; st[100005];int dx[4]=&#123;0,0,-1,1&#125;;int dy[4]=&#123;-1,1,0,0&#125;;inline int get_id(int x,int y)&#123; return x*501+y;&#125;void BreLine(int x1,int y1,int x2,int y2)&#123; int x,y; int dx,dy; int s1,s2; //标志点,记录x1与x2、y1与y2的位置关系 int e; int t; int tag; //记录斜率情况 int i; x=x1; y=y1; dx=abs(x1-x2); dy=abs(y1-y2); if(x2&gt;x1) s1=1; else s1=-1; if(y2&gt;y1) s2=1; else s2=-1; if(dy&gt;dx) &#123; t=dx; dx=dy; dy=t; tag=1; &#125; else tag=0; e=2*dy-dx; for(i=1;i&lt;=dx;i++) &#123; putpixel(x,y,RED); used[x][y]=1; Line[y].push_back(x); G.push_back(Point(x,y)); if(e&gt;=0) &#123; if(tag==0) y=y+s2; else x=x+s1; e=e-2*dx; &#125; if(tag==0) x=x+s1; else y=y+s2; e=e+2*dy; &#125; return;&#125;void Line_paint() //边填充算法&#123; memset(mark,-1,sizeof(mark)); sort(G.begin(),G.end()); for(int i=0;i&lt;(int)G.size();i++) &#123; Point tp=G[i]; int y=tp.y; if(used[tp.x][tp.y]==2)continue; for(int x=tp.x;x&lt;=500;x++) &#123; if(mark[x][y]==-1)mark[x][y]=1; else mark[x][y]=!mark[x][y]; &#125; &#125; for(int x=0;x&lt;=500;x++) for(int y=0;y&lt;=500;y++) if(mark[x][y]==1)putpixel(x,y,RED);&#125;bool ck(int x,int y)&#123; vector&lt;int&gt;::iterator itt=lower_bound(Line[y].begin(),Line[y].end(),x); if(Line[y].size()==0)return false; if(itt==Line[y].begin()&amp;&amp;(*itt)&gt;x)return false; int cnt=0; int d=100; for(vector&lt;int&gt;::iterator it=Line[y].begin();it!=Line[y].end();it++) &#123; int xx=(*it); if(xx&gt;x) break; int yy=y; if(used[xx][yy]==2) &#123; int id=get_id(xx,yy); if(st[id][0].y&lt;=yy&amp;&amp;st[id][1].y&lt;=yy) cnt+=2; else if(st[id][0].y&gt;=yy&amp;&amp;st[id][1].y&gt;=yy) cnt+=2; else cnt++; &#125; else cnt++; &#125; return (cnt&amp;1);&#125;void dfs(int x,int y)&#123; for(int i=0;i&lt;4;i++) &#123; int xx=x+dx[i]; int yy=y+dy[i]; if(used[xx][yy]==1||used[xx][yy]==2) &#123; putpixel(x,y,GREEN); continue; &#125; if(vis[xx][yy])continue; putpixel(x,y,GREEN); vis[xx][yy]=true; dfs(xx,yy); &#125;&#125;void gram()&#123; for(int i=0;i&lt;=500;i++) &#123; for(int j=0;j&lt;=500;j++) &#123; if(used[i][j]) &#123; putpixel(i,j,GREEN); continue; &#125; if(ck(i,j)) putpixel(i,j,GREEN); &#125; &#125;&#125;int main()&#123; initgraph(500, 500); //初始化，显示一个窗口，这里和BGI略有区别 memset(used,0,sizeof(used)); for(int i=0;i&lt;=500;i++)Line[i].clear(); setcaption("填充算法"); //设置窗口标题。 BreLine(0,0,100,400); BreLine(100,400,200,0); BreLine(100,100,200,0); BreLine(0,0,100,100); //printf("yes\n"); for(int i=0;i&lt;=500;i++) &#123; if(Line[i].size()==0)continue; sort(Line[i].begin(),Line[i].end()); &#125; st[get_id(0,0)].push_back(Point(100,400)); st[get_id(0,0)].push_back(Point(100,100)); st[get_id(100,400)].push_back(Point(0,0)); st[get_id(100,400)].push_back(Point(200,0)); st[get_id(200,0)].push_back(Point(100,400)); st[get_id(200,0)].push_back(Point(100,100)); st[get_id(100,100)].push_back(Point(0,0)); st[get_id(100,100)].push_back(Point(200,0)); //printf("yes\n"); used[0][0]=used[100][400]=used[100][100]=used[200][0]=2; //Line_paint(); //dfs(100,200); gram(); getch(); //暂停一下等待用户按键 closegraph(); //关闭图形界面 return 0;&#125;]]></content>
      <categories>
        <category>图形学，填充算法</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>填充算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAIPC-C.Greeting]]></title>
    <url>%2F2018%2F11%2F06%2FNAIPC-C-Greeting%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/gym/101002国庆做的NAIPC，usename6来补题题目意思很简单，就是你给你N种信件，宽度为w，高度为h,数量为q，你可以自定义k种信封，让你求怎么制定信封，浪费的面积最小，信件不能旋转，不然可能还需要处理一下数据范围很小，很容易往折半或者是状压，但是我觉得折半的话，得32这样吧，不然失去意义了，所以往状压DP想，若定义dp[i][s]表示i种信封可以覆盖状态为s的最小信件，预处理信件集合s的最小花费c[s],很明显我先去枚举s，再在s中枚举j，判断s需不需要拆分转移方程为 $dp[i][s] = min(dp[i-1][s-j]+cost[j],dp[i][s])$ 其中j是s的子集，这样就做完了这题有一个个坑点，结果会爆int,于是答案的上界应该处理为1e16左右这题复杂度$O(3^n)$，还没证明出来。。。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define MAXN (1&lt;&lt;15)+100using namespace std;typedef long long LL;const LL INF=1e16;LL dp[16][MAXN],c[MAXN];LL w[16],h[16],q[16];int n,k;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf("%lld%lld%lld",&amp;w[i],&amp;h[i],&amp;q[i]); for(int s=1;s&lt;(1&lt;&lt;n);s++) &#123; LL mxw,mxh,need; int cnt=0; need=mxw=mxh=0LL; for(int i=0;i&lt;n;i++) &#123; if(s&gt;&gt;i&amp;1) &#123; cnt+=q[i]; mxw=max(mxw,w[i]); mxh=max(mxh,h[i]); need+=w[i]*h[i]*q[i]; &#125; &#125; c[s]=mxw*mxh*cnt-need; &#125; for(int i=0;i&lt;=k;i++) for(int j=0;j&lt;(1&lt;&lt;n);j++) dp[i][j]=INF; dp[0][0]=0; //初始化边界条件 for(int i=1;i&lt;=k;i++) //枚举能用多少个 for(int s=0;s&lt;(1&lt;&lt;n);s++) for(int j=s;j;j=(j-1)&amp;s) if(dp[i-1][s-j]&lt;INF)dp[i][s]=min(dp[i][s],dp[i-1][s-j]+c[j]); LL ans=INF; for(int i=0;i&lt;=k;i++)ans=min(ans,dp[i][(1&lt;&lt;n)-1]); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red Black Tree]]></title>
    <url>%2F2018%2F11%2F06%2FRed-Black-Tree%2F</url>
    <content type="text"><![CDATA[ZOJ 4048题目意思是给你一颗树，有n个节点，有m个红节点，当然根也是给红节点，给出q次查询，每次查询k个节点，你可以修改树上的一个黑节点为红色，求出所有修改中距离红节点的最大值的最小最大值最小，一看就是二分，这题如果不带脑袋一想，应该就是求K个点的LCA，然后暴力二分check就行，check的方法很简单吧，就对于当前答案mid，找到所有大于mid，对这些节点求LCA，这样相当于是贪心吧，因为这些点距离最大值要最小，只能尽可能走LCA，于是就很简单了，如果这些点没有LCA，那肯定不行，如果有LCA，那就查看最大值是否小于mid就OK了。据说倍增过不了，还没试，第二次写RMQ+LCA，卡的不行，没想到时间戳是两倍的空间，这个注意到了，然后上网查了一下题解，发现大家都很去掉一个log，于是去学习了下RMQ去掉log的姿势，然后做了排序剪枝二分check，当然是拉出来剪枝的，加了读入优化，硬是优化过去了，昨晚上一直卡，后来发现数组越界，然后发现答案会爆int，刷爆了ZOJ的测评，不知道是不是被ZJU给注意到了，早上起来改了改mid，然后交了一发，2010ms过吧，才发现ZOJ加时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;#define MAXN 100015#define MAXM 200030using namespace std;typedef long long LL;struct Edge&#123;int v,w,next;&#125;;Edge e[MAXM];int head[MAXN],tot;int first[MAXN*2],R[2*MAXN],p[MAXN*2],cnt,dep[MAXN];int node[MAXN],k,st[MAXN];bool isred[MAXN];int dp[MAXN*2][20];int mm[MAXN*2];LL dis[MAXN],cost[MAXN];int n,m,q;bool cmp(int a,int b)&#123; return cost[a]&gt;cost[b];&#125;int read()&#123; char c=getchar(); while (c&gt;'9'||c&lt;'0') c=getchar(); int x=0; while ('0'&lt;=c &amp;&amp; c&lt;='9')&#123; x=x*10+c-'0'; c=getchar(); &#125; return x;&#125;void add(int u,int v,int w)&#123; e[tot].v=v; e[tot].w=w; e[tot].next=head[u]; head[u]=tot++;&#125;void dfs(int u,int depth,int red,int pre)&#123; first[u]=++cnt;p[cnt]=u;R[cnt]=depth; dep[u]=depth; cost[u]=dis[u]-dis[red]; //每个节点到红色节点的距离 for(int i=head[u];i!=-1;i=e[i].next) &#123; int v=e[i].v; if(v!=pre) &#123; dis[v]=dis[u]+(LL)e[i].w; if(isred[v])dfs(v,depth+1,v,u); //下传最近的红色点 else dfs(v,depth+1,red,u); p[++cnt]=u; R[cnt]=depth; &#125; &#125;&#125;void ST(int n)&#123; mm[0]=-1; for(int i=1;i&lt;=n;i++) mm[i] = ((i&amp;(i-1)) == 0) ? mm[i-1]+1 : mm[i-1]; for(int i=1;i&lt;=n;i++)dp[i][0]=i; for(int j=1;j&lt;=mm[n];j++) &#123; for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) &#123; int a=dp[i][j-1],b=dp[i+(1&lt;&lt;(j-1))][j-1]; dp[i][j]=R[a]&lt;R[b]?a:b; &#125; &#125;&#125;int RMQ(int l,int r)&#123; int k=mm[r-l+1]; int a=dp[l][k],b=dp[r-(1&lt;&lt;k)+1][k]; return R[a]&lt;R[b]?a:b;&#125;int LCA(int u,int v)&#123; int x=first[u],y=first[v]; if(x&gt;y)swap(x,y); int res=RMQ(x,y); return p[res];&#125;bool ck(LL mid)&#123; int top=0; //top的值 for(int i=1;i&lt;=k;i++) &#123; if(cost[node[i]]&gt;mid) st[++top]=node[i]; &#125; if(top&lt;=1)return true; //小于或等于1个点改这个点即可 int lca=st[1]; for(int i=2;i&lt;=top;i++) lca=LCA(lca,st[i]); for(int i=1;i&lt;=top;i++) if(dep[lca]&gt;dep[st[i]])return false; //不存在LCA for(int i=1;i&lt;=top;i++) if(dis[st[i]]-dis[lca]&gt;mid)return false; //大于答案的值 return true;&#125;int main()&#123; int t; t=read(); while(t--) &#123; n=read();m=read();q=read(); memset(isred,false,sizeof(isred)); cnt=tot=0; memset(head,-1,sizeof(head)); for(int i=1;i&lt;=m;i++) &#123; int id; id=read(); isred[id]=true; &#125; for(int i=1;i&lt;n;i++) &#123; int u,v,w; u=read();v=read();w=read(); add(u,v,w); add(v,u,w); &#125; dis[1]=0; dfs(1,1,1,1); ST(2*n-1); //dfs序是二倍 while(q--) &#123; k=read(); LL mx=0; for(int i=1;i&lt;=k;i++) node[i]=read(); sort(node+1,node+1+k,cmp); mx=cost[node[1]]; LL l=0,r=mx; LL ans; while(l&lt;=r) &#123; LL mid=(l+r)&gt;&gt;1; if(ck(mid)) &#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>LCA</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>LCA</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maze Designer]]></title>
    <url>%2F2018%2F11%2F04%2FMaze-Designer%2F</url>
    <content type="text"><![CDATA[题目地址:https://nanti.jisuanke.com/t/31462题目给你nxm的方阵图，用最小花费建墙，相当于是迷宫，且每个方格互相可达，并且最短路径唯一，相当于是nxm的生成树，给出q次查询，求出任意这两个点的最短距离首先去建一个最大生成树，因为生成树任意两个点均可达，最大是因为要让其花费最小，把所有花费大的墙拆掉，这样就留下一个唯一的路径，而且花费最小，且任意两点可达123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;#define MAXN 250010#define MAXM 500020using namespace std;typedef long long LL;int n,m;struct Edge&#123; int u,v,next,w; bool operator &lt;(const Edge &amp;tp) &#123; return w&gt;tp.w; &#125;&#125;;struct LCA&#123; Edge e[MAXM]; int fa[MAXN][25]; int head[MAXN]; int dep[MAXN]; int dis[MAXN]; int tot; int height; void init() &#123; memset(head,-1,sizeof(head)); tot=0; height=20; &#125; void add(int u,int v,int w) &#123; e[tot].v=v; e[tot].w=w; e[tot].next=head[u]; head[u]=tot++; &#125; void dfs(int u) &#123; for(int i=1;i&lt;=height;i++) &#123; if(fa[u][i-1]!=-1)fa[u][i]=fa[fa[u][i-1]][i-1]; else break; &#125; for(int i=head[u];i!=-1;i=e[i].next) &#123; int v=e[i].v; if(fa[u][0]!=v) &#123; dis[v]=dis[u]+e[i].w; dep[v]=dep[u]+1; fa[v][0]=u; dfs(v); &#125; &#125; &#125; int lca(int u,int v) &#123; if(dep[u]&lt;dep[v])swap(u,v); int d=dep[u]-dep[v]; for(int i=0;i&lt;=height;i++) &#123; if((1&lt;&lt;i)&amp;d) u=fa[u][i]; &#125; if(u==v)return u; for(int h=height;h&gt;=0;h--) &#123; if(fa[u][h]!=fa[v][h]) &#123; u=fa[u][h]; v=fa[v][h]; &#125; &#125; return fa[u][0]; &#125; int query(int u,int v) &#123; return dis[u]+dis[v]-2*dis[lca(u,v)]; &#125;&#125;;LCA L;struct Krusal&#123; Edge e[MAXM]; int f[MAXN]; int tot; //多少条边 int N; void init() &#123; tot=0; for(int i=1;i&lt;=N;i++)f[i]=i; &#125; void add(int u,int v,int w) &#123; e[tot].u=u; //记录起点 e[tot].v=v; e[tot].w=w; tot++; &#125; int fid(int u)&#123;return f[u]==u?u:f[u]=fid(f[u]);&#125; //并查集 void krusal() &#123; sort(e,e+tot); int cnt=0; for(int i=0;i&lt;tot;i++) &#123; int f1=fid(e[i].u); int f2=fid(e[i].v); if(f1!=f2) &#123; f[f1]=f2; //记录最大生成树的边 L.add(e[i].u,e[i].v,1); L.add(e[i].v,e[i].u,1); cnt++; &#125; if(cnt&gt;=N-1)return; &#125; &#125;&#125;;Krusal K;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; K.N=n*m; K.init(); L.init(); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; char s1[10],s2[10]; int w1,w2; scanf("%s%d%s%d",s1,&amp;w1,s2,&amp;w2); if(s1[0]=='D') K.add((i-1)*m+j,i*m+j,w1); if(s2[0]=='R') K.add((i-1)*m+j,(i-1)*m+j+1,w2); &#125; &#125; K.krusal(); int q; scanf("%d",&amp;q); L.dfs(1); for(int i=1;i&lt;=q;i++) &#123; int x1,y1,x2,y2; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); int u=(x1-1)*m+y1; int v=(x2-1)*m+y2; printf("%d\n",L.query(u,v)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bresenham算法]]></title>
    <url>%2F2018%2F10%2F29%2FBresenham%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Bresenham算法是第三种基于扫描线的算法，第一种是DDA算法，非常简单，直接强制转化y（四舍五入）然后绘点，而中点画线法，通过将函数隐式化，通过不等式关系，查看点与直线的关系，选择最近的像素点那么Bresenham算法又是怎么做的呢？假设$dx = x2 - x1 $, $dy = y2 - y1$,那么直线方程可以表示为$(\frac{dy}{dx})x + b = y$取$k = \frac{dy}{dx}$若假设点$p{i}$坐标为$(x{i},y_{i})$,则分类对直线斜率进行分类讨论k &gt; 0 时，若直线是按坐标序枚举，很容易发现相邻两个坐标之间的增量是正值若$|dx| &gt; |dy|$剩下的过程其实和中点画线差不多，详细过程改日再补123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;GL/glut.h&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;void Bresenham(int x1,int y1,int x2,int y2)&#123; int x,y,dx,dy,d,d1,d2,inc; dx=x2-x1; dy=y2-y1; if(dx*dy&gt;=0)inc=1; else inc=-1; if(abs(dx)&gt;abs(dy)) &#123; if(dx&lt;0) &#123; std::swap(x1,x2); std::swap(y1,y2); dx=-dx;dy=-dy; &#125; d=2*dy-dx; d1=2*dy; d2=2*(dy-dx); x=x1; y=y1; while(x&lt;x2) &#123; glPointSize(5.0); glBegin(GL_POINTS); glVertex2i(x,y); glEnd(); x++; if(d&lt;0)d+=d1; else &#123; y+=inc; d+=d2; &#125; &#125; &#125; else &#123; if(dy&lt;0) &#123; std::swap(x1,x2); std::swap(y1,y2); dx=-dx;dy=-dy; &#125; d=2*dy-dx; d1=2*dy; d2=2*(dy-dx); x=x1; y=y1; while(y&lt;y2) &#123; glPointSize(5.0); glBegin(GL_POINTS); glVertex2i(x,y); glEnd(); y++; if(d&lt;0)d+=d1; else &#123; x+=inc; d+=d2; &#125; &#125; &#125;&#125;void display()&#123; glClearColor(1.0, 1.0, 1.0, 1.0); glClear(GL_COLOR_BUFFER_BIT); glViewport(0,0,500,500); Bresenham(0,0,500,100); Bresenham(0,0,500,200); Bresenham(0,0,500,300); Bresenham(0,0,500,400); Bresenham(0,500,500,0); //printf("over\n"); glFlush();&#125;int main(int argc,char **argv)&#123; glutInit(&amp;argc,argv); glutInitDisplayMode(GLUT_SINGLE|GLUT_RED); glutInitWindowSize(500,500); glutInitWindowPosition(0,0); glutCreateWindow("MPLine"); glutDisplayFunc(display); //调用里面函数的绘图函数（当然是你定义） glColor3f(0.0, 0.0, 0.0); gluOrtho2D(0.0, 500.0, 0.0, 500.0); glutMainLoop(); return 0;&#125;]]></content>
      <categories>
        <category>图形学</category>
        <category>Open GL</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Open GL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP优化专题二]]></title>
    <url>%2F2018%2F10%2F29%2FDP%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[垃圾usename6又来更新DP专题了。。。今天要讲的是DP的第二个专题优化，倍增优化，之前在专题一中，我们已经说过了，DP优化无非从时间，即DP转移入手，或是从空间入手。下面我来看一道这样题目（来源HDU 2157）给定一个有向图，问从A点恰好走k步（允许重复经过边）到达B点的方案数mod p的值乍一看是图论，实际上可以从DP角度去考虑这个题，定义状态dp[u][k]表示走k步走到u这个节点的方案数是多少，很明显根据图的性质和加法原理，转移为dp[v][k]+=dp[u][k-1] （存在u—-&gt; v的 有向边）但是若这个k很大的时候，难免就要进行很大计算，我们发现不管走多少步，只要你从k节点出发，转移是固定的，转移的方程也是固定的（！这个很重要）于是，我们可以采用倍增去加速一阶线性递推式，即矩阵快速幂去倍增优化转移两个状态到两个状态之间转移应该是邻接矩阵，于是对邻接矩阵进行快速幂优化转移即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define maxn 200using namespace std;typedef struct&#123; int a[maxn][maxn];&#125;Martix;const int mod=1000;Martix unit;int n,m;Martix operator*(Martix a,Martix b)&#123; Martix res; memset(res.a,0,sizeof(res.a)); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; for(int k=0;k&lt;n;k++) &#123; res.a[i][j]=(res.a[i][j]+a.a[i][k]*b.a[k][j])%mod; &#125; &#125; &#125; return res;&#125;void init()&#123; memset(unit.a,0,sizeof(unit.a)); for(int i=0;i&lt;n;i++) unit.a[i][i]=1;&#125;Martix qpow_mod(Martix a,int n)&#123; Martix res=unit; while(n) &#123; if(n&amp;1) res=res*a; n&gt;&gt;=1; a=a*a; &#125; return res;&#125;int main()&#123; int s,e,k,cnt,t,A,B; Martix res,tmp; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; if(!n&amp;&amp;!m)break; memset(tmp.a,0,sizeof(tmp.a)); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;s,&amp;e); tmp.a[s][e]=1; //printf("%d %d\n",s,e); &#125; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d%d",&amp;A,&amp;B,&amp;k); init(); res=qpow_mod(tmp,k); cnt=res.a[A][B]; printf("%d\n",cnt); &#125; &#125; return 0;&#125; 一开始我一直错误的认为矩阵的倍增优化转移只能在一阶线性递推式解决，知道发现了这道题：有n天，m件衣服，如果某一天穿了第i件衣服，第二天穿了第j件衣服，那么就会获得f[i][j]的权值。然后给你矩阵f，每件衣服可以穿无限多次，问第n天能获得的最大权值是多少。同样的我们发现，若是定义状态dp[u][k]表示第k天穿了u这件服装，那么转移式子只需把上面的式子进行小小的改动：dp[v][k] = max(dp[u][k-1] + f[u][v]) (u—-&gt;v相连)同样的不管k是多少，对于每个节点的u的转移是不变的，每次都会用到这个矩阵去转移，于是我们采用了模仿矩阵快速幂的方向，做倍增优化，其实是取max和+运算的结合律导致的，这个不做证明，需要用到离散数学的群论和代数系统的知识，有兴趣自行证明，于是导致我们可以先算后面在和前面合并1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define MAXN 105using namespace std;typedef long long LL;typedef struct&#123; LL a[MAXN][MAXN];&#125;Martix;Martix unit;int n,m;Martix operator*(Martix a,Martix b)&#123; Martix ans; memset(ans.a,0,sizeof(ans.a)); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; for(int k=1;k&lt;=n;k++) &#123; ans.a[i][j]=max(ans.a[i][j],a.a[i][k]+b.a[k][j]); &#125; &#125; &#125; return ans;&#125;void init()&#123; memset(unit.a,0,sizeof(unit.a)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) unit.a[i][i]=1;&#125;Martix qpow_mod(Martix a,LL n)&#123; Martix res; memset(res.a,0,sizeof(res.a)); while(n) &#123; if(n&amp;1)res=res*a; n&gt;&gt;=1; a=a*a; &#125; return res;&#125;Martix tmp,ret;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n)!=EOF) &#123; init(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%lld",&amp;tmp.a[i][j]); ret=qpow_mod(tmp,(LL)m-1);// for(int i=1;i&lt;=n;i++)// &#123;// for(int j=1;j&lt;=n;j++)// &#123;// printf("%lld ",ret.a[i][j]);// &#125;// puts("");// &#125; LL ans=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) ans=max(ans,ret.a[i][j]); printf("%lld\n",ans); &#125; return 0;&#125; 上述两个都是类似分层图的DP，因此没有后效性，可以自己思考一下，状态有二维，尽管图上有环也不会导致后效性]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP优化专题一]]></title>
    <url>%2F2018%2F10%2F28%2FDP%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[DP优化专题虽然不是DP的选手，但是可见DP的重要性，DP这个东西高深的很，打算写一写关于DP的事情，usename6 DP 水平有限？dalao求轻喷DP优化一 枚举优化曾经在一次暑假集训的讲课中，选择了讲DP，本来就不是很懂DP这个东西，于是随便选了几个题讲讲，没想到就讲出了DP的其中一个优化，枚举优化，若不是雨神说，我可能都不知道这是什么。。。枚举优化是什么？DP的优化有两种方向，第一种是选择优化时间，第二种是优化空间，如果从时间的角度去考虑优化，那么就要从转移上考虑，如何优化转移，是优化时间重要的思想首先思考这样一个问题：给一个nxm的矩阵，要求你求出一个子矩阵，使得这个矩阵的和最大这个题的传统做法就是枚举起点(x1,y1)、终点(x2,y2)，然后套两重循环，复杂度O($n^6$)一个优化就是加上二维前缀和，这样省去了两个循环，复杂度O($n^4$)固定行的上下界，然后将一列压成一个元素，这题就变成了最大子段和的问题，DP即可O($n^3$)1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define maxn 600using namespace std;typedef long long LL;int n,m;LL sum[maxn][maxn],a[maxn],dp[maxn];int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int x; scanf("%d",&amp;x); sum[i][j]=sum[i-1][j]+x; &#125; &#125; LL mx=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=n;j++) &#123; dp[0]=0; for(int k=1;k&lt;=m;k++) &#123; a[k]=sum[j][k]-sum[i-1][k]; dp[k]=max(a[k],dp[k-1]+a[k]); mx=max(mx,dp[k]); &#125; &#125; &#125; printf("%lld\n",mx); return 0;&#125;但是这个题还有一种优化，就是可以枚举优化掉这个东西转移假设你换一种角度去思考这道题我都把矩阵的上下界固定了，左右的界能不能固定，对应每个矩阵右端列，我能不能快速找到左端列，使得以该右端列结尾的最大连续子矩阵和单调队列去优化转移，每次存该列的前缀子矩阵和（类似扫描线推进），然后在1~当前枚举右端列i-1中从单调队列快速提出来12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define maxn 600using namespace std;typedef long long LL;int n,m;LL sum[maxn][maxn],q[maxn];int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int x; scanf("%d",&amp;x); sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+x; &#125; &#125; LL mx=0; int qs,qe; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=n;j++) &#123; qs=0;qe=1; q[0]=0; //printf("%d %d\n",i,j); for(int k=1;k&lt;=m;k++) &#123; //printf("k = %d\n",k); LL data=sum[j][k]-sum[i-1][k]; //printf("data = %I64d\n",data); if(qs&lt;qe)mx=max(mx,data-q[qs]); while(qs&lt;qe) &#123; if(data&gt;=q[qe-1])break; qe--; &#125; q[qe]=data; qe++; &#125; &#125; &#125; printf("%lld\n",mx); return 0;&#125;由于是前缀，于是可以做枚举优化？由于每次转移需要都是1~i-1的前缀子矩阵和，于是只需要开个数mx维护1~i-1的最小值即可1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define maxn 600#define INF 0x3f3f3f3fusing namespace std;typedef long long LL;int n,m;LL sum[maxn][maxn],q[maxn];int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int x; scanf("%d",&amp;x); sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+x; &#125; &#125; LL mx=0,mm; int qs,qe; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=n;j++) &#123; mm=0; for(int k=1;k&lt;=m;k++) &#123; LL data=sum[j][k]-sum[i-1][k]; if(k!=1)mx=max(mx,data-mm); if(k==1)mx=max(mx,data); mm=min(mm,data); &#125; &#125; &#125; printf("%lld\n",mx); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wannafly挑战赛27]]></title>
    <url>%2F2018%2F10%2F28%2FWannafly%E6%8C%91%E6%88%98%E8%B5%9B27%2F</url>
    <content type="text"><![CDATA[https://www.nowcoder.com/acm/contest/215#questionA.灰魔法师给出长度为n的序列a, 求有多少对数对 (i, j) (1 &lt;= i &lt; j &lt;= n) 满足 $a{i} + a{j}$ 为完全平方数。因为这玩意$n&lt;=100000$，于是我去暴力打了一个表，发现这个完全平方数不是很多，直接二分check就行了，跟沈阳的G比起来差远了1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;vector&lt;int&gt; v;int n;int a[200005];int cnt[200005];int main()&#123; for(int i=1;i&lt;=200000;i++) &#123; int tp=sqrt(i); if(tp*tp==i) v.push_back(i); &#125; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); cnt[a[i]]++; &#125; LL ans=0; for(int i=1;i&lt;=n;i++) &#123; int id=upper_bound(v.begin(),v.end(),a[i])-v.begin(); //printf("yes\n"); for(int j=id;j&lt;(int)v.size();j++) &#123; ans+=cnt[v[j]-a[i]]; if(v[j]==2*a[i])ans--; &#125; &#125; printf("%lld\n",ans/2); return 0;&#125; B.紫魔法师给出一棵仙人掌(每条边最多被包含于一个环，无自环，无重边，保证连通)，要求用最少的颜色对其顶点染色，满足每条边两个端点的颜色不同，输出最小颜色数即可签到题二，这个题，很明显发现答案的取值范围在1，2，3之间，为什么呢，因为题目保证每条边最多被包含一个环，也就是这个图好吧，就是类似联通快一个东西，可以证明奇数环下，至少需要3个颜色，其余偶环和长度为2的颜色只需要2个颜色，然后特殊考虑其中一个边界，那就是都是单点的时候，这个时候一个颜色就行，偶环就用二分图染色法搞一搞。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;vector&lt;int&gt; G[MAXN];int n,m;int color[MAXN];bool BFS(int s)&#123; queue&lt;int&gt; q; //printf("s=%d\n",s); color[s]=1; q.push(s); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0;i&lt;(int)G[u].size();i++) &#123; int v=G[u][i]; if(color[v]!=-1&amp;&amp;color[v]==color[u])return true; if(color[v]==-1)q.push(v); color[v]=color[u]^1; &#125; &#125; return false;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); if(!m) &#123; printf("1\n"); return 0; &#125; for(int i=1;i&lt;=m;i++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; memset(color,-1,sizeof(color)); bool flag=false; for(int i=1;i&lt;=n;i++) &#123; if(color[i]==-1) &#123; if(BFS(i)) &#123; flag=true; break; &#125; &#125; &#125; flag?puts("3"):puts("2"); return 0;&#125; C.蓝魔法师 “你，你认错人了。我真的，真的不是食人魔。”—蓝魔法师 给出一棵树，求有多少种删边方案，使得删后的图每个连通块大小小于等于k，两种方案不同当且仅当存在一条边在一个方案中被删除，而在另一个方案中未被删除，答案对998244353取模考试的时候，想出是树形dp，怎么合并啊，想了一个小时，想不出来，遂弃疗，好吧其实是再不复习图形学就GG了。dp[u][num]表示根节点为u的子树下大小为num节点合并的方案数首先去枚举儿子节点，然后去枚举每个儿子中的多少个节点和父亲合并后的方法数，很明显是个乘法原理，把所有的方案数加起来这操作很秀吧，滚两个数组，c和dp，c表示合并当前子树的方案数，然后滚动一下，怎么老是滚动优化，真的是。。。，DP这么喜欢用滚动吗然后注意考虑下DP边界，就是儿子选0个合并的时，需要计算子树v 1~k的方案数的和，因为不选的话,v也是一样1~k的选择权（选k以上肯定不符合题意）于是这题就做完了，不得不说usename6 DP 真垃圾1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 2010using namespace std;typedef long long LL;const LL mod=998244353;struct Edge&#123;int v,next;&#125;;int head[MAXN],num[MAXN],tot,n,k;LL dp[MAXN][MAXN],c[MAXN];Edge e[MAXN&lt;&lt;1];void add(int u,int v)&#123; e[tot].v=v; e[tot].next=head[u]; head[u]=tot++;&#125;void dfs(int u,int pre)&#123; //printf("u=%d\n",u); dp[u][1]=1; //初始化当u这个子树为1的方案数 num[u]=1; //表示u的子树个数 for(int i=head[u];i!=-1;i=e[i].next) &#123; int v=e[i].v; if(v!=pre) &#123; dfs(v,u); //printf("%d --- &gt; %d\n",u,v); for(int x=0;x&lt;=num[v];x++) //枚举v子树的大小，从0开始是因为他可不选 &#123; for(int y=1;y&lt;=num[u];y++) //枚举u子树的大小，从1开始是因为他必须选 &#123; c[x+y]+=dp[u][y]*dp[v][x]%mod; c[x+y]%=mod; //printf("%d %lld\n",x+y,c[x+y]); &#125; &#125; num[u]+=num[v]; for(int x=1;x&lt;=num[u];x++) &#123; dp[u][x]=c[x]; c[x]=0; &#125; &#125; &#125; for(int i=1;i&lt;=min(k,num[u]);i++) dp[u][0]=(dp[u][0]+dp[u][i])%mod;&#125;int main()&#123; memset(head,-1,sizeof(head)); tot=0; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;n;i++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v); add(v,u); &#125; dfs(1,1); printf("%lld\n",dp[1][0]); return 0;&#125; D.绿魔法师听说是容斥？数论选手决定留坑]]></content>
      <categories>
        <category>ACM</category>
        <category>Wannafly</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Wannafly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中点画线算法]]></title>
    <url>%2F2018%2F10%2F28%2F%E4%B8%AD%E7%82%B9%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[图形学扫描线算法复习中，拯救图形学计划。。。首先这个算法是有适用范围的：$0 &lt; k &lt; 1 $首先将一般的直线方程转化为： $ F(x,y) = ax + by + c $很明显我们发现1.当$F(x,y) = 0$时，点(x,y)在直线上2.当$F(x,y) &gt; 0$时，点(x,y)在直线的上方3.当$F(x,y) &lt; 0$时，点(x,y)在直线的下方若设当前像素点P点$(x{p},y{p})$，那么其中点M点$(x{p} + 1,y{p} + 0.5)$定义 $d = F(M) = F(x{p} + 1,y{p} + 0.5) = a(x{p} + 1) + b(y{p} + 1) + c$对d分类讨论有若d大于0，即M点在直线上方，取$P{1}$点此时由$P{1}$生成的F值（差值）为d1$d1 = F(x{p} + 2,y{p} + 0.5) = a(x{p} + 2) + b(y{p} + 0.5) + c = d + a $即 $x{p+1} = x{p} + 2$ $y{p+1} = y{p} + 0.5$ $d{p+1} = d{p} + a若d小于0，即M点在直线下方，取$P{2}点同理 $ d2 = F{x{p} + 2, y{p} + 1.5} = a(x{p} + 2) + b(y{p} + 1.5) + c = d + a + b $即 $x{p+1} = x{p} + 2$ $y{p+1} = y{p} + 1.5$ $d{p+1} = d_{p} + a + b$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;GL/glut.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;void MP_Line(int x0,int y0,int x1,int y1)&#123; int a,b,d1,d2,d,x,y; a=y0-y1; b=x1-x0; d=a+a+b; d1=a+a; d2=a+a+b+b; x=x0; y=y0; while(x&lt;x1) &#123; glPointSize(5.0); glBegin(GL_POINTS); if(d&lt;0) &#123; glVertex2f(x,y); glEnd(); x++; y++; d+=d2; &#125; else &#123; glVertex2f(x,y); glEnd(); x++; d+=d1; &#125; //printf("(%d,%d)\n",x,y); &#125;&#125;void display()&#123; glClearColor(1.0, 1.0, 1.0, 1.0); glClear(GL_COLOR_BUFFER_BIT); glViewport(0,0,500,500); MP_Line(0,0,500,100); MP_Line(0,0,500,200); MP_Line(0,0,500,300); MP_Line(0,0,500,400); //printf("over\n"); glFlush();&#125;int main(int argc,char **argv)&#123; glutInit(&amp;argc,argv); glutInitDisplayMode(GLUT_SINGLE|GLUT_RED); glutInitWindowSize(500,500); glutInitWindowPosition(0,0); glutCreateWindow("MPLine"); glutDisplayFunc(display); //调用里面函数的绘图函数（当然是你定义） glColor3f(0.0, 0.0, 0.0); gluOrtho2D(0.0, 500.0, 0.0, 500.0); glutMainLoop(); return 0;&#125;]]></content>
      <categories>
        <category>OpenGL</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDA算法]]></title>
    <url>%2F2018%2F10%2F27%2FDDA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今日连更四篇，也是很肛（沉迷博客无法自拔）。。。原理：假设直线为：$ y = kx + b $分两种情况讨论1.当$ | k | &lt; = 1 $则设$x{i+1} = x{i} + 1$那么$y{i+1} = y{i} + k$2.当$ | k | &gt; = 1 $则将直线方程转化为$ x = (1/k)y - b/k $则设$y{i+1} = y{i} + 1$那么$x{i+1} = x{i} + 1/k$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;GL/glut.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;void DDA_Line(int x1,int y1,int x2,int y2) //描绘点在(x1,y1)到(x2,y2)之间的线段&#123; float k; //表示斜率 float t; //在这之间像素点有多少个 float x; //起始点x坐标 float y; //起始点y坐标 float dx=x2-x1; //x方向的增量 float dy=y2-y1; //y方向的增量 bool tag=false; //表示斜率的绝对值是大于还是小于1,大于1为true,小于1为false if(abs(dx)&gt;=abs(dy)) &#123; k=dy/dx; t=dx; tag=true; &#125; else &#123; k=dx/dy; t=dy; tag=false; &#125; x=x1; y=y1; for(int i=0;i&lt;=t;i++) //枚举这之间的像素点 &#123; glPointSize(1.0); glBegin(GL_POINTS); if(tag) &#123; glVertex2f(x,int(y+0.5)); glEnd(); y=y+k; x++; &#125; else &#123; glVertex2f(int(x+0.5),y); glEnd(); x=x+k; y++; &#125; &#125;&#125;void display()&#123; glClearColor(1.0, 1.0, 1.0, 1.0); //白色 glClear(GL_COLOR_BUFFER_BIT); //设置背景为白色 glViewport(0,0,500,500); DDA_Line(0,500,500,0); DDA_Line(0,0,500,600); DDA_Line(250,0,250,500); DDA_Line(0,250,500,250); glFlush();&#125;int main(int argc,char **argv)&#123; glutInit(&amp;argc,argv); glutInitDisplayMode(GLUT_SINGLE|GLUT_RED); glutInitWindowSize(500,500); glutInitWindowPosition(0,0); glutCreateWindow("DDA_Line"); glutDisplayFunc(display); //调用里面函数的绘图函数（当然是你定义） glColor3f(0.0, 1.0, 1.0); gluOrtho2D(0.0, 500.0, 0.0, 500.0); glutMainLoop(); return 0;&#125;]]></content>
      <categories>
        <category>OpenGL</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Open GL 基本函数二]]></title>
    <url>%2F2018%2F10%2F27%2FOpen-GL-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Open GL 基本函数二1void glClearColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha);参数分别是红，绿，蓝，不透明度，取值范围在[0,1]，仅仅只是执行设定颜色，不执行清除工作，仅仅是为了glClear()函数做准备 1glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT) 参数可为一个或多个，若为多个，用’|’隔开GL_COLOR_BUFFER_BIT当前可写的颜色缓冲GL_DEPTH_BUFFER_BIT深度缓冲GL_ACCUM_BUFFER_BIT累积缓冲GL_STENCIL_BUFFER_BIT模板缓冲 如果两个函数结合一起用，即12glClearColor(1.0, 1.0, 1.0, 1.0); //白色glClear(GL_COLOR_BUFFER_BIT);表示把背景设置成蓝色 1void glPointSize(GLfloat size) 设置绘制时点的大小，大小单位为像素，默认值为1.0，很明显要大于0.0f 1void glBegin(GLenum mode) mode表示创建元素的类型，有如下几个类型GL_POINTS 单个顶点集GL_LINES 多组双顶点线段GL_POLYGON 单个简单填充凸多边形GL_TRAINGLES 多组独立填充三角形GL_QUADS 多组独立填充四边形GL_LINE_STRIP 不闭合折线GL_LINE_LOOP 闭合折线GL_TRAINGLE_STRIP 线型连续填充三角形串GL_TRAINGLE_FAN 扇形连续填充三角形串GL_QUAD_STRIP 连续填充四边形串 1void glEnd(void) 一个几何图形绘制的结束 1glVertex2f(float,float) 设定点的坐标，f表示参数是浮点数类似的还有：glVertex2dglVertex2fglVertex3fglVertex3fv字母表示参数的类型1.s表示16位整数（OpenGL中将这个类型定义为GLshort），2.i表示32位整数（OpenGL中将这个类型定义为GLint和GLsizei），3.f表示32位浮点数（OpenGL中将这个类型定义为GLfloat和GLclampf），4.d表示64位浮点数（OpenGL中将这个类型定义为GLdouble和GLclampd）。5.v表示传递的几个参数将使用指针的方式。 1glViewport(GLint x,GLint y,GLsizei width,GLsizei height) x，y 以像素为单位，指定了视口的左下角位置。width，height 表示这个视口矩形的宽度和高度，根据窗口的实时变化重绘窗口。]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Open GL 基本函数一]]></title>
    <url>%2F2018%2F10%2F27%2FOpen-GL-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Open-GL 基本函数一转战图形学（其实为了应付考试。。。，再不复习就挂科了。。。）1void glutInit(int* argc,char** argv) 这个函数用来初始化GLUT，此时main函数也有对应的参数：1int main(int argc,char* argv[])glutInit是从main函数获取参数 1void glutInitWindowSize(int width,int height) 该函数用于初始化窗口的大小 1void glutInitWindowPosition(int x,int y) 该函数用来初始化窗口左上角是什么，以像素为单位 1void glutInitDisplayMode(unsigned int mode) 显示模式，可供选择的参数：1.GLUT_RGBA：当未指明GLUT-RGBA或GLUT-INDEX时，是默认使用的模式。表明欲建立RGBA模式的窗口。2.GLUT_RGB：与GLUT-RGBA作用相同。3.GLUT_INDEX：指明为颜色索引模式。4.GLUT_SINGLE：只使用单缓存5.GLUT_DOUBLE：使用双缓存。以避免把计算机作图的过程都表现出来，或者为了平滑地实现动画。6.GLUT_ACCUM：让窗口使用累加的缓存。7.GLUT_ALPHA：让颜色缓冲区使用alpha组件。8.GLUT_DEPTH：使用深度缓存。9.GLUT_STENCIL：使用模板缓存。10.GLUT_MULTISAMPLE：让窗口支持多例程。11.GLUT_STEREO：使窗口支持立体。12.GLUT_LUMINACE:luminance是亮度的意思。但是很遗憾，在多数OpenGL平台上，不被支持。 1glColor3f(float, float, float) 好吧，他有三个浮点参数，但是不清楚是什么（其实是懒得翻他headfile了）其中0.0表示不使用颜色成分，1.0表示使用颜色最大值具体参数对应的颜色如下12345678glColor3f(0.0, 0.0, 0.0); --&gt; 黑色 glColor3f(1.0, 0.0, 0.0); --&gt; 红色 glColor3f(0.0, 1.0, 0.0); --&gt; 绿色 glColor3f(0.0, 0.0, 1.0); --&gt; 蓝色 glColor3f(1.0, 1.0, 0.0); --&gt; 黄色 glColor3f(1.0, 0.0, 1.0); --&gt; 品红色 glColor3f(0.0, 1.0, 1.0); --&gt; 青色 glColor3f(1.0, 1.0, 1.0); --&gt; 白色 这个函数有个需要注意的是，如果在glBegin()与glEnd()连续调用多个这个函数，只显示最后一个]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 53 (Rated for Div. 2)]]></title>
    <url>%2F2018%2F10%2F27%2FEducational-Codeforces-Round-53-Rated-for-Div-2%2F</url>
    <content type="text"><![CDATA[传送门：http://codeforces.com/contest/1073职业fst选手没有被fst，可喜可贺，成功的上了分A. Diverse Substring水题，直接枚举所有子串判断一下就行，实际上有个更好的做法，直接看相邻的两个字母是不是相同，不相同的话，就取那两个就行了，复杂度O(n)A.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;string s;int cnt[30];int main()&#123; int n; cin&gt;&gt;n; cin&gt;&gt;s; bool flag=false; for(int i=0;i&lt;n;i++) &#123; for(int j=1;i+j-1&lt;n;j++) &#123; string ss=s.substr(i,j); memset(cnt,0,sizeof(cnt)); for(int k=0;k&lt;ss.size();k++) &#123; int id=ss[k]-'a'; cnt[id]++; &#125; bool tag=true; for(int k=0;k&lt;26;k++) &#123; if(cnt[k]&gt;ss.size()/2) &#123; tag=false; break; &#125; &#125; if(tag) &#123; flag=true; cout&lt;&lt;"YES"&lt;&lt;endl; cout&lt;&lt;ss&lt;&lt;endl; &#125; if(flag)break; &#125; if(flag)break; &#125; if(!flag)cout&lt;&lt;"NO"&lt;&lt;endl; return 0;&#125; B. Vasya and Books没什么难度，按题目模拟就行B.cpp12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;int a[200005];int b[200005];bool used[200005];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]); int j=1; for(int i=1;i&lt;=n;i++) &#123; if(used[b[i]]) printf("%d%c",0,i==n?'\n':' '); else &#123; int cnt=0; for(;j&lt;=n;j++) &#123; cnt++; used[a[j]]=true; if(a[j]==b[i]) &#123; j++; break; &#125; &#125; //printf("%d %d\n",b[j],a[i]); //printf("j=%d cnt=%d\n",j,cnt); printf("%d%c",cnt,i==n?'\n':' '); &#125; &#125; return 0;&#125; C. Vasya and Robot题目意思就是给你长度为n移动序列，让你通过修改给定移动序列，使得你能从(0,0)到(x,y)，并求出所有修改中，最大的位置-最小位置+1的最小值刚开始看这题，感觉是双指针，不算很快速的敲完了双指针，后来发现双指针是个假算法，冷静分析了一下，发现区间具有单调性，而且，我只有固定好修改的区间在哪，直接看当前区间的长度和距离之间的关系，二分check一下就好了，最后三分钟绝杀这题C.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n;char op[200005];int x,y;int dx[200005],dy[200005];bool check(int mid)&#123; int cx=0,cy=0; //printf("mid=%d\n",mid); for(int i=1;i&lt;=n;i++) &#123; int j=i+mid-1; if(j&gt;n)break; cx=cy=0; cx=dx[i-1]+(dx[n]-dx[j]); cy=dy[i-1]+(dy[n]-dy[j]); //printf("i=%d cx=%d cy=%d\n",i,cx,cy); if(mid&lt;abs(x-cx)+abs(y-cy))continue; if((mid-abs(x-cx)+abs(y-cy))%2==0)return true; &#125; return false;&#125;int main()&#123; scanf("%d",&amp;n); scanf("%s",op+1); for(int i=1;i&lt;=n;i++) &#123; dx[i]+=dx[i-1]; dy[i]+=dy[i-1]; if(op[i]=='R')dx[i]++; else if(op[i]=='L')dx[i]--; else if(op[i]=='U')dy[i]++; else if(op[i]=='D')dy[i]--; //printf("%d %d %d\n",i,dx[i],dy[i]); &#125; scanf("%d%d",&amp;x,&amp;y); if(dx[n]==x&amp;&amp;dy[n]==y) &#123; printf("0\n"); return 0; &#125; if(abs(x)+abs(y)&gt;n) &#123; printf("-1\n"); return 0; &#125; int l=1,r=n; int ans=1e9; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) &#123; ans=min(mid,ans); r=mid-1; &#125; else l=mid+1; &#125; printf("%d\n",ans==1e9?-1:ans); return 0;&#125; D. Berland Fair好像是给你一个圆形序列，然后你手中有t元钱，你从1位置开始一直走圆形序列，如果能买当前物品，你就去买，但是你只能买一件，当你最后什么都不能买的时候，就退出，问可以买多少件物品可以证明，假设你买的是序列{1,3,4,7},那么你下次一定也只能买{1，3，4，7}，那么根据贪心思想，我计算一下这个序列能被我买多少次，有点类似除法和取mod的思想D.cpp123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n;LL t;int a[200005];int main()&#123; scanf("%d%I64d",&amp;n,&amp;t); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); LL ans=0; while(1) &#123; LL cur=0; LL cnt=0; for(int i=1;i&lt;=n;i++) &#123; if(cur+a[i]&lt;=t) &#123; cnt++; cur+=a[i]; &#125; &#125; if(cur==0)break; ans+=cnt*(t/cur); t%=cur; &#125; printf("%I64d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC 沈阳站总结]]></title>
    <url>%2F2018%2F10%2F25%2FACM-ICPC-%E6%B2%88%E9%98%B3%E7%AB%99%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一开始就听说了沈阳站是Claris和tls和qls出题，本来去的时候就没报拿牌的希望，没想到热身赛居然打到rk61,这让我又燃起了希望，随即当晚又刷了4题。正式赛的时候，zcx很快的发现了一道全场签到题，然后把这个签到题丢给我，我一看是字符串，确定好细节，然后开始写，测了几组样例，放心的交上去，1Y。接下来陷入到长期的卡题中，刷新了一下榜，发现K有人过了，于是赶紧看K，好像是个约瑟夫环问题，但是我并不懂是怎么推的，而且数据范围也有点难搞，过了一会，发现很对队伍过了C，随即放弃手中的K，然后肛起来C，一开始看这个C，我总觉得有点DP的感觉，然后Claris也喜欢出DP，于是我开始怂恿队友往DP方向想，差点就成功坑了队友的一发，这时候lsb推出了一个公式，我不放心，让zcx用py打个表先，没想到这个打表还很难写，于是我们决定，就这么肛上去，我手推了几个，也没发现lsb有错，于是交了一发，1Y。这时候旁边两支金牌队伍都秒了G，看了一眼G，感觉有点像数据结构，但是结合了做这么多数据结构的经验，我觉得这题一定不是数据结构，一开始我提出了离线乱搞的想法，然后仔细阅读题目，好像是强制在线，GG，但是lsb说强制在线反而没有离线那么麻烦，我想了也是，于是开始想在线的做法，这时对友突然提了一下勾股数，我发现确实是整点坐标不共线，必然K是勾股数的平方，我提出了是不是这个范围勾股数不多，直接枚举所有的勾股数就行，于是我上去打了个表，发现勾股数很多，至少占1/2,这时候又陷入僵局，仔细思考了一下，我和lsb发现好像当K是完全平方数的时候，才能共线分解，当K是勾股数的平方的时候，可能会有多个分解，但这个分解量级在10这样，对查询和更新的贡献不大，于是lsb提出预处理所有的勾股数分解，然后查询和更新判断是不是勾股数，分类讨论暴力一下就好了，我觉得这个算法很正确，于是让lsb写了，结果没想到这题码量意外大，没想到因为我的决策失误，错失了一块银牌，这题最后都没找出来哪里WA了，当时这题确实我应该我写的，我意识到这个问题的时候已经是还剩45分钟的时候，这个数据结构没过的锅我背吧，这次比赛我还没尽到代码手责任，特别是这种数据结构题，应该还是我上机搞一搞的。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello,usename6]]></title>
    <url>%2F2018%2F10%2F24%2Fhello-usename6%2F</url>
    <content type="text"><![CDATA[hello usename6!]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
