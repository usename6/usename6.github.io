<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Educational Codeforces Round 53 (Rated for Div. 2)]]></title>
    <url>%2F2018%2F10%2F27%2FEducational-Codeforces-Round-53-Rated-for-Div-2%2F</url>
    <content type="text"><![CDATA[传送门：http://codeforces.com/contest/1073职业fst选手没有被fst，可喜可贺，成功的上了分A. Diverse Substring水题，直接枚举所有子串判断一下就行，实际上有个更好的做法，直接看相邻的两个字母是不是相同，不相同的话，就取那两个就行了，复杂度O(n)A.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;string s;int cnt[30];int main()&#123; int n; cin&gt;&gt;n; cin&gt;&gt;s; bool flag=false; for(int i=0;i&lt;n;i++) &#123; for(int j=1;i+j-1&lt;n;j++) &#123; string ss=s.substr(i,j); memset(cnt,0,sizeof(cnt)); for(int k=0;k&lt;ss.size();k++) &#123; int id=ss[k]-'a'; cnt[id]++; &#125; bool tag=true; for(int k=0;k&lt;26;k++) &#123; if(cnt[k]&gt;ss.size()/2) &#123; tag=false; break; &#125; &#125; if(tag) &#123; flag=true; cout&lt;&lt;"YES"&lt;&lt;endl; cout&lt;&lt;ss&lt;&lt;endl; &#125; if(flag)break; &#125; if(flag)break; &#125; if(!flag)cout&lt;&lt;"NO"&lt;&lt;endl; return 0;&#125; B. Vasya and Books没什么难度，按题目模拟就行B.cpp12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;int a[200005];int b[200005];bool used[200005];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]); int j=1; for(int i=1;i&lt;=n;i++) &#123; if(used[b[i]]) printf("%d%c",0,i==n?'\n':' '); else &#123; int cnt=0; for(;j&lt;=n;j++) &#123; cnt++; used[a[j]]=true; if(a[j]==b[i]) &#123; j++; break; &#125; &#125; //printf("%d %d\n",b[j],a[i]); //printf("j=%d cnt=%d\n",j,cnt); printf("%d%c",cnt,i==n?'\n':' '); &#125; &#125; return 0;&#125; C. Vasya and Robot题目意思就是给你长度为n移动序列，让你通过修改给定移动序列，使得你能从(0,0)到(x,y)，并求出所有修改中，最大的位置-最小位置+1的最小值刚开始看这题，感觉是双指针，不算很快速的敲完了双指针，后来发现双指针是个假算法，冷静分析了一下，发现区间具有单调性，而且，我只有固定好修改的区间在哪，直接看当前区间的长度和距离之间的关系，二分check一下就好了，最后三分钟绝杀这题C.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n;char op[200005];int x,y;int dx[200005],dy[200005];bool check(int mid)&#123; int cx=0,cy=0; //printf("mid=%d\n",mid); for(int i=1;i&lt;=n;i++) &#123; int j=i+mid-1; if(j&gt;n)break; cx=cy=0; cx=dx[i-1]+(dx[n]-dx[j]); cy=dy[i-1]+(dy[n]-dy[j]); //printf("i=%d cx=%d cy=%d\n",i,cx,cy); if(mid&lt;abs(x-cx)+abs(y-cy))continue; if((mid-abs(x-cx)+abs(y-cy))%2==0)return true; &#125; return false;&#125;int main()&#123; scanf("%d",&amp;n); scanf("%s",op+1); for(int i=1;i&lt;=n;i++) &#123; dx[i]+=dx[i-1]; dy[i]+=dy[i-1]; if(op[i]=='R')dx[i]++; else if(op[i]=='L')dx[i]--; else if(op[i]=='U')dy[i]++; else if(op[i]=='D')dy[i]--; //printf("%d %d %d\n",i,dx[i],dy[i]); &#125; scanf("%d%d",&amp;x,&amp;y); if(dx[n]==x&amp;&amp;dy[n]==y) &#123; printf("0\n"); return 0; &#125; if(abs(x)+abs(y)&gt;n) &#123; printf("-1\n"); return 0; &#125; int l=1,r=n; int ans=1e9; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) &#123; ans=min(mid,ans); r=mid-1; &#125; else l=mid+1; &#125; printf("%d\n",ans==1e9?-1:ans); return 0;&#125; D. Berland Fair好像是给你一个圆形序列，然后你手中有t元钱，你从1位置开始一直走圆形序列，如果能买当前物品，你就去买，但是你只能买一件，当你最后什么都不能买的时候，就退出，问可以买多少件物品可以证明，假设你买的是序列{1,3,4,7},那么你下次一定也只能买{1，3，4，7}，那么根据贪心思想，我计算一下这个序列能被我买多少次，有点类似除法和取mod的思想D.cpp123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n;LL t;int a[200005];int main()&#123; scanf("%d%I64d",&amp;n,&amp;t); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); LL ans=0; while(1) &#123; LL cur=0; LL cnt=0; for(int i=1;i&lt;=n;i++) &#123; if(cur+a[i]&lt;=t) &#123; cnt++; cur+=a[i]; &#125; &#125; if(cur==0)break; ans+=cnt*(t/cur); t%=cur; &#125; printf("%I64d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC 沈阳站总结]]></title>
    <url>%2F2018%2F10%2F25%2FACM-ICPC-%E6%B2%88%E9%98%B3%E7%AB%99%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一开始就听说了沈阳站是Claris和tls和qls出题，本来去的时候就没报拿牌的希望，没想到热身赛居然打到rk61,这让我又燃起了希望，随即当晚又刷了4题。正式赛的时候，zcx很快的发现了一道全场签到题，然后把这个签到题丢给我，我一看是字符串，确定好细节，然后开始写，测了几组样例，放心的交上去，1Y。接下来陷入到长期的卡题中，刷新了一下榜，发现K有人过了，于是赶紧看K，好像是给约瑟夫环问题，但是我并不懂是怎么推的，而且数据范围也有点难搞，过了一会，发现很对队伍过了C，随即放弃手中的K，然后肛起来C，一开始看这个C，我总觉得有点DP的感觉，然后Claris也喜欢出DP，于是我开始怂恿队友往DP方向想，差点就成功坑了队友的一发，这时候lsb推出了一个公式，我不放心，让zcx用py打个表先，没想到这个打表还很难写，于是我们决定，就这么肛上去，我手推了几个，也没发现lsb有错，于是交了一发，1Y。这时候旁边两支金牌队伍都秒了G，看了一眼G，感觉有点像数据结构，但是结合了做这么多数据结构的经验，我觉得这题一定不是数据结构，一开始我提出了离线乱搞的想法，然后仔细阅读题目，好像是强制在线，GG，但是lsb说强制在线反而没有离线那么麻烦，我想了也是，于是开始想在线的做法，这时对友突然提了一下勾股数，我发现确实是整点坐标不共线三点，必然K是勾股数的平方，我提出了是不是这个范围勾股数不多，直接枚举所有的勾股数就行，于是我上去打了个表，发现勾股数很多，至少占1/2,这时候又陷入僵局，仔细思考了一下，我和lsb发现好像当K是完全平方数的时候，才能共线分解，当K是勾股数的平方的时候，可能会有多个分解，但这个分解量级在10这样，对查询和更新的贡献不大，于是lsb提出预处理所有的勾股数分解，然后查询和更新判断是不是勾股数，分类讨论暴力一下就好了，我觉得这个算法很正确，于是让lsb写了，结果没想到这题码量意外大，没想到因为我的决策失误，错失了一块银牌，这题最后都没找出来哪里WA了，当时这题确实我应该我写的，我意识到这个问题的时候已经是还剩45分钟的时候，这个数据结构没过的锅我背吧，这次比赛我还没尽到代码手责任，特别是这种数据结构题，应该还是我上机搞一搞的。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello,usename6]]></title>
    <url>%2F2018%2F10%2F24%2Fhello-usename6%2F</url>
    <content type="text"><![CDATA[hello usename6!]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
