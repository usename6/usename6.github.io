<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[腾讯18春招机试]]></title>
    <url>%2F2020%2F03%2F21%2F%E8%85%BE%E8%AE%AF18%E6%98%A5%E6%8B%9B%E6%9C%BA%E8%AF%95%2F</url>
    <content type="text"><![CDATA[好久没有更blog，也好久没编程了，先做个简单慢慢学习。A题小Q定义了一种数列称为翻转数列:给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4…, 每隔m个符号翻转一次, 最初符号为’-‘;。例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.小Q现在希望你能帮他算算前n项和为多少。 题解：稍微有点技巧的数学题？这个题有个条件很关键就是n能被2m整除，如果n不能被2m整除，那这个题要考虑的case还蛮多的。考虑个最简单的模型：N是一个远大于2的偶数（本题中N一定是偶数），m=1很容易想到： \sum_{i=1}^N{i} - 2 * \sum_{j=1}^N/2{1+(j-1)*2}其实发现可以前面两个式子可以利用等差数列前N项和公式化简为： \frac{N * (N+1)}{2} - \frac{N * N}{2}将m推广至小于N的任意数后其实也不难，就相当于后面的减数变成m个等差数列之和，每个等差数列的公差为2m于是可以得到 \frac{N * (N+1)}{2} - (\frac{N * (M+1)}{2} + \frac{N * N}{2} - N * M)1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; LL ans = n*(n+1)/2 - ((n*(m+1))/2 + (n*n/2 - n*m)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; B题牛牛和羊羊正在玩一个纸牌游戏。这个游戏一共有n张纸牌, 第i张纸牌上写着数字ai。牛牛和羊羊轮流抽牌, 牛牛先抽, 每次抽牌他们可以从纸牌堆中任意选择一张抽出, 直到纸牌被抽完。他们的得分等于他们抽到的纸牌数字总和。现在假设牛牛和羊羊都采用最优策略, 请你计算出游戏结束后牛牛得分减去羊羊得分等于多少。 题解：水题1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;typedef long long LL;int n,a[MAXN];LL ans;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); sort(a+1,a+1+n); LL tmp=1; for(int i=n;i&gt;0;i--) &#123; ans = ans + a[i] * tmp; tmp = tmp * -1; &#125; printf("%lld\n",ans); return 0;&#125; C题小Q的父母要出差N天，走之前给小Q留下了M块巧克力。小Q决定每天吃的巧克力数量不少于前一天吃的一半，但是他又不想在父母回来之前的某一天没有巧克力吃，请问他第一天最多能吃多少块巧克力 题解：这个题，最直观的想法就是暴力，然后在找到第一个满足条件就break，可是这样容易超时。因为这个第一个可能会很大。于是我们仔细思考，发现这个题具有二分性质：即满足条件下的最大（小）解于是就可以二分，check直接暴力check即可，复杂度为O(mlogn)123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n,m;bool check(int tp)&#123; int ans=0; for(int i=1;i&lt;=m;i++) &#123; ans=ans+tp; if(ans&gt;n)return false; if(tp&amp;1)tp=tp/2+1; else tp=tp/2; &#125; return true;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); int l=1,r=n,mid,ans; while(l&lt;r) &#123; mid=(l+r)&gt;&gt;1; //printf("[%d %d]\n",l,r); //printf("mid=%d\n",mid); if(check(mid)) l=mid+1,ans=mid; else r=mid-1; &#125; if(l==r&amp;&amp;check(l))ans=l; printf("%d\n",ans); return 0;&#125; D题小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌组成一个总长度正好为K的歌单，每首歌最多只能在歌单中出现一次，在不考虑歌单内歌曲的先后顺序的情况下，请问有多少种组成歌单的方法。 题解：简单组合数学，暴力即可，因为这里数据很小，不需要费马求逆元，直接用杨辉三角形即可。1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define MAXN 105using namespace std;typedef long long LL;const LL mod=1e9+7;LL k;LL A,X,B,Y;LL C[MAXN][MAXN];void init()&#123; for(int i=1;i&lt;=100;i++)C[i][0]=C[i][i]=1; for(int i=1;i&lt;=100;i++) for(int j=1;j&lt;i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;&#125;int main()&#123; init(); scanf("%lld",&amp;k); scanf("%lld%lld%lld%lld",&amp;A,&amp;X,&amp;B,&amp;Y); LL sum=0,ans=0; for(int i=0;i&lt;=X;i++) &#123; if(sum&lt;=k) &#123; LL left=k-sum; //printf("left = %I64d\n",left); if(left%B==0&amp;&amp;(left/B)&lt;=Y)ans=(ans+C[X][i]*C[Y][left/B]%mod)%mod; &#125; else break; sum=sum+A; &#125; printf("%lld\n",ans); return 0;&#125; F题，据说是个错题，而且就算题目意思改过来，好像就变成了给定区域左下角(0,0)和右上角(x,y)的矩形，求在这个矩形中，离(x,y)最近的点。。。想了一个很难写的暴力。。。，先将所有的第一维坐标存入set中，树状数组维护每个一维坐标下的第二维坐标，然后先找到离x最近的x_{0},然后二分查找树状数组找到第二维坐标，同样对第二维做同样的操作（丢set，查BIT），比较最后得到两个结果，最后记得在两个树状数组删去对应的结果。对每个机器每次重复这样的操作即可。。。 不过按照原题做法，感觉不会做，有大佬说用2维KM求解二分图的带权匹配，没学过。。。，那天学习这种操作。 G题待更。。。]]></content>
      <categories>
        <category>机试</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #525 div2]]></title>
    <url>%2F2018%2F12%2F06%2FCodeforces-Round-525-div2%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/contest/1088codeforces 525 div2 题解 By usename6A. Ehab and another construction problemhttp://codeforces.com/contest/1088/problem/A题意：给你一个x，问你在[1,x]范围是否存在两个数a,b，使得$a*b&gt;x，且a/b]]></content>
      <categories>
        <category>ACM</category>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的裁剪算法&&曲线算法]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%9B%BE%E7%9A%84%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95%E5%92%8C%E6%9B%B2%E7%BA%BF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[裁剪算法，首先先状压下线段和边界的状态，然后根据斜截式暴力判断一下就好了，没什么难度，单纯模拟暴力，图形学马上就考试，毛线不懂怎么办啊，还没修界面，还没补青岛，还没搞数据库实验，数模还没看（队友会不会打我。。。）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include "graphics.h" // 引用所需要的图形库#include &lt;algorithm&gt;#define TOP 1#define BOTTOM 2#define RIGHT 4#define LEFT 8#define x first#define y secondusing namespace std;const int XL=100,XR=300,YB=100,YT=300;int encode(int x,int y)&#123; int code=0; if(y&lt;YB)code=code|BOTTOM; if(y&gt;YT)code=code|TOP; if(x&lt;XL)code=code|LEFT; if(x&gt;XR)code=code|RIGHT; return code;&#125;void DisplayLine(int x1, int y1, int x2, int y2, int color) //中点划线&#123; int x = x1, y = y1; int a = y1 - y2, b = x2 - x1; int cx = (b &gt;= 0 ? 1 : (b = -b, -1)); int cy = (a &lt;= 0 ? 1 : (a = -a, -1)); putpixel(x, y, color); int d, d1, d2; if (-a &lt;= b) // 斜率绝对值 &lt;= 1 &#123; d = 2 * a + b; d1 = 2 * a; d2 = 2 * (a + b); while(x != x2) &#123; if (d &lt; 0) y += cy, d += d2; else d += d1; x += cx; putpixel(x, y, color); &#125; &#125; else // 斜率绝对值 &gt; 1 &#123; d = 2 * b + a; d1 = 2 * b; d2 = 2 * (a + b); while(y != y2) &#123; if(d &lt; 0) d += d1; else x += cx, d += d2; y += cy; putpixel(x, y, color); &#125; &#125;&#125;pair&lt;int,int&gt; solve(int x1,int y1,int x2,int y2)&#123; //circle(300,200,100); int x=x1,y=y1; int code=encode(x,y); while(code) &#123; if(code&amp;TOP) &#123; y=YT; x=(x1-x2)*(y-y1)/(y1-y2)+x1; &#125; if(code&amp;BOTTOM) &#123; y=YB; x=(x1-x2)*(y-y1)/(y1-y2)+x1; &#125; if(code&amp;LEFT) &#123; x=XL; y=(y1-y2)*(x-x1)/(x1-x2)+y1; &#125; if(code&amp;RIGHT) &#123; x=XR; y=(y1-y2)*(x-x1)/(x1-x2)+y1; &#125; code=encode(x,y); &#125; //circle(300,200,50); return pair&lt;int,int&gt;(x,y);&#125;void cur_line(int x1,int y1,int x2,int y2)&#123; pair&lt;int,int&gt; s=solve(x1,y1,x2,y2); pair&lt;int,int&gt; e=solve(x2,y2,x1,y1); DisplayLine(s.x,s.y,e.x,e.y,GREEN);&#125;int main()&#123; initgraph(600, 600); //初始化，显示一个窗口，这里和BGI略有区别 setcaption("裁剪算法"); //设置窗口标题。 DisplayLine(100,100,100,300,RED); DisplayLine(100,300,300,300,RED); DisplayLine(300,100,300,300,RED); DisplayLine(100,100,300,100,RED); DisplayLine(0,0,500,500,BLUE); cur_line(0,0,500,500); getch(); //暂停一下等待用户按键 closegraph(); //关闭图形界面 return 0;&#125;]]></content>
      <categories>
        <category>图形学，裁剪算法</category>
        <category>曲线</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>裁剪算法</tag>
        <tag>曲线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形的填充算法]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%9B%BE%E5%BD%A2%E7%9A%84%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[填充算法一共有三种：一种是扫描线算法，扫描线算法挺简单的，如果取y轴平行线做扫描线，把交点的x坐标丢进y扫描线就行，用几个vector维护，然后有几个条件：扫描在当前点之前到奇数个点，那就不在凸包里面，如果有偶数个点，则反之，然后这其中如果有交点是顶点则分类讨论，如果多边形上连接该点的两条边在扫描线同侧，则加2，否则加1，然后还是应用之前的条件看是否在凸包内部即可边填充就是取反，从交点开始扫，然后每次对右边取反就完事种子填充更简单，就看有没有打到边界，dfs就行，只要图形不是很大，都不会爆栈吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include "graphics.h" // 引用所需要的图形库#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int used[505][505];int mark[505][505];bool vis[505][505];struct Point&#123; int x,y; Point()&#123;&#125; Point(int a,int b):x(a),y(b)&#123;&#125; bool operator &lt;(const Point &amp;tp) &#123; if(x==tp.x)return y&lt;tp.y; return x&lt;tp.x; &#125;&#125;;vector&lt;Point&gt; G;vector&lt;int&gt; Line[505];vector&lt;Point&gt; st[100005];int dx[4]=&#123;0,0,-1,1&#125;;int dy[4]=&#123;-1,1,0,0&#125;;inline int get_id(int x,int y)&#123; return x*501+y;&#125;void BreLine(int x1,int y1,int x2,int y2)&#123; int x,y; int dx,dy; int s1,s2; //标志点,记录x1与x2、y1与y2的位置关系 int e; int t; int tag; //记录斜率情况 int i; x=x1; y=y1; dx=abs(x1-x2); dy=abs(y1-y2); if(x2&gt;x1) s1=1; else s1=-1; if(y2&gt;y1) s2=1; else s2=-1; if(dy&gt;dx) &#123; t=dx; dx=dy; dy=t; tag=1; &#125; else tag=0; e=2*dy-dx; for(i=1;i&lt;=dx;i++) &#123; putpixel(x,y,RED); used[x][y]=1; Line[y].push_back(x); G.push_back(Point(x,y)); if(e&gt;=0) &#123; if(tag==0) y=y+s2; else x=x+s1; e=e-2*dx; &#125; if(tag==0) x=x+s1; else y=y+s2; e=e+2*dy; &#125; return;&#125;void Line_paint() //边填充算法&#123; memset(mark,-1,sizeof(mark)); sort(G.begin(),G.end()); for(int i=0;i&lt;(int)G.size();i++) &#123; Point tp=G[i]; int y=tp.y; if(used[tp.x][tp.y]==2)continue; for(int x=tp.x;x&lt;=500;x++) &#123; if(mark[x][y]==-1)mark[x][y]=1; else mark[x][y]=!mark[x][y]; &#125; &#125; for(int x=0;x&lt;=500;x++) for(int y=0;y&lt;=500;y++) if(mark[x][y]==1)putpixel(x,y,RED);&#125;bool ck(int x,int y)&#123; vector&lt;int&gt;::iterator itt=lower_bound(Line[y].begin(),Line[y].end(),x); if(Line[y].size()==0)return false; if(itt==Line[y].begin()&amp;&amp;(*itt)&gt;x)return false; int cnt=0; int d=100; for(vector&lt;int&gt;::iterator it=Line[y].begin();it!=Line[y].end();it++) &#123; int xx=(*it); if(xx&gt;x) break; int yy=y; if(used[xx][yy]==2) &#123; int id=get_id(xx,yy); if(st[id][0].y&lt;=yy&amp;&amp;st[id][1].y&lt;=yy) cnt+=2; else if(st[id][0].y&gt;=yy&amp;&amp;st[id][1].y&gt;=yy) cnt+=2; else cnt++; &#125; else cnt++; &#125; return (cnt&amp;1);&#125;void dfs(int x,int y)&#123; for(int i=0;i&lt;4;i++) &#123; int xx=x+dx[i]; int yy=y+dy[i]; if(used[xx][yy]==1||used[xx][yy]==2) &#123; putpixel(x,y,GREEN); continue; &#125; if(vis[xx][yy])continue; putpixel(x,y,GREEN); vis[xx][yy]=true; dfs(xx,yy); &#125;&#125;void gram()&#123; for(int i=0;i&lt;=500;i++) &#123; for(int j=0;j&lt;=500;j++) &#123; if(used[i][j]) &#123; putpixel(i,j,GREEN); continue; &#125; if(ck(i,j)) putpixel(i,j,GREEN); &#125; &#125;&#125;int main()&#123; initgraph(500, 500); //初始化，显示一个窗口，这里和BGI略有区别 memset(used,0,sizeof(used)); for(int i=0;i&lt;=500;i++)Line[i].clear(); setcaption("填充算法"); //设置窗口标题。 BreLine(0,0,100,400); BreLine(100,400,200,0); BreLine(100,100,200,0); BreLine(0,0,100,100); //printf("yes\n"); for(int i=0;i&lt;=500;i++) &#123; if(Line[i].size()==0)continue; sort(Line[i].begin(),Line[i].end()); &#125; st[get_id(0,0)].push_back(Point(100,400)); st[get_id(0,0)].push_back(Point(100,100)); st[get_id(100,400)].push_back(Point(0,0)); st[get_id(100,400)].push_back(Point(200,0)); st[get_id(200,0)].push_back(Point(100,400)); st[get_id(200,0)].push_back(Point(100,100)); st[get_id(100,100)].push_back(Point(0,0)); st[get_id(100,100)].push_back(Point(200,0)); //printf("yes\n"); used[0][0]=used[100][400]=used[100][100]=used[200][0]=2; //Line_paint(); //dfs(100,200); gram(); getch(); //暂停一下等待用户按键 closegraph(); //关闭图形界面 return 0;&#125;]]></content>
      <categories>
        <category>图形学，填充算法</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>填充算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAIPC-C.Greeting]]></title>
    <url>%2F2018%2F11%2F06%2FNAIPC-C-Greeting%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/gym/101002国庆做的NAIPC，usename6来补题题目意思很简单，就是你给你N种信件，宽度为w，高度为h,数量为q，你可以自定义k种信封，让你求怎么制定信封，浪费的面积最小，信件不能旋转，不然可能还需要处理一下数据范围很小，很容易往折半或者是状压，但是我觉得折半的话，得32这样吧，不然失去意义了，所以往状压DP想，若定义dp[i][s]表示i种信封可以覆盖状态为s的最小信件，预处理信件集合s的最小花费c[s],很明显我先去枚举s，再在s中枚举j，判断s需不需要拆分转移方程为 $dp[i][s] = min(dp[i-1][s-j]+cost[j],dp[i][s])$ 其中j是s的子集，这样就做完了这题有一个个坑点，结果会爆int,于是答案的上界应该处理为1e16左右这题复杂度$O(3^n)$，还没证明出来。。。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define MAXN (1&lt;&lt;15)+100using namespace std;typedef long long LL;const LL INF=1e16;LL dp[16][MAXN],c[MAXN];LL w[16],h[16],q[16];int n,k;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf("%lld%lld%lld",&amp;w[i],&amp;h[i],&amp;q[i]); for(int s=1;s&lt;(1&lt;&lt;n);s++) &#123; LL mxw,mxh,need; int cnt=0; need=mxw=mxh=0LL; for(int i=0;i&lt;n;i++) &#123; if(s&gt;&gt;i&amp;1) &#123; cnt+=q[i]; mxw=max(mxw,w[i]); mxh=max(mxh,h[i]); need+=w[i]*h[i]*q[i]; &#125; &#125; c[s]=mxw*mxh*cnt-need; &#125; for(int i=0;i&lt;=k;i++) for(int j=0;j&lt;(1&lt;&lt;n);j++) dp[i][j]=INF; dp[0][0]=0; //初始化边界条件 for(int i=1;i&lt;=k;i++) //枚举能用多少个 for(int s=0;s&lt;(1&lt;&lt;n);s++) for(int j=s;j;j=(j-1)&amp;s) if(dp[i-1][s-j]&lt;INF)dp[i][s]=min(dp[i][s],dp[i-1][s-j]+c[j]); LL ans=INF; for(int i=0;i&lt;=k;i++)ans=min(ans,dp[i][(1&lt;&lt;n)-1]); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red Black Tree]]></title>
    <url>%2F2018%2F11%2F06%2FRed-Black-Tree%2F</url>
    <content type="text"><![CDATA[ZOJ 4048题目意思是给你一颗树，有n个节点，有m个红节点，当然根也是给红节点，给出q次查询，每次查询k个节点，你可以修改树上的一个黑节点为红色，求出所有修改中距离红节点的最大值的最小最大值最小，一看就是二分，这题如果不带脑袋一想，应该就是求K个点的LCA，然后暴力二分check就行，check的方法很简单吧，就对于当前答案mid，找到所有大于mid，对这些节点求LCA，这样相当于是贪心吧，因为这些点距离最大值要最小，只能尽可能走LCA，于是就很简单了，如果这些点没有LCA，那肯定不行，如果有LCA，那就查看最大值是否小于mid就OK了。据说倍增过不了，还没试，第二次写RMQ+LCA，卡的不行，没想到时间戳是两倍的空间，这个注意到了，然后上网查了一下题解，发现大家都很去掉一个log，于是去学习了下RMQ去掉log的姿势，然后做了排序剪枝二分check，当然是拉出来剪枝的，加了读入优化，硬是优化过去了，昨晚上一直卡，后来发现数组越界，然后发现答案会爆int，刷爆了ZOJ的测评，不知道是不是被ZJU给注意到了，早上起来改了改mid，然后交了一发，2010ms过吧，才发现ZOJ加时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;#define MAXN 100015#define MAXM 200030using namespace std;typedef long long LL;struct Edge&#123;int v,w,next;&#125;;Edge e[MAXM];int head[MAXN],tot;int first[MAXN*2],R[2*MAXN],p[MAXN*2],cnt,dep[MAXN];int node[MAXN],k,st[MAXN];bool isred[MAXN];int dp[MAXN*2][20];int mm[MAXN*2];LL dis[MAXN],cost[MAXN];int n,m,q;bool cmp(int a,int b)&#123; return cost[a]&gt;cost[b];&#125;int read()&#123; char c=getchar(); while (c&gt;'9'||c&lt;'0') c=getchar(); int x=0; while ('0'&lt;=c &amp;&amp; c&lt;='9')&#123; x=x*10+c-'0'; c=getchar(); &#125; return x;&#125;void add(int u,int v,int w)&#123; e[tot].v=v; e[tot].w=w; e[tot].next=head[u]; head[u]=tot++;&#125;void dfs(int u,int depth,int red,int pre)&#123; first[u]=++cnt;p[cnt]=u;R[cnt]=depth; dep[u]=depth; cost[u]=dis[u]-dis[red]; //每个节点到红色节点的距离 for(int i=head[u];i!=-1;i=e[i].next) &#123; int v=e[i].v; if(v!=pre) &#123; dis[v]=dis[u]+(LL)e[i].w; if(isred[v])dfs(v,depth+1,v,u); //下传最近的红色点 else dfs(v,depth+1,red,u); p[++cnt]=u; R[cnt]=depth; &#125; &#125;&#125;void ST(int n)&#123; mm[0]=-1; for(int i=1;i&lt;=n;i++) mm[i] = ((i&amp;(i-1)) == 0) ? mm[i-1]+1 : mm[i-1]; for(int i=1;i&lt;=n;i++)dp[i][0]=i; for(int j=1;j&lt;=mm[n];j++) &#123; for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) &#123; int a=dp[i][j-1],b=dp[i+(1&lt;&lt;(j-1))][j-1]; dp[i][j]=R[a]&lt;R[b]?a:b; &#125; &#125;&#125;int RMQ(int l,int r)&#123; int k=mm[r-l+1]; int a=dp[l][k],b=dp[r-(1&lt;&lt;k)+1][k]; return R[a]&lt;R[b]?a:b;&#125;int LCA(int u,int v)&#123; int x=first[u],y=first[v]; if(x&gt;y)swap(x,y); int res=RMQ(x,y); return p[res];&#125;bool ck(LL mid)&#123; int top=0; //top的值 for(int i=1;i&lt;=k;i++) &#123; if(cost[node[i]]&gt;mid) st[++top]=node[i]; &#125; if(top&lt;=1)return true; //小于或等于1个点改这个点即可 int lca=st[1]; for(int i=2;i&lt;=top;i++) lca=LCA(lca,st[i]); for(int i=1;i&lt;=top;i++) if(dep[lca]&gt;dep[st[i]])return false; //不存在LCA for(int i=1;i&lt;=top;i++) if(dis[st[i]]-dis[lca]&gt;mid)return false; //大于答案的值 return true;&#125;int main()&#123; int t; t=read(); while(t--) &#123; n=read();m=read();q=read(); memset(isred,false,sizeof(isred)); cnt=tot=0; memset(head,-1,sizeof(head)); for(int i=1;i&lt;=m;i++) &#123; int id; id=read(); isred[id]=true; &#125; for(int i=1;i&lt;n;i++) &#123; int u,v,w; u=read();v=read();w=read(); add(u,v,w); add(v,u,w); &#125; dis[1]=0; dfs(1,1,1,1); ST(2*n-1); //dfs序是二倍 while(q--) &#123; k=read(); LL mx=0; for(int i=1;i&lt;=k;i++) node[i]=read(); sort(node+1,node+1+k,cmp); mx=cost[node[1]]; LL l=0,r=mx; LL ans; while(l&lt;=r) &#123; LL mid=(l+r)&gt;&gt;1; if(ck(mid)) &#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>LCA</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>LCA</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maze Designer]]></title>
    <url>%2F2018%2F11%2F04%2FMaze-Designer%2F</url>
    <content type="text"><![CDATA[题目地址:https://nanti.jisuanke.com/t/31462题目给你nxm的方阵图，用最小花费建墙，相当于是迷宫，且每个方格互相可达，并且最短路径唯一，相当于是nxm的生成树，给出q次查询，求出任意这两个点的最短距离首先去建一个最大生成树，因为生成树任意两个点均可达，最大是因为要让其花费最小，把所有花费大的墙拆掉，这样就留下一个唯一的路径，而且花费最小，且任意两点可达123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;#define MAXN 250010#define MAXM 500020using namespace std;typedef long long LL;int n,m;struct Edge&#123; int u,v,next,w; bool operator &lt;(const Edge &amp;tp) &#123; return w&gt;tp.w; &#125;&#125;;struct LCA&#123; Edge e[MAXM]; int fa[MAXN][25]; int head[MAXN]; int dep[MAXN]; int dis[MAXN]; int tot; int height; void init() &#123; memset(head,-1,sizeof(head)); tot=0; height=20; &#125; void add(int u,int v,int w) &#123; e[tot].v=v; e[tot].w=w; e[tot].next=head[u]; head[u]=tot++; &#125; void dfs(int u) &#123; for(int i=1;i&lt;=height;i++) &#123; if(fa[u][i-1]!=-1)fa[u][i]=fa[fa[u][i-1]][i-1]; else break; &#125; for(int i=head[u];i!=-1;i=e[i].next) &#123; int v=e[i].v; if(fa[u][0]!=v) &#123; dis[v]=dis[u]+e[i].w; dep[v]=dep[u]+1; fa[v][0]=u; dfs(v); &#125; &#125; &#125; int lca(int u,int v) &#123; if(dep[u]&lt;dep[v])swap(u,v); int d=dep[u]-dep[v]; for(int i=0;i&lt;=height;i++) &#123; if((1&lt;&lt;i)&amp;d) u=fa[u][i]; &#125; if(u==v)return u; for(int h=height;h&gt;=0;h--) &#123; if(fa[u][h]!=fa[v][h]) &#123; u=fa[u][h]; v=fa[v][h]; &#125; &#125; return fa[u][0]; &#125; int query(int u,int v) &#123; return dis[u]+dis[v]-2*dis[lca(u,v)]; &#125;&#125;;LCA L;struct Krusal&#123; Edge e[MAXM]; int f[MAXN]; int tot; //多少条边 int N; void init() &#123; tot=0; for(int i=1;i&lt;=N;i++)f[i]=i; &#125; void add(int u,int v,int w) &#123; e[tot].u=u; //记录起点 e[tot].v=v; e[tot].w=w; tot++; &#125; int fid(int u)&#123;return f[u]==u?u:f[u]=fid(f[u]);&#125; //并查集 void krusal() &#123; sort(e,e+tot); int cnt=0; for(int i=0;i&lt;tot;i++) &#123; int f1=fid(e[i].u); int f2=fid(e[i].v); if(f1!=f2) &#123; f[f1]=f2; //记录最大生成树的边 L.add(e[i].u,e[i].v,1); L.add(e[i].v,e[i].u,1); cnt++; &#125; if(cnt&gt;=N-1)return; &#125; &#125;&#125;;Krusal K;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; K.N=n*m; K.init(); L.init(); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; char s1[10],s2[10]; int w1,w2; scanf("%s%d%s%d",s1,&amp;w1,s2,&amp;w2); if(s1[0]=='D') K.add((i-1)*m+j,i*m+j,w1); if(s2[0]=='R') K.add((i-1)*m+j,(i-1)*m+j+1,w2); &#125; &#125; K.krusal(); int q; scanf("%d",&amp;q); L.dfs(1); for(int i=1;i&lt;=q;i++) &#123; int x1,y1,x2,y2; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); int u=(x1-1)*m+y1; int v=(x2-1)*m+y2; printf("%d\n",L.query(u,v)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bresenham算法]]></title>
    <url>%2F2018%2F10%2F29%2FBresenham%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Bresenham算法是第三种基于扫描线的算法，第一种是DDA算法，非常简单，直接强制转化y（四舍五入）然后绘点，而中点画线法，通过将函数隐式化，通过不等式关系，查看点与直线的关系，选择最近的像素点那么Bresenham算法又是怎么做的呢？假设$dx = x2 - x1 $, $dy = y2 - y1$,那么直线方程可以表示为$(\frac{dy}{dx})x + b = y$取$k = \frac{dy}{dx}$若假设点$p{i}$坐标为$(x{i},y_{i})$,则分类对直线斜率进行分类讨论k &gt; 0 时，若直线是按坐标序枚举，很容易发现相邻两个坐标之间的增量是正值若$|dx| &gt; |dy|$剩下的过程其实和中点画线差不多，详细过程改日再补123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;GL/glut.h&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;void Bresenham(int x1,int y1,int x2,int y2)&#123; int x,y,dx,dy,d,d1,d2,inc; dx=x2-x1; dy=y2-y1; if(dx*dy&gt;=0)inc=1; else inc=-1; if(abs(dx)&gt;abs(dy)) &#123; if(dx&lt;0) &#123; std::swap(x1,x2); std::swap(y1,y2); dx=-dx;dy=-dy; &#125; d=2*dy-dx; d1=2*dy; d2=2*(dy-dx); x=x1; y=y1; while(x&lt;x2) &#123; glPointSize(5.0); glBegin(GL_POINTS); glVertex2i(x,y); glEnd(); x++; if(d&lt;0)d+=d1; else &#123; y+=inc; d+=d2; &#125; &#125; &#125; else &#123; if(dy&lt;0) &#123; std::swap(x1,x2); std::swap(y1,y2); dx=-dx;dy=-dy; &#125; d=2*dy-dx; d1=2*dy; d2=2*(dy-dx); x=x1; y=y1; while(y&lt;y2) &#123; glPointSize(5.0); glBegin(GL_POINTS); glVertex2i(x,y); glEnd(); y++; if(d&lt;0)d+=d1; else &#123; x+=inc; d+=d2; &#125; &#125; &#125;&#125;void display()&#123; glClearColor(1.0, 1.0, 1.0, 1.0); glClear(GL_COLOR_BUFFER_BIT); glViewport(0,0,500,500); Bresenham(0,0,500,100); Bresenham(0,0,500,200); Bresenham(0,0,500,300); Bresenham(0,0,500,400); Bresenham(0,500,500,0); //printf("over\n"); glFlush();&#125;int main(int argc,char **argv)&#123; glutInit(&amp;argc,argv); glutInitDisplayMode(GLUT_SINGLE|GLUT_RED); glutInitWindowSize(500,500); glutInitWindowPosition(0,0); glutCreateWindow("MPLine"); glutDisplayFunc(display); //调用里面函数的绘图函数（当然是你定义） glColor3f(0.0, 0.0, 0.0); gluOrtho2D(0.0, 500.0, 0.0, 500.0); glutMainLoop(); return 0;&#125;]]></content>
      <categories>
        <category>图形学</category>
        <category>Open GL</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Open GL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP优化专题二]]></title>
    <url>%2F2018%2F10%2F29%2FDP%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[垃圾usename6又来更新DP专题了。。。今天要讲的是DP的第二个专题优化，倍增优化，之前在专题一中，我们已经说过了，DP优化无非从时间，即DP转移入手，或是从空间入手。下面我来看一道这样题目（来源HDU 2157）给定一个有向图，问从A点恰好走k步（允许重复经过边）到达B点的方案数mod p的值乍一看是图论，实际上可以从DP角度去考虑这个题，定义状态dp[u][k]表示走k步走到u这个节点的方案数是多少，很明显根据图的性质和加法原理，转移为dp[v][k]+=dp[u][k-1] （存在u—-&gt; v的 有向边）但是若这个k很大的时候，难免就要进行很大计算，我们发现不管走多少步，只要你从k节点出发，转移是固定的，转移的方程也是固定的（！这个很重要）于是，我们可以采用倍增去加速一阶线性递推式，即矩阵快速幂去倍增优化转移两个状态到两个状态之间转移应该是邻接矩阵，于是对邻接矩阵进行快速幂优化转移即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define maxn 200using namespace std;typedef struct&#123; int a[maxn][maxn];&#125;Martix;const int mod=1000;Martix unit;int n,m;Martix operator*(Martix a,Martix b)&#123; Martix res; memset(res.a,0,sizeof(res.a)); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; for(int k=0;k&lt;n;k++) &#123; res.a[i][j]=(res.a[i][j]+a.a[i][k]*b.a[k][j])%mod; &#125; &#125; &#125; return res;&#125;void init()&#123; memset(unit.a,0,sizeof(unit.a)); for(int i=0;i&lt;n;i++) unit.a[i][i]=1;&#125;Martix qpow_mod(Martix a,int n)&#123; Martix res=unit; while(n) &#123; if(n&amp;1) res=res*a; n&gt;&gt;=1; a=a*a; &#125; return res;&#125;int main()&#123; int s,e,k,cnt,t,A,B; Martix res,tmp; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; if(!n&amp;&amp;!m)break; memset(tmp.a,0,sizeof(tmp.a)); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;s,&amp;e); tmp.a[s][e]=1; //printf("%d %d\n",s,e); &#125; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d%d",&amp;A,&amp;B,&amp;k); init(); res=qpow_mod(tmp,k); cnt=res.a[A][B]; printf("%d\n",cnt); &#125; &#125; return 0;&#125; 一开始我一直错误的认为矩阵的倍增优化转移只能在一阶线性递推式解决，知道发现了这道题：有n天，m件衣服，如果某一天穿了第i件衣服，第二天穿了第j件衣服，那么就会获得f[i][j]的权值。然后给你矩阵f，每件衣服可以穿无限多次，问第n天能获得的最大权值是多少。同样的我们发现，若是定义状态dp[u][k]表示第k天穿了u这件服装，那么转移式子只需把上面的式子进行小小的改动：dp[v][k] = max(dp[u][k-1] + f[u][v]) (u—-&gt;v相连)同样的不管k是多少，对于每个节点的u的转移是不变的，每次都会用到这个矩阵去转移，于是我们采用了模仿矩阵快速幂的方向，做倍增优化，其实是取max和+运算的结合律导致的，这个不做证明，需要用到离散数学的群论和代数系统的知识，有兴趣自行证明，于是导致我们可以先算后面在和前面合并1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define MAXN 105using namespace std;typedef long long LL;typedef struct&#123; LL a[MAXN][MAXN];&#125;Martix;Martix unit;int n,m;Martix operator*(Martix a,Martix b)&#123; Martix ans; memset(ans.a,0,sizeof(ans.a)); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; for(int k=1;k&lt;=n;k++) &#123; ans.a[i][j]=max(ans.a[i][j],a.a[i][k]+b.a[k][j]); &#125; &#125; &#125; return ans;&#125;void init()&#123; memset(unit.a,0,sizeof(unit.a)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) unit.a[i][i]=1;&#125;Martix qpow_mod(Martix a,LL n)&#123; Martix res; memset(res.a,0,sizeof(res.a)); while(n) &#123; if(n&amp;1)res=res*a; n&gt;&gt;=1; a=a*a; &#125; return res;&#125;Martix tmp,ret;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n)!=EOF) &#123; init(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%lld",&amp;tmp.a[i][j]); ret=qpow_mod(tmp,(LL)m-1);// for(int i=1;i&lt;=n;i++)// &#123;// for(int j=1;j&lt;=n;j++)// &#123;// printf("%lld ",ret.a[i][j]);// &#125;// puts("");// &#125; LL ans=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) ans=max(ans,ret.a[i][j]); printf("%lld\n",ans); &#125; return 0;&#125; 上述两个都是类似分层图的DP，因此没有后效性，可以自己思考一下，状态有二维，尽管图上有环也不会导致后效性]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP优化专题一]]></title>
    <url>%2F2018%2F10%2F28%2FDP%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[DP优化专题虽然不是DP的选手，但是可见DP的重要性，DP这个东西高深的很，打算写一写关于DP的事情，usename6 DP 水平有限？dalao求轻喷DP优化一 枚举优化曾经在一次暑假集训的讲课中，选择了讲DP，本来就不是很懂DP这个东西，于是随便选了几个题讲讲，没想到就讲出了DP的其中一个优化，枚举优化，若不是雨神说，我可能都不知道这是什么。。。枚举优化是什么？DP的优化有两种方向，第一种是选择优化时间，第二种是优化空间，如果从时间的角度去考虑优化，那么就要从转移上考虑，如何优化转移，是优化时间重要的思想首先思考这样一个问题：给一个nxm的矩阵，要求你求出一个子矩阵，使得这个矩阵的和最大这个题的传统做法就是枚举起点(x1,y1)、终点(x2,y2)，然后套两重循环，复杂度O($n^6$)一个优化就是加上二维前缀和，这样省去了两个循环，复杂度O($n^4$)固定行的上下界，然后将一列压成一个元素，这题就变成了最大子段和的问题，DP即可O($n^3$)1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define maxn 600using namespace std;typedef long long LL;int n,m;LL sum[maxn][maxn],a[maxn],dp[maxn];int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int x; scanf("%d",&amp;x); sum[i][j]=sum[i-1][j]+x; &#125; &#125; LL mx=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=n;j++) &#123; dp[0]=0; for(int k=1;k&lt;=m;k++) &#123; a[k]=sum[j][k]-sum[i-1][k]; dp[k]=max(a[k],dp[k-1]+a[k]); mx=max(mx,dp[k]); &#125; &#125; &#125; printf("%lld\n",mx); return 0;&#125;但是这个题还有一种优化，就是可以枚举优化掉这个东西转移假设你换一种角度去思考这道题我都把矩阵的上下界固定了，左右的界能不能固定，对应每个矩阵右端列，我能不能快速找到左端列，使得以该右端列结尾的最大连续子矩阵和单调队列去优化转移，每次存该列的前缀子矩阵和（类似扫描线推进），然后在1~当前枚举右端列i-1中从单调队列快速提出来12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define maxn 600using namespace std;typedef long long LL;int n,m;LL sum[maxn][maxn],q[maxn];int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int x; scanf("%d",&amp;x); sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+x; &#125; &#125; LL mx=0; int qs,qe; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=n;j++) &#123; qs=0;qe=1; q[0]=0; //printf("%d %d\n",i,j); for(int k=1;k&lt;=m;k++) &#123; //printf("k = %d\n",k); LL data=sum[j][k]-sum[i-1][k]; //printf("data = %I64d\n",data); if(qs&lt;qe)mx=max(mx,data-q[qs]); while(qs&lt;qe) &#123; if(data&gt;=q[qe-1])break; qe--; &#125; q[qe]=data; qe++; &#125; &#125; &#125; printf("%lld\n",mx); return 0;&#125;由于是前缀，于是可以做枚举优化？由于每次转移需要都是1~i-1的前缀子矩阵和，于是只需要开个数mx维护1~i-1的最小值即可1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define maxn 600#define INF 0x3f3f3f3fusing namespace std;typedef long long LL;int n,m;LL sum[maxn][maxn],q[maxn];int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int x; scanf("%d",&amp;x); sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+x; &#125; &#125; LL mx=0,mm; int qs,qe; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=n;j++) &#123; mm=0; for(int k=1;k&lt;=m;k++) &#123; LL data=sum[j][k]-sum[i-1][k]; if(k!=1)mx=max(mx,data-mm); if(k==1)mx=max(mx,data); mm=min(mm,data); &#125; &#125; &#125; printf("%lld\n",mx); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wannafly挑战赛27]]></title>
    <url>%2F2018%2F10%2F28%2FWannafly%E6%8C%91%E6%88%98%E8%B5%9B27%2F</url>
    <content type="text"><![CDATA[https://www.nowcoder.com/acm/contest/215#questionA.灰魔法师给出长度为n的序列a, 求有多少对数对 (i, j) (1 &lt;= i &lt; j &lt;= n) 满足 $a{i} + a{j}$ 为完全平方数。因为这玩意$n&lt;=100000$，于是我去暴力打了一个表，发现这个完全平方数不是很多，直接二分check就行了，跟沈阳的G比起来差远了1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;vector&lt;int&gt; v;int n;int a[200005];int cnt[200005];int main()&#123; for(int i=1;i&lt;=200000;i++) &#123; int tp=sqrt(i); if(tp*tp==i) v.push_back(i); &#125; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); cnt[a[i]]++; &#125; LL ans=0; for(int i=1;i&lt;=n;i++) &#123; int id=upper_bound(v.begin(),v.end(),a[i])-v.begin(); //printf("yes\n"); for(int j=id;j&lt;(int)v.size();j++) &#123; ans+=cnt[v[j]-a[i]]; if(v[j]==2*a[i])ans--; &#125; &#125; printf("%lld\n",ans/2); return 0;&#125; B.紫魔法师给出一棵仙人掌(每条边最多被包含于一个环，无自环，无重边，保证连通)，要求用最少的颜色对其顶点染色，满足每条边两个端点的颜色不同，输出最小颜色数即可签到题二，这个题，很明显发现答案的取值范围在1，2，3之间，为什么呢，因为题目保证每条边最多被包含一个环，也就是这个图好吧，就是类似联通快一个东西，可以证明奇数环下，至少需要3个颜色，其余偶环和长度为2的颜色只需要2个颜色，然后特殊考虑其中一个边界，那就是都是单点的时候，这个时候一个颜色就行，偶环就用二分图染色法搞一搞。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;vector&lt;int&gt; G[MAXN];int n,m;int color[MAXN];bool BFS(int s)&#123; queue&lt;int&gt; q; //printf("s=%d\n",s); color[s]=1; q.push(s); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0;i&lt;(int)G[u].size();i++) &#123; int v=G[u][i]; if(color[v]!=-1&amp;&amp;color[v]==color[u])return true; if(color[v]==-1)q.push(v); color[v]=color[u]^1; &#125; &#125; return false;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); if(!m) &#123; printf("1\n"); return 0; &#125; for(int i=1;i&lt;=m;i++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; memset(color,-1,sizeof(color)); bool flag=false; for(int i=1;i&lt;=n;i++) &#123; if(color[i]==-1) &#123; if(BFS(i)) &#123; flag=true; break; &#125; &#125; &#125; flag?puts("3"):puts("2"); return 0;&#125; C.蓝魔法师 “你，你认错人了。我真的，真的不是食人魔。”—蓝魔法师 给出一棵树，求有多少种删边方案，使得删后的图每个连通块大小小于等于k，两种方案不同当且仅当存在一条边在一个方案中被删除，而在另一个方案中未被删除，答案对998244353取模考试的时候，想出是树形dp，怎么合并啊，想了一个小时，想不出来，遂弃疗，好吧其实是再不复习图形学就GG了。dp[u][num]表示根节点为u的子树下大小为num节点合并的方案数首先去枚举儿子节点，然后去枚举每个儿子中的多少个节点和父亲合并后的方法数，很明显是个乘法原理，把所有的方案数加起来这操作很秀吧，滚两个数组，c和dp，c表示合并当前子树的方案数，然后滚动一下，怎么老是滚动优化，真的是。。。，DP这么喜欢用滚动吗然后注意考虑下DP边界，就是儿子选0个合并的时，需要计算子树v 1~k的方案数的和，因为不选的话,v也是一样1~k的选择权（选k以上肯定不符合题意）于是这题就做完了，不得不说usename6 DP 真垃圾1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 2010using namespace std;typedef long long LL;const LL mod=998244353;struct Edge&#123;int v,next;&#125;;int head[MAXN],num[MAXN],tot,n,k;LL dp[MAXN][MAXN],c[MAXN];Edge e[MAXN&lt;&lt;1];void add(int u,int v)&#123; e[tot].v=v; e[tot].next=head[u]; head[u]=tot++;&#125;void dfs(int u,int pre)&#123; //printf("u=%d\n",u); dp[u][1]=1; //初始化当u这个子树为1的方案数 num[u]=1; //表示u的子树个数 for(int i=head[u];i!=-1;i=e[i].next) &#123; int v=e[i].v; if(v!=pre) &#123; dfs(v,u); //printf("%d --- &gt; %d\n",u,v); for(int x=0;x&lt;=num[v];x++) //枚举v子树的大小，从0开始是因为他可不选 &#123; for(int y=1;y&lt;=num[u];y++) //枚举u子树的大小，从1开始是因为他必须选 &#123; c[x+y]+=dp[u][y]*dp[v][x]%mod; c[x+y]%=mod; //printf("%d %lld\n",x+y,c[x+y]); &#125; &#125; num[u]+=num[v]; for(int x=1;x&lt;=num[u];x++) &#123; dp[u][x]=c[x]; c[x]=0; &#125; &#125; &#125; for(int i=1;i&lt;=min(k,num[u]);i++) dp[u][0]=(dp[u][0]+dp[u][i])%mod;&#125;int main()&#123; memset(head,-1,sizeof(head)); tot=0; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;n;i++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v); add(v,u); &#125; dfs(1,1); printf("%lld\n",dp[1][0]); return 0;&#125; D.绿魔法师听说是容斥？数论选手决定留坑]]></content>
      <categories>
        <category>ACM</category>
        <category>Wannafly</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Wannafly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中点画线算法]]></title>
    <url>%2F2018%2F10%2F28%2F%E4%B8%AD%E7%82%B9%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[图形学扫描线算法复习中，拯救图形学计划。。。首先这个算法是有适用范围的：$0 &lt; k &lt; 1 $首先将一般的直线方程转化为： $ F(x,y) = ax + by + c $很明显我们发现1.当$F(x,y) = 0$时，点(x,y)在直线上2.当$F(x,y) &gt; 0$时，点(x,y)在直线的上方3.当$F(x,y) &lt; 0$时，点(x,y)在直线的下方若设当前像素点P点$(x{p},y{p})$，那么其中点M点$(x{p} + 1,y{p} + 0.5)$定义 $d = F(M) = F(x{p} + 1,y{p} + 0.5) = a(x{p} + 1) + b(y{p} + 1) + c$对d分类讨论有若d大于0，即M点在直线上方，取$P{1}$点此时由$P{1}$生成的F值（差值）为d1$d1 = F(x{p} + 2,y{p} + 0.5) = a(x{p} + 2) + b(y{p} + 0.5) + c = d + a $即 $x{p+1} = x{p} + 2$ $y{p+1} = y{p} + 0.5$ $d{p+1} = d{p} + a若d小于0，即M点在直线下方，取$P{2}点同理 $ d2 = F{x{p} + 2, y{p} + 1.5} = a(x{p} + 2) + b(y{p} + 1.5) + c = d + a + b $即 $x{p+1} = x{p} + 2$ $y{p+1} = y{p} + 1.5$ $d{p+1} = d_{p} + a + b$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;GL/glut.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;void MP_Line(int x0,int y0,int x1,int y1)&#123; int a,b,d1,d2,d,x,y; a=y0-y1; b=x1-x0; d=a+a+b; d1=a+a; d2=a+a+b+b; x=x0; y=y0; while(x&lt;x1) &#123; glPointSize(5.0); glBegin(GL_POINTS); if(d&lt;0) &#123; glVertex2f(x,y); glEnd(); x++; y++; d+=d2; &#125; else &#123; glVertex2f(x,y); glEnd(); x++; d+=d1; &#125; //printf("(%d,%d)\n",x,y); &#125;&#125;void display()&#123; glClearColor(1.0, 1.0, 1.0, 1.0); glClear(GL_COLOR_BUFFER_BIT); glViewport(0,0,500,500); MP_Line(0,0,500,100); MP_Line(0,0,500,200); MP_Line(0,0,500,300); MP_Line(0,0,500,400); //printf("over\n"); glFlush();&#125;int main(int argc,char **argv)&#123; glutInit(&amp;argc,argv); glutInitDisplayMode(GLUT_SINGLE|GLUT_RED); glutInitWindowSize(500,500); glutInitWindowPosition(0,0); glutCreateWindow("MPLine"); glutDisplayFunc(display); //调用里面函数的绘图函数（当然是你定义） glColor3f(0.0, 0.0, 0.0); gluOrtho2D(0.0, 500.0, 0.0, 500.0); glutMainLoop(); return 0;&#125;]]></content>
      <categories>
        <category>OpenGL</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDA算法]]></title>
    <url>%2F2018%2F10%2F27%2FDDA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今日连更四篇，也是很肛（沉迷博客无法自拔）。。。原理：假设直线为：$ y = kx + b $分两种情况讨论1.当$ | k | &lt; = 1 $则设$x{i+1} = x{i} + 1$那么$y{i+1} = y{i} + k$2.当$ | k | &gt; = 1 $则将直线方程转化为$ x = (1/k)y - b/k $则设$y{i+1} = y{i} + 1$那么$x{i+1} = x{i} + 1/k$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;GL/glut.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;void DDA_Line(int x1,int y1,int x2,int y2) //描绘点在(x1,y1)到(x2,y2)之间的线段&#123; float k; //表示斜率 float t; //在这之间像素点有多少个 float x; //起始点x坐标 float y; //起始点y坐标 float dx=x2-x1; //x方向的增量 float dy=y2-y1; //y方向的增量 bool tag=false; //表示斜率的绝对值是大于还是小于1,大于1为true,小于1为false if(abs(dx)&gt;=abs(dy)) &#123; k=dy/dx; t=dx; tag=true; &#125; else &#123; k=dx/dy; t=dy; tag=false; &#125; x=x1; y=y1; for(int i=0;i&lt;=t;i++) //枚举这之间的像素点 &#123; glPointSize(1.0); glBegin(GL_POINTS); if(tag) &#123; glVertex2f(x,int(y+0.5)); glEnd(); y=y+k; x++; &#125; else &#123; glVertex2f(int(x+0.5),y); glEnd(); x=x+k; y++; &#125; &#125;&#125;void display()&#123; glClearColor(1.0, 1.0, 1.0, 1.0); //白色 glClear(GL_COLOR_BUFFER_BIT); //设置背景为白色 glViewport(0,0,500,500); DDA_Line(0,500,500,0); DDA_Line(0,0,500,600); DDA_Line(250,0,250,500); DDA_Line(0,250,500,250); glFlush();&#125;int main(int argc,char **argv)&#123; glutInit(&amp;argc,argv); glutInitDisplayMode(GLUT_SINGLE|GLUT_RED); glutInitWindowSize(500,500); glutInitWindowPosition(0,0); glutCreateWindow("DDA_Line"); glutDisplayFunc(display); //调用里面函数的绘图函数（当然是你定义） glColor3f(0.0, 1.0, 1.0); gluOrtho2D(0.0, 500.0, 0.0, 500.0); glutMainLoop(); return 0;&#125;]]></content>
      <categories>
        <category>OpenGL</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Open GL 基本函数二]]></title>
    <url>%2F2018%2F10%2F27%2FOpen-GL-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Open GL 基本函数二1void glClearColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha);参数分别是红，绿，蓝，不透明度，取值范围在[0,1]，仅仅只是执行设定颜色，不执行清除工作，仅仅是为了glClear()函数做准备 1glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT) 参数可为一个或多个，若为多个，用’|’隔开GL_COLOR_BUFFER_BIT当前可写的颜色缓冲GL_DEPTH_BUFFER_BIT深度缓冲GL_ACCUM_BUFFER_BIT累积缓冲GL_STENCIL_BUFFER_BIT模板缓冲 如果两个函数结合一起用，即12glClearColor(1.0, 1.0, 1.0, 1.0); //白色glClear(GL_COLOR_BUFFER_BIT);表示把背景设置成蓝色 1void glPointSize(GLfloat size) 设置绘制时点的大小，大小单位为像素，默认值为1.0，很明显要大于0.0f 1void glBegin(GLenum mode) mode表示创建元素的类型，有如下几个类型GL_POINTS 单个顶点集GL_LINES 多组双顶点线段GL_POLYGON 单个简单填充凸多边形GL_TRAINGLES 多组独立填充三角形GL_QUADS 多组独立填充四边形GL_LINE_STRIP 不闭合折线GL_LINE_LOOP 闭合折线GL_TRAINGLE_STRIP 线型连续填充三角形串GL_TRAINGLE_FAN 扇形连续填充三角形串GL_QUAD_STRIP 连续填充四边形串 1void glEnd(void) 一个几何图形绘制的结束 1glVertex2f(float,float) 设定点的坐标，f表示参数是浮点数类似的还有：glVertex2dglVertex2fglVertex3fglVertex3fv字母表示参数的类型1.s表示16位整数（OpenGL中将这个类型定义为GLshort），2.i表示32位整数（OpenGL中将这个类型定义为GLint和GLsizei），3.f表示32位浮点数（OpenGL中将这个类型定义为GLfloat和GLclampf），4.d表示64位浮点数（OpenGL中将这个类型定义为GLdouble和GLclampd）。5.v表示传递的几个参数将使用指针的方式。 1glViewport(GLint x,GLint y,GLsizei width,GLsizei height) x，y 以像素为单位，指定了视口的左下角位置。width，height 表示这个视口矩形的宽度和高度，根据窗口的实时变化重绘窗口。]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Open GL 基本函数一]]></title>
    <url>%2F2018%2F10%2F27%2FOpen-GL-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Open-GL 基本函数一转战图形学（其实为了应付考试。。。，再不复习就挂科了。。。）1void glutInit(int* argc,char** argv) 这个函数用来初始化GLUT，此时main函数也有对应的参数：1int main(int argc,char* argv[])glutInit是从main函数获取参数 1void glutInitWindowSize(int width,int height) 该函数用于初始化窗口的大小 1void glutInitWindowPosition(int x,int y) 该函数用来初始化窗口左上角是什么，以像素为单位 1void glutInitDisplayMode(unsigned int mode) 显示模式，可供选择的参数：1.GLUT_RGBA：当未指明GLUT-RGBA或GLUT-INDEX时，是默认使用的模式。表明欲建立RGBA模式的窗口。2.GLUT_RGB：与GLUT-RGBA作用相同。3.GLUT_INDEX：指明为颜色索引模式。4.GLUT_SINGLE：只使用单缓存5.GLUT_DOUBLE：使用双缓存。以避免把计算机作图的过程都表现出来，或者为了平滑地实现动画。6.GLUT_ACCUM：让窗口使用累加的缓存。7.GLUT_ALPHA：让颜色缓冲区使用alpha组件。8.GLUT_DEPTH：使用深度缓存。9.GLUT_STENCIL：使用模板缓存。10.GLUT_MULTISAMPLE：让窗口支持多例程。11.GLUT_STEREO：使窗口支持立体。12.GLUT_LUMINACE:luminance是亮度的意思。但是很遗憾，在多数OpenGL平台上，不被支持。 1glColor3f(float, float, float) 好吧，他有三个浮点参数，但是不清楚是什么（其实是懒得翻他headfile了）其中0.0表示不使用颜色成分，1.0表示使用颜色最大值具体参数对应的颜色如下12345678glColor3f(0.0, 0.0, 0.0); --&gt; 黑色 glColor3f(1.0, 0.0, 0.0); --&gt; 红色 glColor3f(0.0, 1.0, 0.0); --&gt; 绿色 glColor3f(0.0, 0.0, 1.0); --&gt; 蓝色 glColor3f(1.0, 1.0, 0.0); --&gt; 黄色 glColor3f(1.0, 0.0, 1.0); --&gt; 品红色 glColor3f(0.0, 1.0, 1.0); --&gt; 青色 glColor3f(1.0, 1.0, 1.0); --&gt; 白色 这个函数有个需要注意的是，如果在glBegin()与glEnd()连续调用多个这个函数，只显示最后一个]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 53 (Rated for Div. 2)]]></title>
    <url>%2F2018%2F10%2F27%2FEducational-Codeforces-Round-53-Rated-for-Div-2%2F</url>
    <content type="text"><![CDATA[传送门：http://codeforces.com/contest/1073职业fst选手没有被fst，可喜可贺，成功的上了分A. Diverse Substring水题，直接枚举所有子串判断一下就行，实际上有个更好的做法，直接看相邻的两个字母是不是相同，不相同的话，就取那两个就行了，复杂度O(n)A.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;string s;int cnt[30];int main()&#123; int n; cin&gt;&gt;n; cin&gt;&gt;s; bool flag=false; for(int i=0;i&lt;n;i++) &#123; for(int j=1;i+j-1&lt;n;j++) &#123; string ss=s.substr(i,j); memset(cnt,0,sizeof(cnt)); for(int k=0;k&lt;ss.size();k++) &#123; int id=ss[k]-'a'; cnt[id]++; &#125; bool tag=true; for(int k=0;k&lt;26;k++) &#123; if(cnt[k]&gt;ss.size()/2) &#123; tag=false; break; &#125; &#125; if(tag) &#123; flag=true; cout&lt;&lt;"YES"&lt;&lt;endl; cout&lt;&lt;ss&lt;&lt;endl; &#125; if(flag)break; &#125; if(flag)break; &#125; if(!flag)cout&lt;&lt;"NO"&lt;&lt;endl; return 0;&#125; B. Vasya and Books没什么难度，按题目模拟就行B.cpp12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;int a[200005];int b[200005];bool used[200005];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]); int j=1; for(int i=1;i&lt;=n;i++) &#123; if(used[b[i]]) printf("%d%c",0,i==n?'\n':' '); else &#123; int cnt=0; for(;j&lt;=n;j++) &#123; cnt++; used[a[j]]=true; if(a[j]==b[i]) &#123; j++; break; &#125; &#125; //printf("%d %d\n",b[j],a[i]); //printf("j=%d cnt=%d\n",j,cnt); printf("%d%c",cnt,i==n?'\n':' '); &#125; &#125; return 0;&#125; C. Vasya and Robot题目意思就是给你长度为n移动序列，让你通过修改给定移动序列，使得你能从(0,0)到(x,y)，并求出所有修改中，最大的位置-最小位置+1的最小值刚开始看这题，感觉是双指针，不算很快速的敲完了双指针，后来发现双指针是个假算法，冷静分析了一下，发现区间具有单调性，而且，我只有固定好修改的区间在哪，直接看当前区间的长度和距离之间的关系，二分check一下就好了，最后三分钟绝杀这题C.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n;char op[200005];int x,y;int dx[200005],dy[200005];bool check(int mid)&#123; int cx=0,cy=0; //printf("mid=%d\n",mid); for(int i=1;i&lt;=n;i++) &#123; int j=i+mid-1; if(j&gt;n)break; cx=cy=0; cx=dx[i-1]+(dx[n]-dx[j]); cy=dy[i-1]+(dy[n]-dy[j]); //printf("i=%d cx=%d cy=%d\n",i,cx,cy); if(mid&lt;abs(x-cx)+abs(y-cy))continue; if((mid-abs(x-cx)+abs(y-cy))%2==0)return true; &#125; return false;&#125;int main()&#123; scanf("%d",&amp;n); scanf("%s",op+1); for(int i=1;i&lt;=n;i++) &#123; dx[i]+=dx[i-1]; dy[i]+=dy[i-1]; if(op[i]=='R')dx[i]++; else if(op[i]=='L')dx[i]--; else if(op[i]=='U')dy[i]++; else if(op[i]=='D')dy[i]--; //printf("%d %d %d\n",i,dx[i],dy[i]); &#125; scanf("%d%d",&amp;x,&amp;y); if(dx[n]==x&amp;&amp;dy[n]==y) &#123; printf("0\n"); return 0; &#125; if(abs(x)+abs(y)&gt;n) &#123; printf("-1\n"); return 0; &#125; int l=1,r=n; int ans=1e9; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) &#123; ans=min(mid,ans); r=mid-1; &#125; else l=mid+1; &#125; printf("%d\n",ans==1e9?-1:ans); return 0;&#125; D. Berland Fair好像是给你一个圆形序列，然后你手中有t元钱，你从1位置开始一直走圆形序列，如果能买当前物品，你就去买，但是你只能买一件，当你最后什么都不能买的时候，就退出，问可以买多少件物品可以证明，假设你买的是序列{1,3,4,7},那么你下次一定也只能买{1，3，4，7}，那么根据贪心思想，我计算一下这个序列能被我买多少次，有点类似除法和取mod的思想D.cpp123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n;LL t;int a[200005];int main()&#123; scanf("%d%I64d",&amp;n,&amp;t); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); LL ans=0; while(1) &#123; LL cur=0; LL cnt=0; for(int i=1;i&lt;=n;i++) &#123; if(cur+a[i]&lt;=t) &#123; cnt++; cur+=a[i]; &#125; &#125; if(cur==0)break; ans+=cnt*(t/cur); t%=cur; &#125; printf("%I64d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC 沈阳站总结]]></title>
    <url>%2F2018%2F10%2F25%2FACM-ICPC-%E6%B2%88%E9%98%B3%E7%AB%99%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一开始就听说了沈阳站是Claris和tls和qls出题，本来去的时候就没报拿牌的希望，没想到热身赛居然打到rk61,这让我又燃起了希望，随即当晚又刷了4题。正式赛的时候，zcx很快的发现了一道全场签到题，然后把这个签到题丢给我，我一看是字符串，确定好细节，然后开始写，测了几组样例，放心的交上去，1Y。接下来陷入到长期的卡题中，刷新了一下榜，发现K有人过了，于是赶紧看K，好像是个约瑟夫环问题，但是我并不懂是怎么推的，而且数据范围也有点难搞，过了一会，发现很对队伍过了C，随即放弃手中的K，然后肛起来C，一开始看这个C，我总觉得有点DP的感觉，然后Claris也喜欢出DP，于是我开始怂恿队友往DP方向想，差点就成功坑了队友的一发，这时候lsb推出了一个公式，我不放心，让zcx用py打个表先，没想到这个打表还很难写，于是我们决定，就这么肛上去，我手推了几个，也没发现lsb有错，于是交了一发，1Y。这时候旁边两支金牌队伍都秒了G，看了一眼G，感觉有点像数据结构，但是结合了做这么多数据结构的经验，我觉得这题一定不是数据结构，一开始我提出了离线乱搞的想法，然后仔细阅读题目，好像是强制在线，GG，但是lsb说强制在线反而没有离线那么麻烦，我想了也是，于是开始想在线的做法，这时对友突然提了一下勾股数，我发现确实是整点坐标不共线，必然K是勾股数的平方，我提出了是不是这个范围勾股数不多，直接枚举所有的勾股数就行，于是我上去打了个表，发现勾股数很多，至少占1/2,这时候又陷入僵局，仔细思考了一下，我和lsb发现好像当K是完全平方数的时候，才能共线分解，当K是勾股数的平方的时候，可能会有多个分解，但这个分解量级在10这样，对查询和更新的贡献不大，于是lsb提出预处理所有的勾股数分解，然后查询和更新判断是不是勾股数，分类讨论暴力一下就好了，我觉得这个算法很正确，于是让lsb写了，结果没想到这题码量意外大，没想到因为我的决策失误，错失了一块银牌，这题最后都没找出来哪里WA了，当时这题确实我应该我写的，我意识到这个问题的时候已经是还剩45分钟的时候，这个数据结构没过的锅我背吧，这次比赛我还没尽到代码手责任，特别是这种数据结构题，应该还是我上机搞一搞的。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello,usename6]]></title>
    <url>%2F2018%2F10%2F24%2Fhello-usename6%2F</url>
    <content type="text"><![CDATA[hello usename6!]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
