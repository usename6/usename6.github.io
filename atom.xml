<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>usename6</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-08-02T13:12:44.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>usename6</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PDD笔试题</title>
    <link href="http://yoursite.com/2021/08/02/PDD%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2021/08/02/PDD笔试题/</id>
    <published>2021-08-02T08:30:13.000Z</published>
    <updated>2021-08-02T13:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>A.<br>题意：<br><img src="/images/PDD笔试题/1.jpg" alt="alt"><br>题解：<br>不难，排序后，一个个比较是否包含就行。<br>code:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//结构体的二维排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Line</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Line</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr)</span></span>&#123;</span><br><span class="line">        l=ll;</span><br><span class="line">        r=rr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"l = "</span> + <span class="keyword">this</span>.l + <span class="string">", r = "</span> + <span class="keyword">this</span>.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProblemA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">        Line[] lines = <span class="keyword">new</span> Line[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            lines[i] = <span class="keyword">new</span> Line();</span><br><span class="line">            lines[i].l=cin.nextInt();</span><br><span class="line">            lines[i].r=cin.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(lines, <span class="keyword">new</span> Comparator&lt;Line&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Line o1, Line o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1.l == o2.l)</span><br><span class="line">                    <span class="keyword">return</span> o1.r - o2.r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> o1.l - o2.l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lines[i].r&gt;lines[i-<span class="number">1</span>].r)&#123;</span><br><span class="line">                flag=<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) System.out.println(<span class="string">"false"</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">"true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>B.<br>题意：<br><img src="/images/PDD笔试题/2.jpg" alt="alt"><br>题解：</p><p>code：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProblemB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> [] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100005</span>];</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setcards</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">//O(1)的复杂度</span></span><br><span class="line">        <span class="keyword">if</span>(hashMap.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">int</span> p = hashMap.get(val);</span><br><span class="line">            <span class="keyword">if</span>(p&gt;cnt)&#123;</span><br><span class="line">                c[++cnt]=val;  <span class="comment">//set</span></span><br><span class="line">                hashMap.put(val,cnt);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> num = cnt-p+<span class="number">2</span>;</span><br><span class="line">            cnt=p-<span class="number">1</span>;   <span class="comment">//只有前p-1有效</span></span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        c[++cnt]=val;</span><br><span class="line">        hashMap.put(val,cnt);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100005</span>];</span><br><span class="line">        <span class="keyword">int</span> [] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100005</span>];</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = cin.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)a[i]=cin.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)b[i]=cin.nextInt();</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count1=<span class="number">0</span>,count2=<span class="number">0</span>,ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">        hashMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(count1&lt;N||count2&lt;N)&#123;</span><br><span class="line">            <span class="keyword">while</span>(count1&lt;N)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">                <span class="keyword">int</span> tag=setcards(a[count1]);</span><br><span class="line">                <span class="keyword">if</span>(tag&lt;=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                ans1+=tag;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count2&lt;N)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">                <span class="keyword">int</span> tag=setcards(b[count2]);</span><br><span class="line">                <span class="keyword">if</span>(tag&lt;=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                ans2+=tag;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i]%<span class="number">2</span>!=<span class="number">0</span>)ans1++;</span><br><span class="line">            <span class="keyword">else</span> ans2++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans1+<span class="string">" "</span>+ans2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">Output</span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">Output:</span><br><span class="line"><span class="number">7</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">Output:</span><br><span class="line"><span class="number">6</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line">Output:</span><br><span class="line"><span class="number">0</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">Output:</span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line">Output:</span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>C.<br>题意：<br><img src="/images/PDD笔试题/3.jpg" alt="alt"><br>题解:<br>数学题，需要推出通项公式：<br>若一个数在集合$S$中，那么有：</p><script type="math/tex; mode=display">S_{i} = S_{i-1} * C^{k_{i}} +  t_{i} * B, i=1,2,...N $$  (1)$$ S_{i-1} = S_{i-2} * C^{k_{i-1}} +  t_{i-1} * B, i=1,2,...N $$ (2)联合(1)和(2)，得：$$ S_{i} = （S_{i-2} *  C^{k_{i-1}} +  t_{i-1} * B) * C^{k_{i}} + t{i} * B, i=1,2,...N</script><p>化简有：</p><script type="math/tex; mode=display">S_{i} = S_{i-2} * C^{k_{i-1}+k_{i}} +  (t_{i-1} * C^{k_{i}} + t{i}) * B, i=1,2,...N</script><p>我们令$ KK = k<em>{i-1} + k</em>{i} $,并且令$ TT =  (t<em>{i-1} * C^{k</em>{i}} + t{i}) $, 这里显然KK和TT可以取到N上的任意整数。<br>那么就会得到：</p><script type="math/tex; mode=display">S_{i} = S_{i-2} * C^{KK} + TT * B</script><p>化简得到通项：</p><script type="math/tex; mode=display">S_{i} = S_{0} * C^{K} + T * B</script><p>故只需要枚举$K$，然后判断$(Q - C^{k}*A) % B == 0$即可。特殊地若C=1，那么只需判断 $ (Q % B) == A $<br>code：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProblemC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T=cin.nextInt();</span><br><span class="line">        <span class="keyword">while</span>(T&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            T--;</span><br><span class="line">            <span class="keyword">int</span> A = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> B = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> C = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> Q = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(C==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Q%B==A) System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                <span class="keyword">else</span> System.out.println(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">boolean</span> tag=<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">32</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(res&gt;Q)<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>((Q-res*A)%B==<span class="number">0</span>)&#123;</span><br><span class="line">                        tag=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res=res*C;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tag) System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                <span class="keyword">else</span> System.out.println(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>D.<br>题意:<br><img src="/images/PDD笔试题/4.jpg" alt="alt"><br>题解:<br>贪心，首先数字被分的越多，乘积越小。数字越少，越大。<br>故这里肯定是将这些数分成两个数合理。<br>这题的结论是让两个数的差值尽可能小。（这个结论是猜的，证明暂时略）<br>code:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProblemD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> []cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> []a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100005</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)cnts[i]=cin.nextInt();</span><br><span class="line">        BigInteger A = <span class="keyword">new</span> BigInteger(<span class="string">"0"</span>);</span><br><span class="line">        BigInteger B = <span class="keyword">new</span> BigInteger(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnts[i];j++)&#123;</span><br><span class="line">                a[++cnt]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A.compareTo(B)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                A = A.multiply(BigInteger.valueOf(<span class="number">10</span>));</span><br><span class="line">                A = A.add(BigInteger.valueOf(a[i]));</span><br><span class="line">                B = B.multiply(BigInteger.valueOf(<span class="number">10</span>));</span><br><span class="line">                B = B.add(BigInteger.valueOf(a[i+<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                A = A.multiply(BigInteger.valueOf(<span class="number">10</span>));</span><br><span class="line">                A = A.add(BigInteger.valueOf(a[i+<span class="number">1</span>]));</span><br><span class="line">                B = B.multiply(BigInteger.valueOf(<span class="number">10</span>));</span><br><span class="line">                B = B.add(BigInteger.valueOf(a[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(A.multiply(B));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A.&lt;br&gt;题意：&lt;br&gt;&lt;img src=&quot;/images/PDD笔试题/1.jpg&quot; alt=&quot;alt&quot;&gt;&lt;br&gt;题解：&lt;br&gt;不难，排序后，一个个比较是否包含就行。&lt;br&gt;code:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="Java 笔试题" scheme="http://yoursite.com/categories/Java-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java 笔试题" scheme="http://yoursite.com/tags/Java-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>隐式马尔科夫的学习</title>
    <link href="http://yoursite.com/2020/04/29/%E9%9A%90%E5%BC%8F%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB/"/>
    <id>http://yoursite.com/2020/04/29/隐式马尔科夫/</id>
    <published>2020-04-29T12:46:04.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下隐式马尔科夫这个问题。（好像除了参数估计，就是个概率DP啊，摔<br><a id="more"></a><br>一、基本概念<br>所有可能状态集合： <script type="math/tex">Q = (q_1, q_2, ... , q_n)</script><br>所有可观测集合：   <script type="math/tex">V = (v_1, v_2, ... , v_M)</script><br>长度为T的状态序列：<script type="math/tex">I = (i_1, i_2, ... , i_T)</script><br>长度为T的观测序列：<script type="math/tex">O = (o_1, o_2, ... , o_T)</script><br>初始概率分布：     <script type="math/tex">\pi = (\pi_{1}, \pi_{2}, ... , \pi_{n})</script><br>其中：</p><script type="math/tex; mode=display">\pi_{i} = P(i_t=q_i) , i=1,2,...N</script><p>状态转移矩阵：     <script type="math/tex">A = [a_{ij}]</script><br>其中：</p><script type="math/tex; mode=display">a_{ij} = P(i_{t+1} = q_j | i_t = qi), i=1,2,...,N; j=1,2,...,N.</script><p>观测转移矩阵：     <script type="math/tex">B = [b_{ij}]</script><br>其中：</p><script type="math/tex; mode=display">b_{ij} = P(o_t = v_j | i_t = q_i), i=1,2...,N;j=1,2,...,M</script><p>两个基本假设：<br>1）齐次马尔科夫性假设：即假设隐藏的马尔科夫链在任意时刻t的状态只依赖于前一个时刻的状态。与其他时刻状态及观测无关，也与t时刻无关。<br>2）观测独立假设：即假设任意时刻观测只依赖于该时刻的马尔科夫链的状态，与其他观测及状态无关。<br><strong>具体例子，请参考《统计学习方法》 第10章隐式马尔科夫的第一节，对着例子思考，这些概念会很清晰。</strong><br>三个基本问题：<br>a. 概率计算，给定观测序列，计算在参数<script type="math/tex">\lambda</script>下的该观测序列的概率是多少？<br>b. 参数估计，给定观测序列，估计参数<br>c. 预测，给定观测序列，预测导致对应隐藏状态是多少。<br>二、概率计算问题<br>2.1 前向概率计算<br>定义foward[i][j]表示第j时刻，状态为i的概率是多少？<br>初值：<script type="math/tex">foward[i][1] = \pi[i] \times b[i][o_1]</script><br>转移方程： <script type="math/tex">foward[i][t] = \sum_{j=1}^N{(foward[j][t-1] \times a[j][i])} \times b[i][o_t] , t \gt 1</script><br>最终结果： <script type="math/tex">ans = \sum_{i=1}^N forward[i][T]</script><br>2.2 后向概率计算<br>定义backward[i][j]表示从j+1时刻起，状态为i的概率是多少？<br>初值： <script type="math/tex">backward[i][T] = 1</script><br>转移方程： <script type="math/tex">backward[i][t] = \sum_{j=1}^N{(backward[j][t+1] \times a[j][i])} \times b[j][o_{t+1}] , t \lt T</script><br>最终结果： <script type="math/tex">ans = \sum_{i=1}^N{(\pi_i \times b[i][o_1] \times backward[i][1])}</script><br>注：因为T+1以后的结果不再关心，所以可以虚拟出一个节点，将所有状态节点概率流入这个节点，所以这个节点的概率是1，结合后向概率的概念，所以backward[i][T]被初始化为1。<br>三、参数估计（简单介绍，暂时略过，在学习最大似然估计和最大后验估计等等参数估计方法，会补充说明）<br>主要是对转移状态矩阵和观测转移矩阵的估计，根据输入的训练数据的输入（是否包括状态序列），又分为有监督和无监督型学习方法。<br>四、预测问题<br>4.1 近似算法<br>这个算法很简单，是一种贪心算法，就是每个时刻都选择一个概率最大的状态作为该时刻的估计状态。<br>首先定义：<br>前向概率： <script type="math/tex">\alpha_{t}(i) = forward[i][t]</script><br>后向概率:  <script type="math/tex">\beta_{t}(i) = backward[i][t]</script><br>那么时刻t处于状态<script type="math/tex">q_i</script>的概率<script type="math/tex">\gamma_{t}(i) = \frac{\alpha_{t}(i) \times \beta_{t}(i)}{\sum_{j=1}^N{\alpha_{t}(j) \times \beta_{t}(j)}}</script><br>那么得到最有可能的状态</p><script type="math/tex; mode=display">I_{t} = arg\,\max_{1 \le i \le N} [\gamma_{t}(i)]</script><p>4.2 维比特算法<br>这个算法就是概率DP：<br>定义DP[i][t]表示t时刻下，状态为<script type="math/tex">q_i</script>的概率。<br>初值：   <script type="math/tex">DP[i][1] = \pi_{i} \times b[i][o_1]</script><br>转移:    <script type="math/tex">DP[i][t] = max(DP[j][t-1] \times b[j][o_{t-1}] \times a[j][t])，t \lt T</script><br>最终结果：<script type="math/tex">ans = max(DP[i][T])</script><br>然后在回溯求得这个路径就行了。<br>用C++ 搞搞这个代码，python的版本太多了。。。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HMM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> N, M, T;   <span class="comment">//N表示可能的状态数，M表示可能的观测数，T表示时间</span></span><br><span class="line"><span class="keyword">int</span> O[MAXN];   <span class="comment">//输入观测序列</span></span><br><span class="line"><span class="keyword">double</span> forward[MAXN][MAXN], backward[MAXN][MAXN], pi[MAXN]; <span class="comment">//forward表示前向概率，backward表示后向概率</span></span><br><span class="line"><span class="keyword">double</span> A[MAXN][MAXN], B[MAXN][MAXN];   <span class="comment">//A状态转移矩阵，B观测转移矩阵</span></span><br><span class="line"><span class="keyword">double</span> DP[MAXN][MAXN];<span class="comment">//Predict中的中间结果</span></span><br><span class="line"><span class="keyword">int</span> mark[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> L[MAXN];<span class="comment">//Predict序列值</span></span><br><span class="line">HMM()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//输入状态转移矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; A[i][j];</span><br><span class="line"><span class="comment">//输入观测转移矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; B[i][j];</span><br><span class="line"><span class="comment">//输入初始概率</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; pi[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; O[i];</span><br><span class="line">&#125;</span><br><span class="line">HMM(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> t)</span><br><span class="line">&#123;</span><br><span class="line">N = n;</span><br><span class="line">M = m;</span><br><span class="line">T = t;</span><br><span class="line">Input();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_forward</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">forward[i][<span class="number">1</span>] = pi[i] * B[i][O[<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_backward</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">backward[i][T] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_predict</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">DP[i][<span class="number">1</span>] = pi[i] * B[i][O[<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">2</span>; t &lt;= T; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">mark[i][t] = <span class="number">0</span>;</span><br><span class="line">DP[i][t] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> tmp = DP[j][t<span class="number">-1</span>] * A[j][i] * B[i][O[t]];</span><br><span class="line"><span class="keyword">if</span> (DP[i][t] &lt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">DP[i][t] = tmp;</span><br><span class="line">mark[i][t] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; DP[i][T])</span><br><span class="line">&#123;</span><br><span class="line">ans = DP[i][T];</span><br><span class="line">mark[<span class="number">0</span>][T + <span class="number">1</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">forward_cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">init_forward();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">2</span>; t &lt;= T; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">forward[i][t] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line">&#123;</span><br><span class="line">forward[i][t] += forward[j][t - <span class="number">1</span>] * A[j][i] * B[i][O[t]];  <span class="comment">// j--&gt;i，且i的状态取o[t]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">ans = ans + forward[i][T];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">backward_cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">init_backward();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = T - <span class="number">1</span>; t &gt; <span class="number">0</span>; t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">backward[i][t] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line">&#123;</span><br><span class="line">backward[i][t] += backward[j][t + <span class="number">1</span>] * A[i][j] * B[j][O[t+<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">ans = ans + backward[i][<span class="number">1</span>] * pi[i] * B[i][O[<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_list</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L[t] = mark[pre][t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (t&gt;<span class="number">1</span>)</span><br><span class="line">get_list(t - <span class="number">1</span>, L[t]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; L[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">predict</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">init_predict();</span><br><span class="line">solve();</span><br><span class="line">get_list(T, <span class="number">0</span>);</span><br><span class="line">output();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HMM work=HMM(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; work.forward_cal() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; work.backward_cal() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">work.predict();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0.5 0.2 0.3</span></span><br><span class="line"><span class="comment">0.3 0.5 0.2</span></span><br><span class="line"><span class="comment">0.2 0.3 0.5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0.5 0.5</span></span><br><span class="line"><span class="comment">0.4 0.6</span></span><br><span class="line"><span class="comment">0.7 0.3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0.2 0.4 0.4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>书中例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="number">0.5</span> <span class="number">0.2</span> <span class="number">0.3</span></span><br><span class="line"><span class="number">0.3</span> <span class="number">0.5</span> <span class="number">0.2</span></span><br><span class="line"><span class="number">0.2</span> <span class="number">0.3</span> <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.5</span> <span class="number">0.5</span></span><br><span class="line"><span class="number">0.4</span> <span class="number">0.6</span></span><br><span class="line"><span class="number">0.7</span> <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.2</span> <span class="number">0.4</span> <span class="number">0.4</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="number">0.130218</span></span><br><span class="line"><span class="number">0.130218</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一下隐式马尔科夫这个问题。（好像除了参数估计，就是个概率DP啊，摔&lt;br&gt;
    
    </summary>
    
      <category term="machine learning" scheme="http://yoursite.com/categories/machine-learning/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>C++ 网络编程（二） --- TCP传输</title>
    <link href="http://yoursite.com/2020/04/28/winsock-2/"/>
    <id>http://yoursite.com/2020/04/28/winsock-2/</id>
    <published>2020-04-28T01:32:46.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>国际投资学作业公布了，要写小论文，然后还得赶毕设，最近有可能会咕咕一段时间？<br><a id="more"></a><br>一、TCP 传输的基本概念<br>1.1 TCP报文格式<br><img src="/images/winsock-2/figure1.png" alt="alt"><br>在本节，我们重点关注的是SYN、ACK、FIN选项。<br>1）SYN介绍<br>先介绍一个概念叫ISN（Initial Sequence Number），在三次连接过程中，客户端和服务端在建立TCP连接时，双方都会发送SYN报文，并初始化序号。那么为什么需要初始化序列号呢？<br>可以举一例说明。假设服务端（A），客户端（B）建立连接，分别使用固定序列号1和2。当A和B建立TCP连接后，B由于一部分原因重启了，那么这条TCP连接将被A废弃。但可能因为网络延迟，B发送给A的数据还在传输，并未送达A。那么在B重启后，B在重新和A建立TCP连接，在发送新的数据包，那这样就会出现A端既接收了废弃连接数据包、同样也接收新数据连接包，导致错误发生。<br>且注意ISN一般不能取固定值，若ISN固定了，攻击者很容易知道该客户端的ISN是多少，那他就可以根据需要创建和客户端（B）相同的IP和端口，并建立相同的ISN，这样的话就可以进行攻击。<br>SYN，又称同步序列编号（Synchronize Sequence Numbers），该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。（检查的目的就是防止对废弃连接得到数据包进行错误解释，上面已经说明了）。<br>参考：<br><a href="https://zhuanlan.zhihu.com/p/86426969?utm_source=qq&amp;utm_medium=social&amp;utm_oi=852178998824955904" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86426969?utm_source=qq&amp;utm_medium=social&amp;utm_oi=852178998824955904</a><br>ACK：确认标志，又称（Acknowledgement Number），提示远端系统服务端已经成功接收客户端发送的sequence，期待下一个sequence的到来。<br>FIN: 主要用于结束一个TCP连接。<br>1.2 三次握手<br><img src="/images/winsock-2/figure2.png" alt="alt"><br>具体地：<br>第一次握手：客户端给服务端发送一个SYN报文，并指明客户端的初始序列号(ISN-c),此时客户端处于SYN_SEND状态。同步位SYN = 1,seq = x。<strong>注意：不能携带数据。</strong><br>第二次握手：服务端接收到客户端的SYN报文后，会以自己SYN、ACK的报文作为应答，同时指明了自己的初始序列号(ISN-s)。服务端处于SYN_REVD状态。SYN = 1，seq = y, ACK = x+1<br>第三次握手：客户端接收到SYN数据报之后，会同服务器一样，以SYN、ACK报文作为应答，此时客户端处于ESTABLISHED状态。服务端接收到客户端发来的SYN、ACK报文后，也会处于ESTABLISHED状态。此时双方成功建立连接。<br><strong>第三次握手可以携带数据，第一、第二次不行。</strong><br>为什么要三次握手？<br>回答这个问题，需要知道三次握手每一次握手的目的是什么？<br>第一次握手：服务端能够得出结论：客户端的发送能力、服务端的接收能力都是正常的。<br>第二次握手：客户端能够得出结论：服务端的发送、发送能力、客户端的发送、接收能力都是正常的。<br>如果仅仅只是第二次握手，其实服务端并不知道客户端的接收能力是怎么样的。所以需要客户端对这个报文进行响应。<br>第三次握手：服务端能够得出结论：客户端的发送接收能力、服务端的发送接收能力正常。<br>所以我们需要经过三次握手才能得出这样的结论。<br>1.3 四次挥手<br><img src="/images/winsock-2/figure3.png" alt="alt"><br>第一次挥手：客户端发送FIN报文，报文中会指定一个序列号，此时客户端处于FIN_WAIT1状态。即在发出释放连接的报文后，停止发送数据，并进入FIN_WAIT1，并等待服务端的确认。<br>第二次挥手：服务端接收FIN报文，发送ACK报文响应客户端发送的FIN报文，通知客户端已经收到报文。此时服务器进入CLOSE_WAIT的状态。TCP连接进入半关闭状态（客户端到服务端关闭）。客户端收到服务端的确认后，进入FIN_WAIT2状态，这时主要等待的是服务端发出的连接释放报文段。<br>第三次挥手：当服务端也想断开连接了（比如说没什么事情要告诉客户端了），服务端也会发送一个FIN报文，并指定一个序列号，此时服务端也处于LAST_ACK的状态。这时候服务端等待客户端的确认。<br>第四次挥手：客户端收到来自服务端的FIN报文后，发送一个ACK报文作为应答，此时客户端进入TIME_WAIT状态。<strong>（此时TCP连接还没有被释放掉）</strong> 需要经过2 MSL后，客户端进入CLOSED状态。<br>那么有几个问题需要考虑下：<br>a. 为什么要进行四次挥手？<br>第一次、第二次挥手仅仅表示客户端（服务端）不再发送数据，服务端（客户端）可以关闭对客户端（服务端）的接收。而第三次、第四次则是服务端（客户端）不再发送数据。<br>如果仅仅只是两次挥手就关闭所有连接，可能对方某些想要发送数据被迫中断，容易导致错误的发生。<br>b. 为什么要等待两个MSL<br>TIME_WAIT状态设置为2MSL的等待事件。（其中MSL表示Maximum Segment Lifetime，表示任何报文段被丢弃前在网络内的最长时间。）。因为若服务端（客户端）没有收到客户端（服务端）发来ACK请求，可以再重发一次FIN报文，申请断开所有连接。首先服务端（客户端）至多需要经过一个MSL后才能判断是否接收到客户端（服务端）发来ACK，若没有接收到，则需要重新发送FIN报文，而FIN报文到达客户端（服务端）。所以客户端需要等待2MSL，才能判断是否需要关闭连接。若2MSL内，没有收到任何报文，则可以关闭连接。<br>1.4 超时重传<br>RTO,Retransmission TimeOut，若对方超过RTO都没有接收到消息，可以申请向我方申请重传。这个RTO不宜过大，若太大了，则会使网络的吞吐率变小，若RTO太小，有些延迟较大的报文则会被认为丢失，造成不必要重传。一般来说，RTO设置依赖于RTT（Round Trip Time），往返时延，这个往返时延可以通过一些算法进行估算，从而设置RTO。<br>1.5 TCP连接涉及的状态<br><img src="/images/winsock-2/figure4.png" alt="alt"><br>二、winsock - TCP<br>2.1 状态转换图<br><img src="/images/winsock-2/figure5.png" alt="alt"><br>简单介绍在winsock中，TCP的三次握手和四次挥手在winsock中哪些阶段体现。<br>1）首先服务端初始化socket后，调用listen函数，进入监听状态。<br>2）客户端初始化socket后，首先调用connect函数，相当于发送SYN J。<br>3）服务端监听到这个信号后，在accept阻塞，然后进行后续两次握手（前一次在监听的时候已经做了）。<br>注：3）的具体过程，在上述状态图已经解释，这里不再详细说明。<br>4）三次握手之后，新建连接套接字，并返回这个套接字，accept不再被阻塞。<br>四次挥手：<br>上述过程，主要是客户端发送FIN先被服务端接收的时候结果。<br><img src="/images/winsock-2/figure6.png" alt="alt"><br>上述情况是服务端先申请关闭连接，可以发现和上面状态刚好反过来。<br><img src="/images/winsock-2/figure7.png" alt="alt"><br>上述情况是同时到达的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国际投资学作业公布了，要写小论文，然后还得赶毕设，最近有可能会咕咕一段时间？&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>神经网络学习(一) --- 卷积部分</title>
    <link href="http://yoursite.com/2020/04/22/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C1/"/>
    <id>http://yoursite.com/2020/04/22/神经网络1/</id>
    <published>2020-04-22T09:07:18.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>烂笔头疗法，学习下神经网络的卷积部分，（只是理论部分，改天有时间实操几个问题。。<br><a id="more"></a><br>一、卷积<br>1.1 卷积的概念<br>摆个图，应该就懂了（逃<br><img src="/images/神经网络-1/figure1.jpg" alt="alt"><br><img src="/images/神经网络-1/figure2.gif" alt="alt"><br>卷积的作用：在于能提供和挖掘物体的某些共有特征<br>先放一张图在下面，然后介绍一些专有名词：<br><img src="/images/神经网络-1/figure3.png" alt="alt"><br>input_channel: 输入数据的channel个数，对应每个kernel(filter)有多少个channel。<br>output_channel:输出数据(feature map)的channel个数，对应有多少个kernel(filter)。<br>kernel(filter): 卷积核，如图所示，黄色的部分<br>padding: 在图片最外圈补零。如果padding等于，就相当于补两圈0，最后得到输入的size为(h+2,w+2)。<br>stride:卷积核每次移动的补偿，上图卷积核stride为1。<br>feature map:最后得到的输出。<br>如何计算feature map的size</p><script type="math/tex; mode=display">outputsize=(inputsize-kernelsize+2 \times padding)/stride+1</script><p>1.2 特殊的卷积 —— 1x1卷积的作用<br>1）channel-wise full connection （跨通道信息结合）<br>可以按照将feature map中的(x,y)的不同channel连接起来，这样相比全连接层参数更少，更节省空间。在16年CVPR 《Context Encoders: Feature Learning by Inpainting》有提及。如果想保持输入和输出size一样，使用全连接的参数比1x1卷积多。<br>2）升维、降维：这主要是指channel维度。<br>二、反卷积（转置卷积）<br>2.1 反卷积的概念<br>反卷积主要作用，举个我现在正在图像修补的任务来说，图像修补主要采用类似Encoder-Decoder的结构，Encoder主要采用卷积将语义信息编码，在decoder阶段主要使用反卷积（转置卷积）进行解码，还原原图的分辨率。我认为这种结构应该常见于类似UNet的网络的结构。（或是图像修补任务中）。<br>那么反卷积是什么呢？<br>下图是反卷积的常见的过程。<br><img src="/images/神经网络-1/figure4.gif" alt="alt"><br>在这里,$ kernel_size = 3, padding = 1, stride = 2$。<br>那么你可能会觉得好奇，按照正常卷积那套，这里的stride不应该是1吗。<strong>这里就是反卷积和卷积的不同。反卷积的stride并不代表每次点乘后需要将kernel移动多少个单位，而是代表我需要在input里面插入每两列、每两行插入stride-1的列（行）的0。注：padding决定边界插入多少列（行）的0。</strong><br>下图给个stride为1的反卷积，这个实际上和卷积的参数是相同。（$padding=2,stride=1,kernelsize=3$）<br><img src="/images/神经网络-1/figure5.gif" alt="alt"><br>2.2 如何计算反卷积的output_size<br>反卷积的output_size其实可以先算出中间插入0后新的input_size，再利用stride=1、padding、kernel_size计算新的feature_map的大小。<br>知乎硬是没看懂。。。（那个取mod不是搞笑吗，不是变成蛋生鸡还是鸡生蛋的问题了吗？那这样我还不如直接模拟，或者就考虑没有余数的情况）<br><a href="https://www.zhihu.com/question/48279880" target="_blank" rel="noopener">https://www.zhihu.com/question/48279880</a><br>反正正常情况：$ ((inputsize - 1) \times stride + 2 \times padding - kernelsize) / 1$,(化简过，别怀疑为什么没有+1)。<br>三、空洞卷积(膨胀卷积)<br>3.1 空洞卷积的概念<br>还是给个图感受下：<br><img src="/images/神经网络-1/figure6.png" alt="alt"><br>dilate=2，kernel_size=3,padding=0。<br>3.2 感受野概念及应用<br>感受野就是当前的feature map的每一个节点和多少个输入节点相关。例如下图，倒数第二层的feature map每个节点由输入的两个节点构成。那么相当于感受野是2。我们上面（蓝色）的图的倒数第3层节点感受野是4，而在第二层跳过一个节点做连接的感受野是5，感受野增大，主要是跳过一些节点后，重复感受野区域减小了，非重复区域增多，所以导致感受野整体增大。<br>图像修补<br><img src="/images/神经网络-1/figure7.jpg" alt="alt"><br>应用：感受野通常应用在目标检测、语义分割、图像修补等领域。例如基于anchor的目标检测，如果卷积捕捉的语义太小，那么很有可能不足以表征整个anchor的语义无法进行正确的目标检测。例如盲人摸大象，你只摸到象腿，能猜出这个是象吗？对于图像修补，如果捕捉语义太小，很有可能捕捉的仍是空洞的语义，这样必然会导致结果更加模糊。如下图所示：<br><img src="/images/神经网络-1/figure8.png" alt="alt"><br>不过以上的推理都是理论的感受野，并不是在卷积过程中真正的感受野。由于在卷积过程中，事实上会有些节点重复编码到一个feature map的节点中，这样该节点对feature map的这个节点贡献较大。所以并不是感受野中每个节点对feature map的某一节点影响是等同的。一般是呈现高斯分布（在感受野中间的节点值对该feature map的这个节点影响较大）。<br>来源：2016 NIPS 《Understanding the Effective Receptive Field in Deep Convolutional Neural Networks》<br>一个本人觉得讲的不错解释：<br><a href="https://zhuanlan.zhihu.com/p/40267131" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40267131</a><br>3.3 空洞卷积与卷积的区别<br>普通卷积也可以增加感受野，通常由两种操作：<br>a.卷积后增加池化层<br>b.卷积加stride<br>a操作的缺点在于池化层增加参数和计算的复杂度，而且损失了更多的信息。<br>b操作的缺点在于加入stride后，感受野的增加是延迟的。不能在当前层起效。比如说你当前进行stride=2的卷积，那么想要增加感受野，必须在这之后再加一层卷积，这层卷积后得到feature map比原来经过stride=1卷积后在卷积的feature map感受野大。<br>而空洞卷积则不存在上述问题，即空洞能及时的进行感受野增大，能保证用较小的参数、损失较小的信息实现feature map的感受野的增加增加。<br>五、depthwise卷积、pointwise卷积<br>首先我们要知道常规卷积的操作是怎么样，如下图所示：<br><img src="/images/神经网络-1/figure11.png" alt="alt"><br>而事实上，我们可以拆分成两步：Depthwise Convolution与Pointwise Convolution。<br>首先是Depthwise Convolution：<br>如下图所示，有多少个input_channel，就有多少个深度卷积核(channel都是1)，且每个深度卷积核只和对应的channel的输入进行卷积。<br><img src="/images/神经网络-1/figure12.png" alt="alt"><br>而后是Pointwise Convolution:<br><img src="/images/神经网络-1/figure13.png" alt="alt"><br>如下图所示，output_channel = filter_count，而每一个卷积核的size为1 x 1 x input_channel。<br>可以发现：原来参数个数为：$3 \times 3 \times 3 \times 4 = 108$<br>而现在的参数: $3 \times 3 \times 3 + 1 \times 1 \times 4 = 31 $<br>参数近乎减少到原来的1/3，让我们再来看卷积的计算次数（只关注乘法，因为乘法消耗的CPU or GPU时间周期更大）：<br>原来： $origincnt =  H \times W \times 4 \times 3 \times 3 $<br>而现在：$curcnt = H \times W \times 3 \times 3 \times 3 + H \times W \times 4 \times 1 \times 1 $<br>乘法次数大幅度减少。<br>这样能够大幅度减少参数和卷积次数，大大降低时间复杂度和空间复杂度。是一种优化的方式。<br>六、其他卷积<br>部分卷积<br>最早是由ECCV 2018年的一篇论文《Image Inpainting for Irregular Holes Using Partial Convolutions》。由NVIDIA提出来一种概念，他们团队认为普通卷积没有考虑每个节点对该区域影响权重，而错误将每个节点视为等同，这样容易导致填补过程的歧义（我口胡的：可以理解为动态规划的具有后效性，比如说当前有缺失像素A和缺失像素B，卷积核先利用缺失像素B的信息先将缺失像素A进行补洞，而后利用缺失像素A的信息再对缺失像素B进行补洞，这样容易混乱，如果我们加入权值，就可以令B像素对A像素填充权重更小以避免这钟情况的发生。），这因为这种特性，所以可以使用部分卷积有利于对非规则区域的像素进行填充。（因为如果直接卷积，容易导致补洞的过拟合，如把很多没用的区域考虑进去了，出现模糊的现象。）<br>具体方法如下：<br><img src="/images/神经网络-1/figure9.png" alt="alt"><br><img src="/images/神经网络-1/figure10.png" alt="alt"><br>门卷积<br>是在部分卷积上的改进版本。由Yu、Adobe Research、ByteDance Research的团队在ICCV(oral)《Free-Form Image Inpainting with Gated Convolution》提出来一项技术。Yu认为部分卷积并不能很准确区分那些像素是有效的，那些像素对该区域的语义信息编码、或者是补洞是有效的。例如说下面两个Patch，在部分卷积中则会视为等同：</p><script type="math/tex; mode=display">\begin {pmatrix}     1 & 1 & 1 \\     1 & 1 & 1\\     1 & 1 & 1 \end {pmatrix}</script><script type="math/tex; mode=display">\begin {pmatrix}     0 & 0 & 0 \\     0 & 0 & 1\\     0 & 0 & 1 \end {pmatrix}</script><p>其中0表示missing pixel，而1表示known pixel。很明显上面的区域更容易看成（编码）一个known region，对补洞的贡献更大。而下面的区域更容易被编码成unkown region，对补洞贡献要小一些，而在部分卷积中这两者是等同，明显不合理，当然作者还举了其他不合理的地方，这里不一一列出了。（大概在文中Introduction的第四段）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;烂笔头疗法，学习下神经网络的卷积部分，（只是理论部分，改天有时间实操几个问题。。&lt;br&gt;
    
    </summary>
    
      <category term="神经网络，machine learning" scheme="http://yoursite.com/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%8Cmachine-learning/"/>
    
    
      <category term="神经网络，machine learning" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%8Cmachine-learning/"/>
    
  </entry>
  
  <entry>
    <title>C++ 网络编程（一） --- 初识socket</title>
    <link href="http://yoursite.com/2020/04/21/winsock-1/"/>
    <id>http://yoursite.com/2020/04/21/winsock-1/</id>
    <published>2020-04-21T06:07:43.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周组会真的是灾难，还得要优化代码，真是难受。。。<br><a id="more"></a><br>一、背景<br>1.1 OSI、TCP/IP网络模型<br><img src="/images/winsock-1/figure1.png" alt="alt"><br>越高层服务对象越高，低级服务交给底层去完成，这样每一层只需要关注自己即可。<br>1.2 网络编程位置<br><img src="/images/winsock-1/figure2.png" alt="alt"><br>可以看到Socket网络编程主要是为传输层和网络层服务。<br>传输层：端到端的传输方式。（即主机应用程序之间的传输方式）。协议主要有面向连接的TCP和面向无连接的UDP协议。<br>网络层：点到点的通信，通过路由选择算法，选择合适路径，经由多个路由器之后，传输到目的节点的网络上。再由数据链路层和物理层传递到对应的主机（MAC地址）上。<br>也就是说SOCKET编程能够实现进程和进程之间面向连接和面向无连接的功能。<br><img src="/images/winsock-1/figure3.png" alt="alt"><br>二、什么是Socket<br>2.1 Socket的概念<br>首先先得说明一个故事，简单说明网络通信的过程。<br>假设有一个家庭A，成员有小明、小花、小聪。每个人都有一个自己发送和接收邮箱。每个人只能读取自己邮箱的文件。<br>家庭B，成员有小哥、小弟两人，同样每个人也有一个自己的发送和接收邮箱。<br>家庭A位于H区。家庭B位于S区。<br>如果小明想和小哥通信。那会经历以下几个过程。<br>a.首先将写好的信件，放入自己发送邮箱中。<br>b.然后通知快递员来拿，快递员先将邮件传到H区的传输中心。<br>c.接着再由汽车，经由Q区、W区、I区（H区与S区的最短路径）传输中心，达到S区传输中心。<br>d.接下来再通知S区快递员，让S区快递员将邮件送入到家庭B对应小哥的接收邮箱中。<br>这实际上类似于网络通信的过程。<br>家庭A，家庭B ——&gt; 主机。<br>小明，小花，小聪，小哥，小弟 ——&gt; 进程。<br>发送邮箱，接收邮箱 ——-&gt; 端口。<br>H区、Q区、W区、I区、S区传输中心 —-&gt; 网关和路由器。<br>汽车 —-&gt; 网络层的传输的过程。<br>快递小哥 ——&gt; 数据链路层，物理层传输到网关的过程。<br>从网络通信的角度理解，这里socket指的是端口，即发送邮箱和接收邮箱，进程只需要把数据交付给邮箱，他可以选择如何交付，比如说加急交付等。这是他可以操作的过程。但是传输的过程并不是由他控制。而是由快递员和汽车（操作系统、线路等等控制）。<br>简单的说，socket通过将IP地址和端口号绑定起来，用来唯一表示主机中的进程通信的端口。是应用层和传输层之间的端口（API）。<br>从操作系统角度理解，socket指的是操作系统类似文件的一种资源。用句柄表示。<br>2.2 socket的好处<br>1）方便调试。（只需要关注进程，传输交由操作系统）<br>2）方便编写代码。（只需要关注进程，传输交由操作系统）<br>3）屏蔽了底层复杂的网络操作。<br>2.3 socket的种类<br>一共分为三种：字节流套接字（TCP）、数据报套接字（UDP）、原始套接字（IP）。<br>三、初识winsocket<br>3.1 认识头文件 ——— winsock.h<br>导入投文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br></pre></td></tr></table></figure><br>注意：在Visual studio中需要导入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> commet(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></span><br></pre></td></tr></table></figure><br>第二个目的可以简单解释下：主要和程序的编译运行相关。<br>.h 文件指明了函数接口在哪？ —- 编译需要用<br>.lib 文件指明了链接器调用的函数在哪个dll中 —- 链接时需要用<br>.dll 可执行代码 —- 运行时用。<br>在程序中必须依次指定这三个文件的路径，否则无法正确执行。<br>3.2 初始化winsocket<br>WSAStartup (WORD wVersionRequested,LPWSADATA lpWSAData)<br>(1)wVersionRequested: 高阶字节指定小版本（修订本）号，低位字节指定主版本号。这里的版本号指的都是socket的版本号。<br>Eg.WORD sockVersion = MAKEWORD(minorVer, majorVer); //其中minorVer = majorVer = 2，表示采用winsock2的API。<br>(2)IpWSAData指定WSADATA数据结构的指针，用来接收Window sockets实现的细节（即dll库中的细节）。在WSAStartup调用后将对WSAdata进行一次初始化。<br>WSADATA的结构具体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">WSAData</span> &#123;</span></span><br><span class="line">   WORDwVersion;   <span class="comment">// 库文件建议应用程序使用的版本</span></span><br><span class="line">   WORDwHighVersion;    <span class="comment">// 库文件支持的最高版本</span></span><br><span class="line">   <span class="keyword">char</span>szDescription[WSADESCRIPTION_LEN+<span class="number">1</span>];  <span class="comment">// 库描述字符串</span></span><br><span class="line">   <span class="keyword">char</span>szSystemStatus[WSASYS_STATUS_LEN+<span class="number">1</span>];  <span class="comment">// 系统状态字符串</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span>iMaxSockets;       <span class="comment">// 同时支持的最大套接字的数量</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span>iMaxUdpDg;       <span class="comment">// 2.0版中已废弃的参数</span></span><br><span class="line">   <span class="keyword">char</span>  *lpVendorInfo;       <span class="comment">// 2.0版中已废弃的参数</span></span><br><span class="line">&#125; WSADATA,  * LPWSADATA;</span><br></pre></td></tr></table></figure><br>(3)返回值：整型，成功返回0.不成功则返回以下错误码：<br>(这里注意：不能使用GetLastError()得到错误的信息。)<br>a.WSASYSNOTREADY: 当前网络还没有准备好进行通信<br>b.WSAVERNOTSUPPORTED：套接字无法支持此应用程序。<br>c.WSAEPROCLIM：任务数超过winsock的支持上限。（这块怀疑是和iMaxSockets有关系）。<br>d.WSAEFAULT：WSAdata是一个非法的指针。<br>(4)函数的功能：此函数被调用的时，可以通过所设置的环境变量找到winsock.dll文件;检查winsock.dll的版本号是否符合要求，符合则返回0（盲猜不符合返回WSAVERNOTSUPPORTED）;实现winsock和应用程序绑定（这块可以理解为编译链接运行的过程）。<br>3.3 终止Winsock<br>int WSACleanup(void)函数<br>(1)参数是void,这点和WSAStartup不同<br>(2)返回值：整型，0表示成功失败返回SOCKETERROR，注意这里可以GetLastError()得到错误信息（这是与WSAStartup的第二个不同点）。<br>(3)函数的功能：中止对WinSock.dll的调用，释放引用动态链接库时占用的系统资源。<br>3.4 创建套接字<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; </span><br></pre></td></tr></table></figure><br>domain：表示的地址族，WinSock可支持AF_INET（IPV4）。<br>type：用以指定套接字的类型，刚刚也提到过了，一般包括三种类型：<br>a.SOCK_STREAM<br>流套接字，为TCP提供有连接的可靠传输。<br>b.SOCK_DGRAM<br>数据报套接字，使用UDP提供无连接的不可靠传输。<br>c.SOCK_RAW<br>原始套接字，提供底层IP的接口。<br>protocol:指定使用的协议，如IPPROTO_TCP，值得注意的是当type指为SOCK_STREAM和SOCK_DGRAM时的时候，<strong>实际上protocol也被指定了，此时我们可以将值设置为0</strong>。<br>返回值：函数执行失败返回INVALID_SOCKET（即-1），可以通过调用WSAGetLastError取得错误代码。<br><strong>值得注意的是：SOCK类型是一个整型描述符（句柄），是一个指向内部数据结构的指针，我们在后期调用的时候导入这个整型描述符，相当于控制和操作这个socket</strong><br>3.5 关闭套接字<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closesocket</span><span class="params">(SOCKET s)</span></span>; <span class="comment">// 参数是要关闭的套接字的句柄 </span></span><br></pre></td></tr></table></figure><br>3.6 绑定套接字到指定IP地址<br>首先要明白Winsock的寻址方式是怎么样的，由于要兼容多个协议，所以我们需要设计一个通用的数据结构存储这个地址。这个通用的数据结构就是sockaddr。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">u_short sa_family;  <span class="comment">//地址家族，AF_xx</span></span><br><span class="line"><span class="keyword">char</span>sa_data[<span class="number">14</span>];  <span class="comment">//14个字节的协议地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在介绍下sockaddr_in。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"><span class="keyword">short</span>sin_family;  <span class="comment">//地址家族，eg.AF_INET,AF_INET6</span></span><br><span class="line">u_short sin_port;    <span class="comment">//端口号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//用于存储IP地址，这个等下详细介绍下</span></span><br><span class="line"><span class="keyword">char</span>sin_zero[<span class="number">8</span>];  <span class="comment">//填充字节使得sockaddr_in和sockaddr保持大小。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>注意到这里还有一个in_addr的结构体，主要是用于存储IP地址，其结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> u_char s_b1,s_b2,s_b3,s_b4; &#125; S_un_b;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> u_short s_w1,s_w2; &#125; S_un_w;</span><br><span class="line">u_long S_addr;</span><br><span class="line">&#125; S_un;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_addr  S_un.S_addr     <span class="comment">/* can be used for most tcp &amp; ip code */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_host  S_un.S_un_b.s_b2<span class="comment">/* host on imp */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_net   S_un.S_un_b.s_b1 <span class="comment">/* network */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_imp   S_un.S_un_w.s_w2<span class="comment">/* imp */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_impno S_un.S_un_b.s_b4<span class="comment">/* imp # */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_lh    S_un.S_un_b.s_b3 <span class="comment">/* logical host */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>难点： 1）区分sockaddr、sockaddr_in、in_addr<br>一般来说sockaddr和sockaddr_in的包含数据内容是一致，但是能够操作这两个结构体的对象不一样，sockaddr一般是在accept,getsockname之类函数中使用，而sockaddr_in则是用户进行操作和修改。一般来说我们需要先对sockaddr_in赋值，在使用函数的时候可能需要将sockaddr_in强制转化为sockaddr,以便于使用。<strong>这里我的理解是，填充的时候要按照具体规则来，而调用的函数的时候，不同的协议的处理方式可能具有相似性，如果重写函数的话，似乎太浪费空间和笔墨，所以统一用sockaddr作为接口，处理的时候，我们需要将sockaddr_in转化为sockaddr进行处理。</strong><br>而in_addr则表示sockaddr中地址参数。三者关系如下图所示：<br><img src="/images/winsock-1/figure4.png" alt="alt"><br>2）如何给in_addr赋值<br>首先要地址是以什么样的顺序存入数据结构中。TCP/IP统一规定使用大端传输数据，也称为网络字节顺序。<strong>上述sockaddr和sockaddr_in除了sin_family（不是协议的一部分），其他所有值都要按网络字节顺序存储。</strong><br>注：大端存储是什么，就是将高位数据存储到低位空间中。<br>eg.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">servAddr.sin_addr.S_un.S_addr = inet_addr(<span class="string">"127.0.0.1"</span>); </span><br><span class="line"><span class="built_in">sin</span>.sin_addr.S_un.S_addr = htonl(INADDR_ANY);<span class="comment">//(ULONG)0x00000000</span></span><br></pre></td></tr></table></figure><br>简单介绍以上两种赋值方式：<br>inet_addr：可以将点分十进制的字符串转换为为一个长整型的数。<br>htonl: 可以将32位字节顺序转化为网络的字节顺序，刚刚也提到了除了sin_family，其他的值全部要按照网络的字节顺序来存储。<br>附：INADDR_ANY表示转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。一般服务器会使用INADDR_ANY。<br>其他函数还有htons、htonl、ntohs、ntohl等。不再赘述。（太懒了，逃<br>回到如何将套接字绑定到指定网络地址上，一般我们是用connect()或者listen()函数调用。值得注意的是在服务端，用于监听客户端连接请求套接字一定要绑定，而客户端不一定需要绑定。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    SOCKET s,        <span class="comment">//socket的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct sockaddr *  name,  <span class="comment">//网络地址，之前介绍那些，不过我们只能对sockaddr_in赋值，如果使用需要强制转化sockaddr_in变成sockaddr处理</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> namelen                     <span class="comment">//sockaddr的长度，直接sizeof(name)就ojbk</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br>返回值：成功为0，否则是SOCKET_ERROR。<br>3.7 设置套接字进入监听状态<br>条件：字节流套接字，服务端，是一种被动连接模式。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> listen（</span><br><span class="line">SOCKET s,     <span class="comment">/*已绑定的套接字句柄*/</span></span><br><span class="line"><span class="keyword">int</span> backlog  <span class="comment">/*等待连接队列长度*/</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>3.8 接收连接请求<br>从监听套接字的等待队列中抽取连接请求，建立新的套接字与该客户端的套接字建立连接，交换数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SOCKET s,                   <span class="comment">//服务端处的监听套接字</span></span></span></span><br><span class="line"><span class="function"><span class="params">struct sockaddr* addr,  <span class="comment">//出口参数，客户端地址结构</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span>* addrlen                   <span class="comment">//出口参数，客户端地址长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br>返回值：如果连接成功返回新的套接字描述符，否则返回INVALID_SOCKET。<br>3.9 请求连接函数<br>客户端请求与服务端建立连接。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    SOCKET s,   <span class="comment">//客户端的套接字</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct sockaddr *  name, <span class="comment">//客户端的地址结构</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> namelen    <span class="comment">//客户端的sockaddr长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br>返回值：成功返回0，否则返回SOCKET_ERROR。<br>根据3.7 ~ 3.9节内容，我们可以对客户端的状态进行总结。<br>when 客户端发出connect（请求连接） —-&gt; 服务端则会监听到该连接，将会采取三个动作： 1）TCP三次握手成功后，调用accept函数，然后讲该连接丢入已连接队列中。 2）将其丢入到等待连接队列中。 3）将其扔出去。<br>（具体三次握手下细化的状态转移问题，我想等学习了三次握手再说，先甩一个感觉不错链接：<br> <a href="https://blog.csdn.net/kongxian2007/article/details/49153801" target="_blank" rel="noopener">https://blog.csdn.net/kongxian2007/article/details/49153801</a><br>3.10 收发数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    SOCKET s,   <span class="comment">//若是服务器，则该选项是accpet建立对应的套接字。客户端则为建立连接的套接字</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>  * buf, <span class="comment">//发送数据的缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> len,         <span class="comment">//缓冲区中的数据长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> flags        <span class="comment">//调用执行方式，一般置为0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br>返回值<br>成功：返回实际发送的字节数<br>失败：返回SOCKET_ERROR<br><strong>请注意send的成功调用并不代表数据发送成功，仅仅表示能成功送入缓冲区</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    SOCKET s,   <span class="comment">//建立连接套接字</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> * buf, <span class="comment">//接收缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> len,    <span class="comment">//缓冲区长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> flags   <span class="comment">//选项，一般为0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br>返回值：<br>成功：返回实际接收的字节数<br>连接已终止：0<br>失败：返回SOCKET_ERROR<br>下面的代码很有可能会出现一个问题，如果是循环接收服务端发送的数据，如果接收到的是这样数据：<br>aaaa<br>aaa<br>bbbb<br>实际上客户端接收的是：<br>aaaa<br>aaa<br>bbb<br>最后一个数据少了b，这是因为第三个参数在每一次调用前都在发生变化，从4到3，所以导致第三次接收缓冲区只能接收”bbb”。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nRecv = recv(s, buff, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><br>正确的写法可以是这样：定义一个常数即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nRecv = recv(s, buff, <span class="number">256</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>实验：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// TCPServer.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> commet(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/InitSock.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">CInitSock initSock;<span class="comment">// 初始化Winsock库</span></span><br><span class="line">sockaddr_in server, client;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WORD ws_version = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA wsaData;</span><br><span class="line">WSAStartup(ws_version,&amp;wsaData);</span><br><span class="line"><span class="comment">// 创建套节字</span></span><br><span class="line">SOCKET sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (sListen == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed socket() \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充sockaddr_in结构</span></span><br><span class="line">sockaddr_in <span class="built_in">sin</span>;</span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(<span class="number">4567</span>);</span><br><span class="line"><span class="built_in">sin</span>.sin_addr.S_un.S_addr = htonl(INADDR_ANY);<span class="comment">//(ULONG)0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//output 1 Create</span></span><br><span class="line"><span class="keyword">int</span> server_len = <span class="keyword">sizeof</span>(server);</span><br><span class="line">getsockname(sListen, (sockaddr *)&amp;server, &amp;server_len);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the Create Stage of Socket IP:"</span> &lt;&lt; inet_ntoa(server.sin_addr) &lt;&lt; <span class="string">":"</span> &lt;&lt; ntohs(server.sin_port) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定这个套节字到一个本地地址</span></span><br><span class="line"><span class="keyword">if</span> (bind(sListen, (LPSOCKADDR)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed bind() \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output 2 Bind</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="keyword">sizeof</span>(server));</span><br><span class="line">server_len = <span class="keyword">sizeof</span>(server);</span><br><span class="line">getsockname(sListen, (sockaddr *)&amp;server, &amp;server_len);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the Bind Stage of Socket IP:"</span> &lt;&lt; inet_ntoa(server.sin_addr) &lt;&lt; <span class="string">":"</span> &lt;&lt; ntohs(server.sin_port) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入监听模式</span></span><br><span class="line"><span class="keyword">if</span> (listen(sListen, <span class="number">2</span>) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed listen() \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output 3 listen</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="keyword">sizeof</span>(server));</span><br><span class="line">server_len = <span class="keyword">sizeof</span>(server);</span><br><span class="line">getsockname(sListen, (sockaddr *)&amp;server, &amp;server_len);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the Listen Stage of Socket IP:"</span> &lt;&lt; inet_ntoa(server.sin_addr) &lt;&lt; <span class="string">":"</span> &lt;&lt; ntohs(server.sin_port) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环接受客户的连接请求</span></span><br><span class="line">sockaddr_in remoteAddr;</span><br><span class="line"><span class="keyword">int</span> nAddrLen = <span class="keyword">sizeof</span>(remoteAddr);</span><br><span class="line">SOCKET sClient;</span><br><span class="line"><span class="keyword">char</span> szText[] = <span class="string">" TCP Server Demo! \r\n"</span>;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 接受一个新连接</span></span><br><span class="line">sClient = accept(sListen, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrLen);</span><br><span class="line"><span class="keyword">if</span> (sClient == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed accept()"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="keyword">sizeof</span>(server));</span><br><span class="line">server_len = <span class="keyword">sizeof</span>(server);</span><br><span class="line">getsockname(sListen, (sockaddr *)&amp;server, &amp;server_len);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the accept Stage of Socket IP:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server IP:"</span> &lt;&lt; inet_ntoa(server.sin_addr) &lt;&lt; <span class="string">":"</span> &lt;&lt; ntohs(server.sin_port) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span>(client));</span><br><span class="line"><span class="keyword">int</span> client_len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">getsockname(sClient, (sockaddr *)&amp;client, &amp;client_len);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Client IP:"</span> &lt;&lt; inet_ntoa(client.sin_addr) &lt;&lt; <span class="string">":"</span> &lt;&lt; ntohs(client.sin_port) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 接受到一个连接：%s \r\n"</span>, inet_ntoa(remoteAddr.sin_addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向客户端发送数据</span></span><br><span class="line">send(sClient, szText, <span class="built_in">strlen</span>(szText), <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 关闭同客户端的连接</span></span><br><span class="line">closesocket(sClient);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭监听套节字</span></span><br><span class="line">closesocket(sListen);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// TCPClient.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> commet(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/InitSock.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">CInitSock initSock;<span class="comment">// 初始化Winsock库</span></span><br><span class="line">sockaddr_in client;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WORD ws_version = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA wsaData;</span><br><span class="line">WSAStartup(ws_version, &amp;wsaData);</span><br><span class="line"><span class="comment">// 创建套节字</span></span><br><span class="line">SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (s == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Failed socket() \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以在这里调用bind函数绑定一个本地地址</span></span><br><span class="line"><span class="comment">// 否则系统将会自动安排</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 填写远程地址信息</span></span><br><span class="line">sockaddr_in servAddr;</span><br><span class="line">servAddr.sin_family = AF_INET;</span><br><span class="line">servAddr.sin_port = htons(<span class="number">4567</span>);</span><br><span class="line"><span class="comment">// 注意，这里要填写服务器程序（TCPServer程序）所在机器的IP地址</span></span><br><span class="line"><span class="comment">// 如果你的计算机没有联网，直接使用127.0.0.1即可</span></span><br><span class="line">servAddr.sin_addr.S_un.S_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"><span class="keyword">int</span> client_len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">getsockname(s, (sockaddr *)&amp;client, &amp;client_len);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the Create Stage of Socket IP:"</span> &lt;&lt; inet_ntoa(client.sin_addr) &lt;&lt; <span class="string">":"</span> &lt;&lt; ntohs(client.sin_port) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (connect(s, (sockaddr*)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Failed connect() \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span>(client));</span><br><span class="line">client_len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">getsockname(s, (sockaddr *)&amp;client, &amp;client_len);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the Create Stage of Socket IP:"</span> &lt;&lt; inet_ntoa(client.sin_addr) &lt;&lt; <span class="string">":"</span> &lt;&lt; ntohs(client.sin_port) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> nRecv = recv(s, buff, <span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nRecv &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">buff[nRecv] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 接收到数据：%s"</span>, buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭套节字</span></span><br><span class="line">closesocket(s);</span><br><span class="line">WSACleanup();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周组会真的是灾难，还得要优化代码，真是难受。。。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>概率图模型学习1 --- 初入概率图</title>
    <link href="http://yoursite.com/2020/04/11/%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B-%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%AD%A6%E4%B9%A01/"/>
    <id>http://yoursite.com/2020/04/11/概率图模型-马尔科夫学习1/</id>
    <published>2020-04-11T12:23:40.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节复习之前打过一种类型的ACM题，概率图模型。也是为之后的马尔科夫随机场、条件马尔科夫随机场、隐式马尔科夫做准备。<br><a id="more"></a><br>HDU 5955<br>题意很简单，就是一群人坐在一起，这群人给出一个长度为N的序列（序列的每一个数是1~6中的一个），扔无数次色子直到其中一个序列出现为止。然后让你判断每一个人猜中的概率是多少。<br>题解：<br>在此之前，得介绍一种数据结构，叫AC自动机。简单下介绍一下：<br>给出四个单词：”ABC”、”BD”、”BCD”、”C”<br>首先建立字典树，如下图所示：<br><img src="/images/概率图模型1/AC自动机.png" alt="alt"><br>fail指针是如何建立的：<br>首先fail指针建立的目的就是为了剪枝，我们不希望我匹配失误后，还要跳回根节点继续匹配，我们希望能够一个前缀使得它和当前我们失配的后缀是相同，这样我们只需要把失配后缀的最后元素指向前缀最后的元素继续匹配就行。<br>这里针对第四层叶子节点C来说，即上图的4号节点的fail指针。4号节点匹配到“ABC”单词的最后，明显属于失配的节点（因为没发继续往下走了。），我们发现”ABC“的后缀“BC”和“BCD”前缀”BC“是相同的，且我们发现”ABC“的后缀“C”和“C”前缀”C“也是相同的，那么我们应该选择哪个，这里采用一个贪心的策略，每次寻找较大的后缀，故最后fail指针会指向7号节点。<br>那么这里就有一个问题，在于怎么样是最大的后缀呢，我们发现可以从父亲节点失配节点寻找是否有一个儿子节点值和该失配节点相同。在这个例子中，4号节点的父亲节点是3，,3的fail指针是5，那么我们只要检查5号节点是否存在一个儿子节点的值是C，即7号节点。<br>如果我们每一个节点都按照上述策略去匹配，必然能保证我们每次失配寻找都是一个最大后缀。当这个最大后缀不满足我们会继续找一个次大的最大后缀，直至所有后缀找完。<br><img src="/images/概率图模型1/AC自动机1.png" alt="alt"><br>给一个乱搞的解法，也是现场很多人过的解法：AC自动机+矩阵快速幂。<br>首先考虑一个简单的情况，分别给出两个序列：“1234” “2345”，最多扔6次（不是无数次），两个人猜中的概率是多少。<br>首先根据给出序列建立AC自动机：<br><img src="/images/概率图模型1/AC自动机2.png" alt="alt"><br>设出现“1234”序列为事件A，“2345”为事件B，扔了i次为事件$ Q_i $，那么A事件发生概率为</p><script type="math/tex; mode=display">P(A) = \sum_{i=4}^6 P(A \bigcap Q_{i})</script><p>同理B事件发生的概率为</p><script type="math/tex; mode=display">P(B) = \sum_{i=4}^6 P(B \bigcap Q_{i})</script><p>但是我们发现这样算似乎有点繁琐，因为我们想要得到最多六次的结果，就得计算3次概率再相加。我们希望能不能只用算一次就能得到结果。仔细思考，当我们第四次投掷出一个序列的时候，实际上第五次、第六次结果是什么都不关心了。于是我们可以把第四次就投掷出序列“1234” 等价于 6次投掷出“1234xy”,其中$x,y \in [1,6] $，同理五次投掷出序列”1234”可以看成”x1234y”。于是我们可以把式子改成：</p><script type="math/tex; mode=display">P(A) = \sum_{x=1}^6 \sum_{y=1}^6 P(1234xy) + \sum_{x=1}^6 \sum_{y=1}^6 P(x1234y)</script><p>但是在上一个AC自动机中，当我们投掷出“1234”的4的时候，根据fail指针，如果下一个是5，那么我们将跳转到“2345”的5,这样会出现歧义。为了避免这样的歧义出现，我们需要对AC自动机进行一个个小小调整：<br><img src="/images/概率图模型1/AC自动机3.png" alt="alt"><br>这样不管下一次投掷的是什么，我都会继续跳转到4这个节点。同理当我投掷出”2345”这个序列的时候，我也会跳转到5。防止歧义的出现。（从这里看出4和5的自连接的条件概率是100%）<br>那么接下来我们只需要利用概率DP求解这个问题就可以了，转移方程为</p><script type="math/tex; mode=display">dp[i][k] = dp[i][k] + \frac{1}{6} \times dp[j][k-1] , (j,i) \in E</script><p>求解6次即可。<br>接下来我们回到本节问题，本节问题是求无穷次，无穷次不好办啊，但是实际上我们发现当我们迭代到一定次数的时候，结果会慢慢收敛到某一个值，也就是说当给定精度要求，我们并不需要迭代无数次，只需要迭代有限次的次数。<br>PS:这个确实不知道为啥？本还以为是马尔科夫的细致平稳条件，但看了下细致平稳的条件的要求，似乎本题不满足任意状态可达的要求。看来这个做法确实有点乱搞乱来的感觉。。。（2333）<br>这个题，大概应该是在$2^{30}$左右的时候，精度就够了，当然肯定是不能循环这么多次，直接就用矩阵快速幂就可以做完这个题了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 135</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][<span class="number">7</span>],fail[MAXN],ed[MAXN];</span><br><span class="line">    <span class="keyword">int</span> root,L,cnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">            next[L][i]=<span class="number">-1</span>;</span><br><span class="line">        ed[L++]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> L<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        L=<span class="number">0</span>;</span><br><span class="line">        root=newnode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> *buf,<span class="keyword">int</span> len)</span>          </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> id=buf[i];</span><br><span class="line">            <span class="keyword">if</span>(next[now][id]==<span class="number">-1</span>)</span><br><span class="line">                next[now][id]=newnode();</span><br><span class="line">            now=next[now][id];</span><br><span class="line">        &#125;</span><br><span class="line">        ed[now]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        fail[root]=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i]==<span class="number">-1</span>)</span><br><span class="line">                next[root][i]=root;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                fail[next[root][i]]=root;</span><br><span class="line">                q.push(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(ed[fail[now]])</span><br><span class="line">                ed[now]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i]==<span class="number">-1</span>)</span><br><span class="line">                    next[now][i]=next[fail[now]][i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fail[next[now][i]]=next[fail[now]][i];</span><br><span class="line">                    q.push(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie AC;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> mat[MAXN][MAXN];</span><br><span class="line">&#125;;</span><br><span class="line">Matrix unit;</span><br><span class="line">Matrix <span class="keyword">operator</span> *(Matrix a,Matrix b)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix ans;</span><br><span class="line">    <span class="built_in">memset</span>(ans.mat,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans.mat));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</span><br><span class="line">                ans.mat[i][j]=(ans.mat[i][j]+a.mat[i][k]*b.mat[k][j]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,len;</span><br><span class="line"><span class="keyword">int</span> buf[MAXN];</span><br><span class="line">Matrix tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)unit.mat[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;len);</span><br><span class="line">        AC.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;buf[j]);</span><br><span class="line">            AC.Insert(buf,len);</span><br><span class="line">        &#125;</span><br><span class="line">        AC.build();</span><br><span class="line">        <span class="built_in">memset</span>(tmp.mat,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp.mat));</span><br><span class="line">        N=AC.L;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(AC.ed[i])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.mat[i+<span class="number">1</span>][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">6</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> id=AC.next[i][j];</span><br><span class="line">                tmp.mat[i+<span class="number">1</span>][id+<span class="number">1</span>]+=<span class="number">1.0</span>/<span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;i++)</span><br><span class="line">            tmp=tmp*tmp;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(AC.ed[i])</span><br><span class="line">                cnt++,<span class="built_in">printf</span>(<span class="string">"%.6f%c"</span>,tmp.mat[<span class="number">1</span>][i+<span class="number">1</span>],cnt==n?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来介绍这个题普遍流传的解法：AC自动机+高斯消元。<br>首先说明下高斯消元的合理性：<br>首先考虑一个简单的情况，分别给出两个序列：“12” “23”，然后我们由此建立AC自动机，如下：<br><img src="/images/概率图模型1/AC自动机4.png" alt="alt"><br>我们发现这个AC自动机有个特点在于任意节点互相可达，这样则会满足马尔科夫的细致平稳条件，即$ \lim \limits_{N \to \infty} DP[i][N] = x_i $，最后会收敛一个值。<br>同样根据刚刚的推论，为了求解方便，我们同样需要把AC自动机改造下，这个时候我们只需要去掉”12”的2的fail指针。同时去掉”23”的3的fail指针。这样完成构造。刚刚已经说了这个结果是收敛，那么当$N \to \infty$时候，必然会满足下列式子：<br>（PS：左边”12”分别为1、2号节点，右边”23”分别为3、4号节点，其中注意的是由于概率和是1，所以我们需要指定一个常数1流入根节点。）</p><script type="math/tex; mode=display">\left\{\begin{aligned} a_{01} \times x_1 + a_{02} \times x_2 + a_{03} \times x_3 + a_{04} \times x_{4} &= x_0 \times -a_{00} - 1\\ a_{10} \times x_0 + a_{12} \times x_2 + a_{13} \times x_3 + a_{14} \times x_{4} &= x_1 \times -a_{11} \\ a_{20} \times x_0 + a_{21} \times x_1 + a_{23} \times x_3 + a_{24} \times x_{4} &= x_2 \times -a_{22} \\a_{30} \times x_0 + a_{31} \times x_1 + a_{32} \times x_2 + a_{34} \times x_{4} &= x_3 \times -a_{33} \\a_{40} \times x_0 + a_{41} \times x_1 + a_{42} \times x_2 + a_{43} \times x_{3} &= x_4 \times -a_{44}\end{aligned} \right.</script><p>其中，方程的增广矩阵如下：</p><script type="math/tex; mode=display">\left [    \begin {array} {ccccc|c}     a_{00} & a_{01} & a_{02} & a_{03} & a_{04} & -1\\     a_{10} & a_{11} & a_{12} & a_{13} & a_{14} & 0\\     a_{20} & a_{21} & a_{22} & a_{23} & a_{24} & 0\\     a_{30} & a_{31} & a_{32} & a_{33} & a_{34} & 0\\     a_{40} & a_{41} & a_{42} & a_{43} & a_{44} & 0    \end {array}\right ]</script><p>于是我们只需要模拟AC自动机求出A矩阵后，再利用高斯消元即可。<br>高斯消元：<br><a href="https://oi-wiki.org/math/gauss/" target="_blank" rel="noopener">https://oi-wiki.org/math/gauss/</a><br>（这个有时间再好好学习，先贴一个原来写的代码，写的很丑，凑合着看）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 135</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][<span class="number">7</span>],fail[MAXN],ed[MAXN];</span><br><span class="line">    <span class="keyword">int</span> root,L,cnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">            next[L][i]=<span class="number">-1</span>;</span><br><span class="line">        ed[L++]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> L<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        L=<span class="number">0</span>;</span><br><span class="line">        root=newnode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> *buf,<span class="keyword">int</span> len)</span>          </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> id=buf[i];</span><br><span class="line">            <span class="keyword">if</span>(next[now][id]==<span class="number">-1</span>)</span><br><span class="line">                next[now][id]=newnode();</span><br><span class="line">            now=next[now][id];</span><br><span class="line">        &#125;</span><br><span class="line">        ed[now]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        fail[root]=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i]==<span class="number">-1</span>)</span><br><span class="line">                next[root][i]=root;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                fail[next[root][i]]=root;</span><br><span class="line">                q.push(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(ed[fail[now]])</span><br><span class="line">                ed[now]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i]==<span class="number">-1</span>)</span><br><span class="line">                    next[now][i]=next[fail[now]][i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fail[next[now][i]]=next[fail[now]][i];</span><br><span class="line">                    q.push(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie AC;</span><br><span class="line"><span class="keyword">int</span> n,len;</span><br><span class="line"><span class="keyword">int</span> buf[MAXN];</span><br><span class="line"><span class="keyword">int</span> equ,var;</span><br><span class="line"><span class="keyword">double</span> a[MAXN][MAXN],x[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,col,max_r;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>,col = <span class="number">0</span>;k &lt; equ &amp;&amp; col &lt; var;k++,col++)</span><br><span class="line">    &#123;</span><br><span class="line">        max_r = k;</span><br><span class="line">        <span class="keyword">for</span>(i = k+<span class="number">1</span>;i &lt; equ;i++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][col]) &gt; <span class="built_in">fabs</span>(a[max_r][col]))</span><br><span class="line">                max_r = i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[max_r][col]) &lt; eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k != max_r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = col;j &lt; var;j++)</span><br><span class="line">                swap(a[k][j],a[max_r][j]);</span><br><span class="line">            swap(x[k],x[max_r]);</span><br><span class="line">        &#125;</span><br><span class="line">        x[k]/=a[k][col];</span><br><span class="line">        <span class="keyword">for</span>(j = col+<span class="number">1</span>;j &lt; var;j++)a[k][j]/=a[k][col];</span><br><span class="line">        a[k][col] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; equ;i++)</span><br><span class="line">            <span class="keyword">if</span>(i != k)</span><br><span class="line">            &#123;</span><br><span class="line">                x[i] -=  x[k]*a[i][k];</span><br><span class="line">                <span class="keyword">for</span>(j = col+<span class="number">1</span>;j &lt; var;j++)a[i][j] -= a[k][j]*a[i][col];</span><br><span class="line">                a[i][col] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;len);</span><br><span class="line">        AC.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;buf[j]);</span><br><span class="line">            AC.Insert(buf,len);</span><br><span class="line">        &#125;</span><br><span class="line">        AC.build();</span><br><span class="line">        <span class="keyword">int</span> N=AC.L;</span><br><span class="line">        <span class="comment">//printf("N=%d\n",N);</span></span><br><span class="line">        var=equ=AC.L;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="keyword">sizeof</span>(x));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)a[i][i]=<span class="number">-1</span>;</span><br><span class="line">        x[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(AC.ed[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">6</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> id=AC.next[i][j];</span><br><span class="line">                a[id][i]+=<span class="number">1.0</span>/<span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;N;i++)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            for(int j=0;j&lt;N;j++)</span></span><br><span class="line"><span class="comment">//                printf("%.6lf ",a[i][j]);</span></span><br><span class="line"><span class="comment">//            puts("");</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        Gauss();</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(AC.ed[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.6lf%c"</span>,x[i],cnt==n?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节复习之前打过一种类型的ACM题，概率图模型。也是为之后的马尔科夫随机场、条件马尔科夫随机场、隐式马尔科夫做准备。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/categories/ACM/machine-learning/"/>
    
      <category term="概率图" scheme="http://yoursite.com/categories/ACM/machine-learning/%E6%A6%82%E7%8E%87%E5%9B%BE/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="概率图" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>C ++ 多线程编程2 ——— 同步与互斥</title>
    <link href="http://yoursite.com/2020/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/04/07/多线程编程二/</id>
    <published>2020-04-07T12:04:21.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>突然看到一句很好的话，知人者智，自知者明。也算勉励自己吧。<br><a id="more"></a><br>1）创建一个信号量<br>创建信号量主要采用CreateSemaphore函数，函数原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateSemaphore</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes </span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      LONG lInitialCount, </span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      LONG lMaximumCount, </span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpName </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br>a.lpSemaphoreAttributes<br>这个参数应该算是老朋友了(详细见C++多线程编程1 —- 创建线程)，上个星期刚刚见过的，表示这个线程的安全属性是多少，如果为NULL表示默认的安全属性。<br>b.lInitialCount<br>表示信号量的初始值，取值范围为[0,lMaximumCount]。<br>c.lMaximumCount<br>表示该信号量的最大值。与b相对应。<br>d.lpName<br>表示信号量的名称。这里讲解下，LPCTSTR是指向常量字符串的长指针，等同于const TCHAR的指针。TCHAR主要取决你的工程代码中是否定义<strong>宏UNICODE</strong>有所不同。如果定义了UNICODE，TCHAR = wchar_t，否则是char。<br>返回值是指向信号量的句柄（这里体现了句柄不仅仅可以管理进程还可以管理其他的资源），<strong>如果创建信号量与已有信号量重名，那么返回已经存在的信号量句柄。</strong> （有待考察）。</p><p>2）打开信号量。<br>打开一个已有的信号量我们一般是用OpenSemaphore函数来进行。这个一般是通过名字打开一个信号量。函数原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenSemaphoreW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL    bInheritHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br>a.dwDesiredAccess<br>对该信号量的访问权，如果这个访问权不允许当前进程对这个信号量进行操作，那么这个函数执行将会失败。<br>b.bInheritHandle<br>是否被继承，如果为true，那么该线程创建的信号们将会继承已有的信号（不太清楚继承的是什么？），为false，则不会继承。<br>c.lpName<br>打开信号量的名字。<br><strong>更多请了解：</strong><br><strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-opensemaphorew" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-opensemaphorew</a></strong></p><p>3）获得信号占有权<br>3.1 WaitForSingleObject函数<br>在window操作系统中，线程具有两个非常重要的状态：“授信状态”、“非授信状态”。当进程处于非授信状态的时候，进程被阻塞，当处于授信状态时候，就相当于被唤醒。说白了这个操作就类似于PV操作的P操作，申请进入临界区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hObject, <span class="comment">//指明一个内核对象的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwMilliseconds)</span></span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><br>a.hObject<br>这个参数表示该进程在等待的信号量的句柄。<br>b.dwMilliseconds<br>表示需要等待的时间（单位为毫秒），可以传递INFINITE表示将无限等待下去。如果等待超时将返回WAIT_TIMEOUT,如果失败则返回WAIT_FAILED,正常执行返回WAIT_OBJECT_0。可以用switch case语句判断该进程的状况。<br>3.2 WaitForMultipleObjects函数<br>这个函数与之前的WaitForSingleObject函数最大不同在于，WaitForSingleObject人如其名，一个进程只能等待一个信号。而WaitForMultipleObjects函数可以实现一个进程等待多个信号的功能。函数的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD nCount, <span class="comment">// number of handles in the handle array</span></span></span></span><br><span class="line"><span class="function"><span class="params">CONST HANDLE *lpHandles, <span class="comment">// pointer to the object-handle array</span></span></span></span><br><span class="line"><span class="function"><span class="params">BOOL fWaitAll, <span class="comment">// wait flag</span></span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwMilliseconds <span class="comment">// time-out interval in milliseconds</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br>a.nCount<br>表示指定列表中句柄的数量，最大值为MAXIMUM_WAIT_OBJECTS（64）。<br>b.lpHandles<br>指定信号量列表的头指针。<br>c.fWaitAll<br>人如其名，表示是否等待全部的HANDLE发出指令，如果为true,则等到所有的HANDLE对该进程发出信号才能继续执行，否则只需要任何一个HANDLE对该进程发出信号即可。<br>d.dwMilliseconds<br>同上不解释了。<br>返回值：<br>WAIT_ABANDONED_0表示所有HANDLE都发出消息。这个和普通的WAIT_OBJECT_0不同在于：<strong>通常在WAIT_ABANDONED中都存在一个互斥量，即控制进程间的互斥关系（例如进程A和进程B间是互斥的访问共享变量a，那么就可以设置一个互斥的信号量），那么很有可能会出现一种情况，就是有一个进程意外终止了，但是他没有释放这个互斥量，这样我们就称为信号遗忘。</strong><br>WAIT_TIMEOUT表示超时。<br>WAIT_OBJECT_0表示所有HANDLE都发出消息。</p><p>4）信号量的释放<br>信号量的释放主要用ReleaseSemaphore函数来进行控制，与刚刚的两个函数WaitForSingleObject、WaitForMultipleObjects两个函数相对应，属于PV操作的V操作。函数的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReleaseSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      HANDLE hSemaphore,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      LONG   lReleaseCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_ LPLONG lpPreviousCount</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br>a.hSemaphore<br>表示释放的信号量的句柄。<br>b.lReleaseCount<br>简单说表示V操作释放多少次。或者这个互斥量释放了多少个。与创建进程的lInitialCount相对应。<br>c.lpPreviousCount<br>指向上一次计数结果的指针，不需要可以设置为NULL。</p><p>实战：<br>A.生产者消费者模型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> plate[<span class="number">10</span>];  <span class="comment">//表示盘子,P表示Proudct，N表示None，E表示吃</span></span><br><span class="line"><span class="keyword">int</span> p, e;</span><br><span class="line">HANDLE empty;   <span class="comment">//表示盘子中空的位置的信号量</span></span><br><span class="line">HANDLE mutex;  <span class="comment">//生产者消费者互斥访问盘子</span></span><br><span class="line">HANDLE full;   <span class="comment">//表示盘子中多余苹果的信号量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_status</span><span class="params">(DWORD flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> pflag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">switch</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0:</span><br><span class="line">pflag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line">pflag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fail to wait\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; GetLastError() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line">pflag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time out\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pflag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(HANDLE hSemp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD flag = WaitForSingleObject(hSemp, INFINITE); </span><br><span class="line"><span class="keyword">bool</span> pflag=get_status(flag);</span><br><span class="line"><span class="keyword">if</span> (!pflag)<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"P is fail!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(HANDLE hSemp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> pflag = ReleaseSemaphore(hSemp, <span class="number">1</span>, <span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span> (!pflag)<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"V is fail!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_plate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; plate &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_plate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">plate[i] = <span class="string">'N'</span>;</span><br><span class="line">plate[num] = <span class="string">'\0'</span>;</span><br><span class="line">show_plate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Product_Apple</span><span class="params">(LPVOID lpParamter)</span>     <span class="comment">//生产者进程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">P(empty);</span><br><span class="line">P(mutex);</span><br><span class="line">plate[(p++) % num] = <span class="string">'P'</span>;</span><br><span class="line">show_plate();</span><br><span class="line">V(mutex);</span><br><span class="line">V(full);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">cost_Apple</span><span class="params">(LPVOID lpParamter)</span>   <span class="comment">//消费者进程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">P(full);</span><br><span class="line">P(mutex);</span><br><span class="line">plate[(e++) % num] = <span class="string">'E'</span>;</span><br><span class="line">show_plate();</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">init_plate();  <span class="comment">//初始化盘子</span></span><br><span class="line"><span class="comment">//创建信号量</span></span><br><span class="line">empty = CreateSemaphore(<span class="literal">NULL</span>, num, num, <span class="literal">NULL</span>);  <span class="comment">//初始为3个空位，最多有3个空位。</span></span><br><span class="line">full = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">0</span>, num, <span class="literal">NULL</span>);</span><br><span class="line">mutex = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>);  <span class="comment">//互斥访问Apple变量</span></span><br><span class="line"><span class="comment">//创建进程</span></span><br><span class="line">HANDLE ThreadHandle[<span class="number">2</span>];</span><br><span class="line">ThreadHandle[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Product_Apple, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);  <span class="comment">//生产者子线程</span></span><br><span class="line">ThreadHandle[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, cost_Apple, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);     <span class="comment">//消费者子线程</span></span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>, ThreadHandle, TRUE, INFINITE);   <span class="comment">//这句话控制了主线程和子线程的同步关系</span></span><br><span class="line">Sleep(<span class="number">30000</span>);</span><br><span class="line">CloseHandle(empty);</span><br><span class="line">CloseHandle(full);</span><br><span class="line">CloseHandle(mutex);</span><br><span class="line">CloseHandle(ThreadHandle[<span class="number">0</span>]);</span><br><span class="line">CloseHandle(ThreadHandle[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果：<br><img src="/images/多线程2/res1.png" alt="alt"><br>坑点：如果不加WaitForMultipleObjects这个函数的话，主线程不会被阻塞，很可能先执行CloseHandle的函数，导致子线程或者信号量先被销毁了。若是信号量销毁则可能出现5号错误码（无法访问），6号错误码（非法的HANDLE）。<br>B.读者写者模型 —- 读者优先<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> plate[<span class="number">10</span>];  <span class="comment">//表示盘子,P表示Proudct，N表示None，E表示吃</span></span><br><span class="line"><span class="keyword">int</span> readcnt;</span><br><span class="line"><span class="keyword">int</span> ticket=<span class="number">6</span>;</span><br><span class="line">HANDLE mutex;<span class="comment">//控制读者间互斥，因为readcnt是共享变量</span></span><br><span class="line">HANDLE wr;<span class="comment">//控制读者和写者，写者和写者的互斥</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_status</span><span class="params">(DWORD flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> pflag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">switch</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0:</span><br><span class="line">pflag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line">pflag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fail to wait\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; GetLastError() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line">pflag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time out\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pflag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(HANDLE hSemp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD flag = WaitForSingleObject(hSemp, INFINITE);</span><br><span class="line"><span class="keyword">bool</span> pflag = get_status(flag);</span><br><span class="line"><span class="keyword">if</span> (!pflag)<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"P is fail!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(HANDLE hSemp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> pflag = ReleaseSemaphore(hSemp, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!pflag)<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"V is fail!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">reader</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">P(mutex);</span><br><span class="line"><span class="keyword">if</span> (readcnt == <span class="number">0</span>)</span><br><span class="line">P(wr);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"read Process ID"</span> &lt;&lt; GetCurrentThreadId() &lt;&lt; <span class="string">":"</span> &lt;&lt; ticket &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">readcnt++;</span><br><span class="line">V(mutex);</span><br><span class="line">P(mutex);</span><br><span class="line">readcnt--;</span><br><span class="line"><span class="keyword">if</span> (readcnt == <span class="number">0</span>)</span><br><span class="line">V(wr);</span><br><span class="line">V(mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">writer</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">P(wr);</span><br><span class="line">ticket--;<span class="comment">//票数-1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"writer Process ID"</span> &lt;&lt; GetCurrentThreadId() &lt;&lt; <span class="string">":"</span> &lt;&lt; ticket &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">V(wr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mutex = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">wr = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE ThreadHandle[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ThreadHandle[i] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, reader, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">ThreadHandle[i + <span class="number">2</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, writer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">WaitForMultipleObjects(<span class="number">4</span>, ThreadHandle, TRUE, INFINITE);   <span class="comment">//这句话控制了主线程和子线程的同步关系</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ticket &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">Sleep(<span class="number">30000</span>);</span><br><span class="line">CloseHandle(mutex);</span><br><span class="line">CloseHandle(wr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i++)CloseHandle(ThreadHandle[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/多线程2/res2.png" alt="alt"><br>写者优先是一样的方法，不再赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然看到一句很好的话，知人者智，自知者明。也算勉励自己吧。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>平面最近点对</title>
    <link href="http://yoursite.com/2020/04/01/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/"/>
    <id>http://yoursite.com/2020/04/01/平面最近点对/</id>
    <published>2020-04-01T12:09:52.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>平面最近点对，给出N个二维平面上的点，求空间欧几里得距离最近的一对点，并输出这样欧几里得距离。<br><a id="more"></a><br>来源：洛谷P1429<br>首先给出KD-Tree做法，直接暴力就好了，只有一个特例要处理下，就是同样位置的点可能会出现两次，这样的距离是0。<br>通过这道题，感觉自己更加理解K-D Tree了（大误？），但感觉K-D Tree有点劲啊，这啥优化都没有，就这样搜下去都可以，这玩意复杂度是个啥啊？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sq(x) (x)*(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int x(0),f(1);</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> mm[<span class="number">2</span>],mx[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> w, id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Point &amp;tp)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x[idx]&lt;tp.x[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point pt[MAXN];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>,Point&gt; PDN;</span><br><span class="line">priority_queue&lt;PDN&gt; que;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">2</span>,m=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KDTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Point p[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> sz[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt,<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">        sz[rt]=r-l;</span><br><span class="line">        sz[rt&lt;&lt;<span class="number">1</span>]=sz[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">        idx=dep%k;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        nth_element(pt+l,pt+mid,pt+r+<span class="number">1</span>);</span><br><span class="line">        p[rt]=pt[mid];</span><br><span class="line">        p[rt].mm[<span class="number">0</span>]=p[rt].mx[<span class="number">0</span>]=p[rt].x[<span class="number">0</span>];p[rt].mm[<span class="number">1</span>]=p[rt].mx[<span class="number">1</span>]=p[rt].x[<span class="number">1</span>];</span><br><span class="line">        build(l,mid<span class="number">-1</span>,rt&lt;&lt;<span class="number">1</span>,dep+<span class="number">1</span>);</span><br><span class="line">        build(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,dep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            p[rt].mm[<span class="number">0</span>]=min(min(p[rt&lt;&lt;<span class="number">1</span>].mm[<span class="number">0</span>],p[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mm[<span class="number">0</span>]),p[rt].mm[<span class="number">0</span>]);</span><br><span class="line">            p[rt].mm[<span class="number">1</span>]=min(min(p[rt&lt;&lt;<span class="number">1</span>].mm[<span class="number">1</span>],p[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mm[<span class="number">1</span>]),p[rt].mm[<span class="number">1</span>]);</span><br><span class="line">            p[rt].mx[<span class="number">0</span>]=max(max(p[rt&lt;&lt;<span class="number">1</span>].mx[<span class="number">0</span>],p[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx[<span class="number">0</span>]),p[rt].mx[<span class="number">0</span>]);</span><br><span class="line">            p[rt].mx[<span class="number">1</span>]=max(max(p[rt&lt;&lt;<span class="number">1</span>].mx[<span class="number">1</span>],p[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx[<span class="number">1</span>]),p[rt].mx[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> m,<span class="keyword">int</span> dep,Point q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sz[rt]==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">        idx=dep%k;</span><br><span class="line">         <span class="comment">//printf("(%d,%d)\n",p[rt].x[0],p[rt].x[1]);</span></span><br><span class="line">        <span class="keyword">int</span> left=rt&lt;&lt;<span class="number">1</span>,right=rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">        PDN tmp=PDN(<span class="number">0</span>,p[rt]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)tmp.first+=sq(<span class="number">1.0</span>*(p[rt].x[i]-q.x[i]));</span><br><span class="line">        <span class="keyword">if</span>(q.x[idx]&gt;p[rt].x[idx])swap(left,right);</span><br><span class="line">        <span class="keyword">if</span>(sz[left]!=<span class="number">-1</span>)query(left,m,dep+<span class="number">1</span>,q);</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)que.size()&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((q.x[<span class="number">0</span>]!=p[rt].x[<span class="number">0</span>]||q.x[<span class="number">1</span>]!=p[rt].x[<span class="number">1</span>]))que.push(tmp);</span><br><span class="line">            <span class="keyword">if</span>(q.x[<span class="number">0</span>]==p[rt].x[<span class="number">0</span>]&amp;&amp;q.x[<span class="number">1</span>]==p[rt].x[<span class="number">1</span>])tag++;</span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.first&lt;que.top().first)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(q.x[<span class="number">0</span>]!=p[rt].x[<span class="number">0</span>]&amp;&amp;q.x[<span class="number">1</span>]!=p[rt].x[<span class="number">1</span>])que.pop(),que.push(tmp);</span><br><span class="line">                <span class="keyword">if</span>(q.x[<span class="number">0</span>]==p[rt].x[<span class="number">0</span>]&amp;&amp;q.x[<span class="number">1</span>]==p[rt].x[<span class="number">1</span>])tag++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sq(<span class="number">1.0</span>*q.x[idx]-p[rt].x[idx])&lt;que.top().first)flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">/*double mm_dist=min(sq(q.x[0]-p[rt].mm[0]),sq(q.x[0]-p[rt].mx[0]));</span></span><br><span class="line"><span class="comment">            if(mm_dist&gt;que.top().first)flag=false;</span></span><br><span class="line"><span class="comment">            mm_dist=min(sq(q.x[1]-p[rt].mm[1]),sq(q.x[1]-p[rt].mx[1]));</span></span><br><span class="line"><span class="comment">            if(mm_dist&gt;que.top().first)flag=false;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sz[right]!=<span class="number">-1</span>&amp;&amp;flag)query(right,m,dep+<span class="number">1</span>,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;pt[i].x[<span class="number">0</span>],&amp;pt[i].x[<span class="number">1</span>]);</span><br><span class="line">    T.build(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("cur query:(%d,%d)\n",pt[i].x[0],pt[i].x[1]);</span></span><br><span class="line">        T.tag=<span class="number">0</span>;</span><br><span class="line">        T.query(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,pt[i]);</span><br><span class="line">        <span class="keyword">if</span>(T.tag&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=<span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=min(que.top().first,ans);</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,<span class="built_in">sqrt</span>(ans));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然还有一个法二，也是一个流行的方法，是指分治。<br>首先给个90分的做法（嘛，这也是11个测试点前面10个测试点太水了），首先先对x按第一关键字排序，而后对y按第二关键字排序，对排好序的点进行分治：<br>1）对于区间[l,r]来说，我们寻找[p[l].x,p[r].x]的中点的x坐标记为mid_x，以其作为分界线将区间分半，递归求解每一个区间的最近点对的距离。递归结束的条件是区间上所有点的x坐标相等，如果只有一个点注意这时候最近点对的距离是无穷大（边界条件），否则用只需枚举这个点相邻的点来判断是否为最近点对。<br>2）合并的区间很简单，在左半部分找到距离mid_x最近的left_x，在右半部分找到距离最近的right_x，（找可以用二分找），然后在left_x和right_x这两条直线上双指针扫描。<br>单纯只对x这样做肯定是不行的，可以举一个反例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">100</span></span><br><span class="line"><span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">50</span></span><br><span class="line"><span class="number">7</span> <span class="number">51</span></span><br></pre></td></tr></table></figure><br>如果只按照x坐标去，先排序得到：(2,50)、(3,100)、(6,0)、(7,51)。首先取mid_x=4进行划分，这样将会划分成(2,50)和(3,100)为左半部分，其余点为右半部分，在合并这两个区间的时候，按照我们的算法，我们只会取离x=4最近(3,100)，和右半部分的(6,0)进行求解，但是实际上在合并过程还有一个最近点对没有考虑(2,50)和(7,51)。<br>所以我们需要再对y坐标在做一边上述操作，当然最后还是不能满分的(笑)。<br>给一个90分的答案：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sq(x) (x)*(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Point &amp;tp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==tp.x)<span class="keyword">return</span> y&lt;tp.y;</span><br><span class="line">        <span class="keyword">return</span> x&lt;tp.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Point p[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmid</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=l;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p[mid].x&lt;=x)l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p[l].x&lt;=x&amp;&amp;l==r)ans=l;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> mid)</span>  <span class="comment">//双指针扫描</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist=sq(<span class="number">1.0</span>*p[i].x-p[j].x)+sq(<span class="number">1.0</span>*p[i].y-p[j].y);</span><br><span class="line">        <span class="comment">//printf("dist=%.4lf\n",dist);</span></span><br><span class="line">        ans=min(dist,ans);</span><br><span class="line">        <span class="keyword">if</span>(p[i].y&gt;p[j].y)j++;</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[l].x==p[r].x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ans=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;r;i++)</span><br><span class="line">            ans=min(ans,sq(<span class="number">1.0</span>*p[i].x-p[i+<span class="number">1</span>].x)+sq(<span class="number">1.0</span>*p[i].y-p[i+<span class="number">1</span>].y));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=(p[l].x+p[r].x)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pos=getmid(x,l,r);</span><br><span class="line">    <span class="keyword">double</span> lmm=solve(l,pos);</span><br><span class="line">    <span class="keyword">double</span> rmm=solve(pos+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> ll=getmid(p[pos].x<span class="number">-1</span>,l,pos);</span><br><span class="line">    <span class="keyword">if</span>(ll&lt;pos&amp;&amp;p[ll].x&lt;p[pos].x)ll++;</span><br><span class="line">    <span class="keyword">int</span> rr=getmid(p[pos+<span class="number">1</span>].x+<span class="number">1</span>,pos+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//printf("rr=%d\n",rr);</span></span><br><span class="line">    <span class="comment">//printf("%d %d\n",p[pos+1].x+1,p[rr].x);</span></span><br><span class="line">    <span class="keyword">if</span>(rr&gt;pos+<span class="number">1</span>&amp;&amp;p[rr].x==p[pos+<span class="number">1</span>].x+<span class="number">1</span>)rr--;</span><br><span class="line">    <span class="comment">//printf("lmm=%.4lf rmm=%.4lf\n",lmm,rmm);</span></span><br><span class="line">    <span class="comment">//int ch;</span></span><br><span class="line">    <span class="comment">//scanf("%d",&amp;ch);</span></span><br><span class="line">    <span class="comment">//printf("[%d,%d] : %d\n",ll,rr,pos);</span></span><br><span class="line">    <span class="keyword">double</span> lrm=Merge(ll,rr,pos);</span><br><span class="line">    <span class="comment">//printf("lrm=%.4lf\n",lrm);</span></span><br><span class="line">    <span class="keyword">double</span> ans=min(min(lmm,rmm),lrm);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">    sort(p+<span class="number">1</span>,p+<span class="number">1</span>+n);</span><br><span class="line">    <span class="comment">//printf("\n\n");</span></span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=n;i++)printf("%d %d\n",p[i].x,p[i].y);</span></span><br><span class="line">    <span class="keyword">double</span> ans=solve(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)swap(p[i].x,p[i].y);</span><br><span class="line">    sort(p+<span class="number">1</span>,p+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">double</span> ans1=solve(<span class="number">1</span>,n);</span><br><span class="line">    ans=min(ans,ans1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,<span class="built_in">sqrt</span>(ans));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为什么这样只能90分，尽管我们x和y的情况都考虑了，但这并不是正确的贪心，给出一个反例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span></span><br><span class="line"><span class="number">16</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">50</span></span><br><span class="line"><span class="number">9</span> <span class="number">49</span></span><br><span class="line"><span class="number">50</span> <span class="number">51</span></span><br><span class="line"><span class="number">17</span> <span class="number">52</span></span><br></pre></td></tr></table></figure><br>在这个例子中，我们发现答案并不是在x中距离最近的点，或者y中距离最近的点钟产生，而是在次近点中产生，即(9,49)和(17,52)<br>那么，我们就要思考怎么样才是正确的剪枝，正确的降低复杂度，我们知道肯定是不能$O(n^2)$去枚举，那要爆炸的。。。<br>我们注意到答案很有可能回在以mid_x为划分分别向左和右扩张d(d是当前左区间和右区间的最小distance),如下图所示：<br><img src="/images/平面最近点对/A.png" alt="alt"><br>当然还可以继续化简答案，当固定一个点，去枚举这个点是否存在更近最近点对的时候，我们只需要检查和它距离为d这段区间$（y_0-d,y_0+d）$答案，所以对于一个点，我们最多check 2d x 2d这样一个正方形。然后由于左区间的点和右区间点各点之间距离一定大于等于d，因此我们最多只需要枚举12个点，为什么是12个点，可以看下面那个这张图：<br><img src="/images/平面最近点对/B.png" alt="alt"><br>我们取2d x 2d右边的部分，如果我们要把一组点放在这个2d x d的部分，并且要求任意两点间的距离大于等于d，最多能放多少个点。也就是在上图中，我们最多能放多少个点，首先我们将这个矩形的长2d划分成3等分，也就是2/3d，宽划分2等分，也就是1/2d，这样我们能把这个矩形划分成6个小部分，注意到每一个矩形的对角线是小于d，也就是说在同一个矩形中，我们不能放进两个点，因为这样会破坏任意两点距离大于等于d的条件，故不行。故一个小矩形只能放1个点。故在2d x 2d的矩形中，我们可以放12个点，也就是说我们最多只需要暴力check 12个点即可。<br>最后复杂度是$O(nlog^2n)$<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sq(x) (x)*(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2e5</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF=<span class="number">1e18</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Point a,Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.x)<span class="keyword">return</span> a.y&gt;b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Point a,Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y==b.y)<span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y&gt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Point p[MAXN];</span><br><span class="line">Point q[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans=INF;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)<span class="keyword">return</span> sq(<span class="number">1.0</span>*(p[l].x-p[r].x))+sq(<span class="number">1.0</span>*(p[l].y-p[r].y));</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> lm=solve(l,mid);</span><br><span class="line">    <span class="keyword">double</span> rm=solve(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//merge</span></span><br><span class="line">    ans=min(lm,rm);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(p[i].x-p[mid].x)&lt;=ans)q[++cnt]=p[i];</span><br><span class="line">    sort(q+<span class="number">1</span>,q+cnt+<span class="number">1</span>,cmp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(<span class="number">1.0</span>*(q[j].y-q[i].y))&gt;<span class="built_in">sqrt</span>(ans))<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">double</span> dist=sq(<span class="number">1.0</span>*(q[i].x-q[j].x))+sq(<span class="number">1.0</span>*(q[i].y-q[j].y));</span><br><span class="line">            ans=min(ans,dist);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">    sort(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp1);</span><br><span class="line">    <span class="keyword">double</span> ans=solve(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,<span class="built_in">sqrt</span>(ans));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>给几组数据，备用debug:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test 1 样例</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Test 2 是否溢出</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1000000000</span> <span class="number">1000000000</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.4142</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Test 3 重复点</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Test 4 刚刚双指针提到的bug</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">100</span></span><br><span class="line"><span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">50</span></span><br><span class="line"><span class="number">7</span> <span class="number">51</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.0990</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Test 5 双指针的bug 2</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span></span><br><span class="line"><span class="number">16</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">50</span></span><br><span class="line"><span class="number">9</span> <span class="number">49</span></span><br><span class="line"><span class="number">50</span> <span class="number">51</span></span><br><span class="line"><span class="number">17</span> <span class="number">52</span></span><br><span class="line"></span><br><span class="line"><span class="number">8.5440</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平面最近点对，给出N个二维平面上的点，求空间欧几里得距离最近的一对点，并输出这样欧几里得距离。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/categories/ACM/machine-learning/"/>
    
      <category term="K-D tree" scheme="http://yoursite.com/categories/ACM/machine-learning/K-D-tree/"/>
    
      <category term="分治" scheme="http://yoursite.com/categories/ACM/machine-learning/K-D-tree/%E5%88%86%E6%B2%BB/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="K-D tree" scheme="http://yoursite.com/tags/K-D-tree/"/>
    
      <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>C ++ 多线程编程1 ——— 创建线程</title>
    <link href="http://yoursite.com/2020/03/26/C-plus-plus-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%80-%E2%80%94%E2%80%94%E2%80%94-%E5%AD%A6%E4%B9%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/26/C-plus-plus-多线程编程一-———-学习函数/</id>
    <published>2020-03-26T14:20:05.000Z</published>
    <updated>2021-08-02T07:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习多线程，紧跟脚步，不做眼高手低，稳扎稳打<br><a id="more"></a><br>1）HANDLE的定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *HANDLE;</span><br></pre></td></tr></table></figure><br>从中我们可以发现HANDLE的定义，它实际上表示一个void型的指针，使用这样的指针有个好处在于：<strong>void型指针可以强制转化为任意类型的指针</strong>，因此我们可以用他指向任意的数据结构。<br>那么我们就会思考HANDLE的作用是什么呢？这里参考了下stackoverflow的某位大佬（Lawrence Dol）的话：<br>来源：<a href="https://stackoverflow.com/questions/902967/what-is-a-windows-handle" target="_blank" rel="noopener">https://stackoverflow.com/questions/902967/what-is-a-windows-handle</a><br><img src="/images/多线程/HANDLE.png" alt="alt"><br>a.句柄的重定向<br>    如下图所示，当我们想访问一个进程里面的对象的时候，我们先访问HANDLE得到一个这个进程的对象表(即指向这个进所有对象的内存空间的指针数组),内核通过处理这个对象表的元素，完成对进程的控制。比如说重定向，因为大多数操作系统采用了虚拟内存，那这样的话一个进程所有对象的内存地址并不是固定的。所以操作系统可以利用这样特效，更改这个对象表的指针指向，完成重定向，实现虚拟内存实现。<br>b.隐藏某些信息<br>    从(a)我们可以知道，句柄可以帮助操作系统实现虚拟内存，重定向的功能。但是仔细思考，要想实现虚拟内存，我们直接访问这个进程的对象表不行吗，为什么一定通过一个指针去访问一个对象表。这就涉及到操作系统的安全的内容。我们知道操作系统的调度是受到保护的，如果用户对其进行修改，会不会破坏原有操作系统的调度，可能会导致操作系统崩溃。于是我们需要设一个HANDLE，指向这段需要保护的空间，这样用户就没有办法对其进行直接修改。看似这是一个笨操作，事实上是为了保证操作系统的安全性。<br>    还有一个好处，从API开发者角度考虑这个问题，如果我们设计了HANDLE指针当做这个API的返回值，这样用户就不知道我们实际返回值的定义是什么，就没办法得知我们这个结构体或者类的定义是什么？就没办法对这个结构体进行操作，比如取数据（都不知道这个结构体里面的成员变量有哪些，怎么提取？）。这是一个很好的安全措施，给一个例子说明：<br>    下图是一个关于Widget这个结构体的一个函数<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget * <span class="title">GetWidget</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget *w;</span><br><span class="line">    w = findWidget(name);</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    上述函数的返回值为Widget *,当我们在main函数调用这个GetWidget的时候，我们首先要定义Widget的指针这个变量，这样就相当于暴露了这个结构体名字，用户可以通过这个名字查询查询到Widget的成员变量。<br>    但是如果我们这样定义：<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *HANDLE</span><br><span class="line"><span class="function">HANDLE <span class="title">GetWidget</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget *w;</span><br><span class="line">    w = findWidget(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;HANDLE&gt;(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    那这样的话，我们在主函数调用GetWidget的时候，只需要定义HANDLE这个变量即可，这样用户只知道这个返回值返回的是HANDLE，即使暴露这个名字，也只能找到HANDLE的定义，无法确认这个HANDLE内部的实际意义是什么。当然我一直有个疑惑在于如果我知道了GetWidget函数不就可以知道实际返回的Widget，那这样不缺失了保护的意义？难道是它把这个GetWidget藏的很深？不让用户看见？<br>2）如何创建线程<br>当我们学会了HANDLE作用，了解了在Window操作系统中，是怎么样利用HANDLE实现对进程、资源等的控制（重定向，虚拟内存管理），怎么样保护Window的内核资源不被随意更改。那么我们就要了解在用户层面上是如何创建线程的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPDWORD lpThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><br>下面简单介绍几个参数：<br>a.lpThreadAttributes<br>    LPSECURITY_ATTRIBUTES lpThreadAttributes,表示指向SECURITY_ATTRIBUTES型态的指针。设置为NULL表示默认安全性，此时不可被子线程继承。给出其定义如下：<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SECURITY_ATTRIBUTES</span> &#123;</span></span><br><span class="line">    DWORD  nLength;         <span class="comment">//nLength表示，这个结构所占的空间是多少</span></span><br><span class="line">    LPVOID lpSecurityDescriptor; <span class="comment">//安全描述符，可以控制用户对线程的访问，如果该值为NULL，则表示用户对这个进程访问权限是默认的。</span></span><br><span class="line">    BOOL   bInheritHandle;      <span class="comment">//该控制属性能否被子进程继承。</span></span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure><br>    因此，由上述定义可知，如果我们想创建子线程也继承父进程下用户访问权限，那么我们不能设置为NULL，而是设置一个新的LPSECURITY_ATTRIBUTES，并设置其中的成员变量bInheritHandle为True即可。<br>b.dwStackSize<br>    线程堆栈的初始化大小，由用户设定。一个线程所有函数都要依赖于这个栈，比如参数的存储，使用。如果设置为0，那么将线程堆栈设置为默认大小（1MB）。<br>c.lpStartAddress<br>    指向线程函数的指针。这里允许多个线程指向同一个函数。（PS:可以实验下）。<br>d.lpParameter<br>    传给多线程函数的参数。LPVOID是一个空指针类型，可以对在线程函数进行内部强制转化转化到你想要类型，然后再执行。最常见的可以为这个线程函数进行一个结构体，然后我们将这个结构体指针传进去。如果只有一个参数可以传递一个对象的指针即可。<br>e.dwCreationFlags<br>    控制线程的创建方式，这里给出了两种创建方式：<br>    1.CREATE_SUSPENDED，这个进程会以挂起（suspended）状态创建，并且进程函数不会被执行，除非ResumeThread这个函数被调用。<br>    2.STACK_SIZE_PARAM_IS_A_RESERVATION，为这个线程提供了设置预留栈，这个参数和前面dwStackSize有关，如果这个标志未指定的话，dwStackSize应该会设置为预留栈的大小，如果为指定，dwStackSize将指定为默认的值。<br>    3.0表示创建后立即激活。<br>    PS：可以分别实验下上面三种创建方式。<br>f.lpThreadId<br>    返回新线程的ID，如果设置为NULL，则不返回新线程的ID。</p><p>实践：<br>创建一个含参数的新线程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sq(x) (x)*(x)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">int</span> x, y; </span><br><span class="line">Point()&#123;&#125;</span><br><span class="line">Point(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y) :x(_x), y(_y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span>&#123;</span> Point p1, p2; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_dist</span><span class="params">(Point p, Point q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(sq(p.x - q.x) + sq(p.y - q.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Fun</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input *cur = (Input *)lpParamter;</span><br><span class="line">Point p = cur-&gt;p1;</span><br><span class="line">Point q = cur-&gt;p2;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_dist(p, q) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input in;</span><br><span class="line">in.p1 = Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">in.p2 = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">HANDLE hthread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Fun, (LPVOID)(&amp;in), <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>栈空间这块，不知道为什么是随机的数值，这里不清楚变量是不是顺序存储在内存里面，好像跟我想的不一样，先给代码吧，以后再考虑。。。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sq(x) (x)*(x)</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Test</span><span class="params">(PVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwRet = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%-3d:0x%x\n"</span>, lpParamter, &amp;dwRet);</span><br><span class="line"><span class="keyword">return</span> dwRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwTid;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Main:0x%x\n"</span>, &amp;dwTid);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>;i++)</span><br><span class="line">CreateThread(<span class="literal">NULL</span>, <span class="number">4</span>, Test, (PVOID)(i), STACK_SIZE_PARAM_IS_A_RESERVATION, <span class="literal">NULL</span>);</span><br><span class="line">Sleep(<span class="number">6000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3）CloseHandle函数<br>销毁线程用void CloseHandle(HANDLE thread);</p><p>4)GetCurrentThreadId函数<br>得到当前线程的PID，int GetCurrentThreadId().</p><p>以上是多线程的基本内容，下一节介绍window.h的临界区，并尝试基本的生产者消费者模型的编程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习多线程，紧跟脚步，不做眼高手低，稳扎稳打&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>KD-tree 练习一：HDU 5992 Finding Hotels</title>
    <link href="http://yoursite.com/2020/03/26/KD-tree-%E7%BB%83%E4%B9%A0%E4%B8%80%EF%BC%9AHDU-5992-Finding-Hotels/"/>
    <id>http://yoursite.com/2020/03/26/KD-tree-练习一：HDU-5992-Finding-Hotels/</id>
    <published>2020-03-26T11:46:11.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>练习机器学习算法也是练习代码功底，以备后续找工作之用。给个预告，下一节试着用K-D Tree做最近点对。<br><a id="more"></a><br>HDU 5992 Finding Hotels<br>题意：给出一个N($N \leq 200000$)个宾馆和M($M \leq 20000$)个顾客，给出每个宾馆在二维地图中的坐标和花费，同时给出每个旅客的二维坐标和旅客能承受最大花费，要求对于每一个旅客，找到满足小于最大花费下，离它欧几里得距离最小的旅馆是哪个，如果有多个旅馆，输出编号最近的那个。<br>题解：K-D Tree，典型的K-D Tree暴力，与最裸的K-D Tree不同的是，你还需要考虑当前旅馆花费是否小于最小花费，这个本题解法没有优化，就是按照K-D Tree建树顺序去搜索（即尽可能贪心与他欧几里得距离最近的点，然后暴力check），可能本身这样搜索就是一个优化和剪枝。<br>下面介绍K-D Tree算法，这也是本次学习的核心，K-D Tree就是讲一些K维的数据按照一定顺序进行放置，经过这样放置后对于我们解决K维空间最近邻搜索问题起到一定优化。<br>最早K-D Tree原型要说的话，应该BST，即二叉搜索树，下面回忆下二叉搜索树的一些基本概念：对于一个二叉树而言，每一个节点分别存储一个数值（与线段树一个不同，线段树是每个节点存储区间信息），从这个节点往下可以引出两个分支，第一个分支是小于该节点的左子树，第二个分支是大于该分支的右子树，这样我们只需要在每个节点进行决策，如果大于当前节点，显然我们不需要花太多时间去搜索左子树，同理小于也是一样的。<br>K-D Tree是当BST推广到二维的一个概念。对于一个良好的搜索数据结构而言，我们希望对于每一个节点来说，它的左右子树是平衡（深度尽量一致），这样能够避免出现链状的二叉树，比如说：8-&gt;9-&gt;10-&gt;11-&gt;12-&gt;…-&gt;100,当然我们想查找比99大的元素的时候，对于这样一个链状的二叉树而言，几乎是O(N),但如果我取中间的节点作为二叉树的根节点，可能左右子树深度一致，能够尽量避免较大搜索。同时对于我们来说还有一个新问题：这些数据有K个维度，我应该是以什么依据划分左右子树。<br>于是总结下来，建立一个K-D Tree需要考虑以下问题：<br>1）如何保证K-D Tree是个左右子树平衡的结构？<br>2）如何划分子树？<br>首先解决2）问题，如何划分子树，可以思考一个生活场景，现在你的手里拿着黄瓜，黄瓜长20cm,宽6cm,给你一把刀让你对黄瓜分成2分，你会怎么切？对于一个正常人来说，肯定会对着黄瓜长截一刀，得到两个长10cm,宽6cm的黄瓜。同样对于数据也是一样，当一个数据某个维度相差特别大（即该维度的最小值和最大值差别特别大），我们就可以说数据从这里切分是最好的。而在这里，我们一般用数据的方差去衡量是不是差别很大。当方差较大时候，我们认为数据分别比较广，比较好分，当数据的方差很小，我们认为它们都集中在平均值上，不好区分。于是一个很简单方法，我去检查选了该节点后，剩余的节点的方差在K维表现，当第i维方差较大的时候，我们认为从第i维最好分。当然一个最简单方法就是轮着分，第一次我用第一维，第二次用第二维…第K次用第K维。在这道题中，为了方便我们用轮着分。<br>接下来解决问题1），如何保证K-D Tree是一个平衡结构。因为我们划分子树是以某一个维度去划分。不关心其他维度，于是我们可以把他看成关于第i维（第i维是当前我们划分子树依据）的一维数组。刚刚也说道对于一个数组，比如说1,2,3,4,5去建立二叉树，如果我们取1或者5作为根节点就会出现链状，即左右子树节点数的差值很大。但是我们取3去做，会发现两边子树的节点数都是2，这样可以保持当前的左右子树平衡。注意到3这个数字的特点是刚好是这个数列的中位数。如果我们每一步划分子树都按照取中位数，是不是都能保证每一步的左右子树划分都是平衡。这样整体的左右子树的划分就是平衡的。<br>好像光光去说，似乎有点勉强，我们举个例子：<br><img src="/images/hdu5992/K-DTree.jpg" alt="alt"><br>上面分别给出了6个平面中二维点，分别为(7,2)、(5,4)、(2,3)、(4,7)、(9,6)、(8,1)，按照上述规则（轮流+中位数），我们可以得到如下一个K-DTree:<br><img src="/images/hdu5992/K-DTree2.jpg" alt="alt"><br>理解上述建树的过程，我们需要考虑的是：如何查询K-D Tree的最近邻？<br>与不同二叉树不同的是，通常我们都用二叉树去查询比他小的元素，或者是大的元素。而在K-D Tree，我们大多数是查询在树中哪一个节点离当前的节点的欧几里得距离（曼哈顿距离也行）更近。那么我们应该如何查询？<br>通过总结，我们一般按照如下规则对K-D Tree进行查询：<br>a.首先按照类似二叉树的方法，对当前节点，按照划分子树规则，即通过比较该元素与当前子树的根节点的第i维大小，如果比他大则进入右子树查询，如果小则进入左子树查询。<br>b.但由于我们查询距离最近，那么我们可能会思考一个问题就是另外一个分支是否存在更近的点？于是我们就会想采用一种方法去判断是否有更近的点出现在另外一个分支中。我们采用这个方法就是判断以当前查询的节点为原点，以当前最小欧几里得距离为半径，画出一个超平面圆形，同样我们用一个超平面矩形去包含另外一个分支所有的点，看是不是有交集，如果有交集，那么很有可能有比其还小的一个点。<br>这个a可能很好理解，这个b似乎有点抽象，让我们用一个图去理解这个问题：<br><img src="/images/hdu5992/KD-Tree-Search1.png" alt="alt"><br>黑色的点表示K-D Tree上的点，分别有(2,3)、(5,4)、(4,7)、(2,7)、(1,8)、(6,9)<br>按照K-D Tree建树规则，我们很快就确认我们搜索顺序先是：<br>(2,7)-&gt;(5,4)-&gt;(4,7)<br>当回溯至(5,4)节点我们需要检查他的下半部分的分支是否是存在更近的点，于是我们以查询点（图中星星点，(2,5)）为圆心画出一个圆。然后我们发现下半分支就是图中最左下角的矩形，我们发现他们有交集，即可能存在更近的点（事实上确实有）。于是我们就会去搜索下面的分支：<br><img src="/images/hdu5992/KD-Tree-Search2.png" alt="alt"><br>那么现在一个问题，在于我们如何确定矩形和圆是否可能存在交集，最简单的方法就是存下下半分支的按极角排序的最近的点表示矩形左下角，最远的点表示右上角。然后判断是否有交集，但这样太麻烦不好维护，我们注意到当我们回溯到(5,4)的时候，上下分支是依据y坐标划分的，那么(5,4)一定是下面区域中最高的那个点（肯定的，根据建树规则思考）。那么若这个点与(2,5)在y坐标方向的距离小于半径，那必然会有交集，所以我需要去继续搜索下一个分支判断是否有距离更小的元素。<br>注意：也可能另一个分支不存在最小的元素，但是相交后可能性较大，用其他方法排除是否存在最小的元素可能条件更弱，容易TLE的。</p><p>下面给出HDU这个题的code(题解上面已经说了，就一句话按K-D Tree顺序搜索相当于剪枝，速度更快吧)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sq(x) (x)*(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int x(0),f(1);</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123;<span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> w,id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Point &amp;tp)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x[idx]&lt;tp.x[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point pt[MAXN];</span><br><span class="line">Point q;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,Point&gt; PDN;</span><br><span class="line">priority_queue&lt;PDN&gt; que;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">2</span>,m=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KDTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Point p[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> sz[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt,<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">        sz[rt]=r-l;</span><br><span class="line">        sz[rt&lt;&lt;<span class="number">1</span>]=sz[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">        idx=dep%<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        nth_element(pt+l,pt+mid,pt+r+<span class="number">1</span>);</span><br><span class="line">        p[rt]=pt[mid];</span><br><span class="line">        build(l,mid<span class="number">-1</span>,rt&lt;&lt;<span class="number">1</span>,dep+<span class="number">1</span>);</span><br><span class="line">        build(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> m,<span class="keyword">int</span> dep,Point q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sz[rt]==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> idx=dep%k,left=rt&lt;&lt;<span class="number">1</span>,right=rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">        PDN tmp=PDN(<span class="number">0</span>,p[rt]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)tmp.first+=sq(<span class="number">1L</span>L*(p[rt].x[i]-q.x[i]));</span><br><span class="line">        <span class="keyword">if</span>(q.x[idx]&gt;p[rt].x[idx])swap(left,right);</span><br><span class="line">        <span class="keyword">if</span>(sz[left]!=<span class="number">-1</span>)query(left,m,dep+<span class="number">1</span>,q);</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)que.size()&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[rt].w&lt;=q.w)</span><br><span class="line">                que.push(tmp);</span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.first&lt;que.top().first&amp;&amp;p[rt].w&lt;=q.w)que.pop(),que.push(tmp);</span><br><span class="line">            <span class="keyword">if</span>(tmp.first==que.top().first&amp;&amp;p[rt].w&lt;=q.w&amp;&amp;p[rt].id&lt;que.top().second.id)que.pop(),que.push(tmp);</span><br><span class="line">            <span class="keyword">if</span>(sq(q.x[idx]-p[rt].x[idx])&lt;que.top().first)flag=<span class="literal">true</span>;  <span class="comment">//查询另外部分矩形和圆形是否相交</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sz[right]!=<span class="number">-1</span>&amp;&amp;flag)query(right,m,dep+<span class="number">1</span>,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="keyword">int</span> n,ask;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=read();ask=read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pt[i].id=i;</span><br><span class="line">            pt[i].x[<span class="number">0</span>]=read();pt[i].x[<span class="number">1</span>]=read();pt[i].w=read();</span><br><span class="line">        &#125;</span><br><span class="line">        T.build(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(ask--)</span><br><span class="line">        &#123;   q.x[<span class="number">0</span>]=read();q.x[<span class="number">1</span>]=read();q.w=read();</span><br><span class="line">            T.query(<span class="number">1</span>,m,<span class="number">0</span>,q);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,que.top().second.x[<span class="number">0</span>],que.top().second.x[<span class="number">1</span>],que.top().second.w);</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;练习机器学习算法也是练习代码功底，以备后续找工作之用。给个预告，下一节试着用K-D Tree做最近点对。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/categories/ACM/machine-learning/"/>
    
      <category term="K-D tree" scheme="http://yoursite.com/categories/ACM/machine-learning/K-D-tree/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="K-D tree" scheme="http://yoursite.com/tags/K-D-tree/"/>
    
  </entry>
  
  <entry>
    <title>腾讯18春招机试</title>
    <link href="http://yoursite.com/2020/03/21/%E8%85%BE%E8%AE%AF18%E6%98%A5%E6%8B%9B%E6%9C%BA%E8%AF%95/"/>
    <id>http://yoursite.com/2020/03/21/腾讯18春招机试/</id>
    <published>2020-03-21T02:51:03.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更blog，也好久没编程了，先做个简单慢慢学习。<br><a id="more"></a><br>A题<br>小Q定义了一种数列称为翻转数列:<br>给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4…, 每隔m个符号翻转一次, 最初符号为’-‘;。<br>例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.<br>而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.<br>小Q现在希望你能帮他算算前n项和为多少。</p><p>题解：稍微有点技巧的数学题？这个题有个条件很关键就是n能被2m整除，如果n不能被2m整除，那这个题要考虑的case还蛮多的。<br>考虑个最简单的模型：N是一个远大于2的偶数（本题中N一定是偶数），m=1<br>很容易想到：</p><script type="math/tex; mode=display">\sum_{i=1}^N{i} - 2 * \sum_{j=1}^{N/2}{(1+(j-1)*2)}</script><p>其实发现可以前面两个式子可以利用等差数列前N项和公式化简为：</p><script type="math/tex; mode=display">\frac{N * (N+1)}{2} - \frac{N * N}{2}</script><p>将m推广至小于N的任意数后其实也不难，就相当于后面的减数变成m个等差数列之和，每个等差数列的公差为2m<br>于是可以得到</p><script type="math/tex; mode=display">\frac{N * (N+1)}{2} - (\frac{N * (M+1)}{2} + \frac{N * N}{2} - N * M)</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    LL ans = n*(n+<span class="number">1</span>)/<span class="number">2</span> - ((n*(m+<span class="number">1</span>))/<span class="number">2</span> + (n*n/<span class="number">2</span> - n*m));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B题<br>牛牛和羊羊正在玩一个纸牌游戏。这个游戏一共有n张纸牌, 第i张纸牌上写着数字ai。<br>牛牛和羊羊轮流抽牌, 牛牛先抽, 每次抽牌他们可以从纸牌堆中任意选择一张抽出, 直到纸牌被抽完。<br>他们的得分等于他们抽到的纸牌数字总和。<br>现在假设牛牛和羊羊都采用最优策略, 请你计算出游戏结束后牛牛得分减去羊羊得分等于多少。</p><p>题解：水题<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,a[MAXN];</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    LL tmp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans + a[i] * tmp;</span><br><span class="line">        tmp = tmp * <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C题<br>小Q的父母要出差N天，走之前给小Q留下了M块巧克力。小Q决定每天吃的巧克力数量不少于前一天吃的一半，<br>但是他又不想在父母回来之前的某一天没有巧克力吃，请问他第一天最多能吃多少块巧克力</p><p>题解：这个题，最直观的想法就是暴力，然后在找到第一个满足条件就break，可是这样容易超时。因为这个第一个可能会很大。<br>于是我们仔细思考，发现这个题具有二分性质：即满足条件下的最大（小）解<br>于是就可以二分，check直接暴力check即可，复杂度为O(mlogn)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=ans+tp;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;n)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(tp&amp;<span class="number">1</span>)tp=tp/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tp=tp/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n,mid,ans;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//printf("[%d %d]\n",l,r);</span></span><br><span class="line">        <span class="comment">//printf("mid=%d\n",mid);</span></span><br><span class="line">        <span class="keyword">if</span>(check(mid))</span><br><span class="line">            l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==r&amp;&amp;check(l))ans=l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>D题<br>小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌组成一个总长度正好为K的歌单，<br>每首歌最多只能在歌单中出现一次，在不考虑歌单内歌曲的先后顺序的情况下，请问有多少种组成歌单的方法。</p><p>题解：简单组合数学，暴力即可，因为这里数据很小，不需要费马求逆元，直接用杨辉三角形即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL k;</span><br><span class="line">LL A,X,B,Y;</span><br><span class="line">LL C[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)C[i][<span class="number">0</span>]=C[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;A,&amp;X,&amp;B,&amp;Y);</span><br><span class="line">    LL sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=X;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            LL left=k-sum;</span><br><span class="line">            <span class="comment">//printf("left = %I64d\n",left);</span></span><br><span class="line">            <span class="keyword">if</span>(left%B==<span class="number">0</span>&amp;&amp;(left/B)&lt;=Y)ans=(ans+C[X][i]*C[Y][left/B]%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        sum=sum+A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>E题(好题)</p><p>小Q的公司最近接到m个任务, 第i个任务需要xi的时间去完成, 难度等级为yi。<br>小Q拥有n台机器, 每台机器最长工作时间zi, 机器等级wi。<br>对于一个任务,它只能交由一台机器来完成, 如果安排给它的机器的最长工作时间小于任务需要的时间, 则不能完成,如果完成这个任务将获得200 <em> xi + 3 </em> yi收益。</p><p>对于一台机器,它一天只能完成一个任务, 如果它的机器等级小于安排给它的任务难度等级, 则不能完成。</p><p>小Q想在今天尽可能的去完成任务, 即完成的任务数量最大。如果有多种安排方案,小Q还想找到收益最大的那个方案。小Q需要你来帮助他计算一下。</p><p>题解：<br>题目出错了，应该改为怎么样才能让任务数最大，并且计算使得任务数最大的花费是多少。<br>按任务数去贪心来做，先对每个任务和机器按照时间从大到小，时间相同按等级从大到小。<br>经过上述排序后，扫描排序后的每一个任务，扫描机器集合直到不存在机器比当前任务花费长则结束，如果存在一个机器比它时间长，则把它加入集合S，然后判断这个集合中是否存在比该机器等级高的机器，如果有则表示该机器可以被匹配，并且从匹配集合中选一个最小的等级从S集合中删去，计算花费。<br>对于下一个机器来说，同样扫描除S集合以外的所有机器直到不存在机器比当前任务花费长则结束，并按上述一样的操作加入S集合，然后判断这个集合中是否存在比该机器等级高的机器，如果有则表示该机器可以被匹配，同样从匹配集合中选一个最小的等级从S集合中删去，计算花费。<br>这是一种二步贪心的策略，优先匹配时间长且等级高的，因为这部分选择少不容易浪费（否则你按小的任务去匹配和一个与它时间相差较大的机器，那肯定浪费了），对于等级低机器，因为集合S的机器必然满足它的条件，但是得优先（必须这样匹配，不然也会导致浪费）选接近它等级，不然容易浪费。且优先匹配时间大的机器，还可以利用上一次没有匹配的机器，从而减少扫描的时间。<br>可以想成，我贪心按任务时间从高到低的顺序去处理这个问题以避免浪费，选用任务的时间X去筛选出满足当前机器可能可行集S，而后我在可行集合S中优先选择最小满足条件的等级（因为此时可行集合的时间X已经不重要，对下一步的影响不如y对下一步的影响）<br>这样的做法的好处在于：省时（nxm的复杂度，且不重复扫描，比它高的优先统计进去了）的一种贪心，且不需要较麻烦的二维排序<br>一种错误且复杂的思路：仅仅只考虑当前机器的匹配策略，用暴力方法去找与(x,y)欧几里得距离最小，事实上没有这个必要是欧几里得距离最小，这种方法繁琐，且很有可能是错的。举一例即可。<br>2 2<br>10 10<br>13 9<br>7 10<br>8 9</p><p>我们会发现8 9这个机器，按照取欧几里得最小去匹配的话，优先匹配10 10，而此时7 10没办法被匹配。<br>事实上正确答案应该是8 9匹配13 9，而7 10匹配10 10。是一种二步贪心的思想。</p><p>这个题并未在赛场上想出正解，以下代码借鉴了腾讯的正解进行编写。。。，说明小伙子贪心能力不行啊。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    Node()&#123;&#125;;</span><br><span class="line">    Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):x(a),y(b)&#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;tp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tp.x==x)<span class="keyword">return</span> tp.y&lt;y;</span><br><span class="line">        <span class="keyword">return</span> tp.x&lt;x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">Node p[MAXN],q[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;q[i].x,&amp;q[i].y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">    <span class="comment">//printf("\n\n");</span></span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+n);</span><br><span class="line">    sort(p+<span class="number">1</span>,p+<span class="number">1</span>+m);</span><br><span class="line">   <span class="comment">// for(int i=1;i&lt;=m;i++)</span></span><br><span class="line">    <span class="comment">//    printf("%d %d\n",p[i].x,p[i].y);</span></span><br><span class="line">    <span class="comment">//printf("\n\n");</span></span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">    <span class="comment">//    printf("%d %d\n",q[i].x,q[i].y);</span></span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("i=%d %d %d\n",i,p[i].x,p[i].y);</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=n&amp;&amp;q[j].x&gt;=p[i].x)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[q[j].y]++;</span><br><span class="line">            <span class="comment">//printf("[%d,%d]\n",q[j].x,q[j].y);</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=p[i].y;k&lt;=<span class="number">100</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[k])</span><br><span class="line">            &#123;</span><br><span class="line">                tot++;</span><br><span class="line">                cnt[k]--;</span><br><span class="line">                ans=ans+(<span class="number">200</span>*p[i].x+<span class="number">3</span>*p[i].y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %lld\n"</span>,tot,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F题<br>画家小Q又开始他的艺术创作。小Q拿出了一块有NxM像素格的画板, 画板初始状态是空白的,用’X’表示。<br>小Q有他独特的绘画技巧,每次小Q会选择一条斜线, 如果斜线的方向形如’/‘,即斜率为1,小Q会选择这条斜线中的一段格子,都涂画为蓝色,用’B’表示;如果对角线的方向形如’\’,即斜率为-1,小Q会选择这条斜线中的一段格子,都涂画为黄色,用’Y’表示。<br>如果一个格子既被蓝色涂画过又被黄色涂画过,那么这个格子就会变成绿色,用’G’表示。<br>小Q已经有想画出的作品的样子, 请你帮他计算一下他最少需要多少次操作完成这幅画。</p><p>暴力，case很多，直接两边dfs会因为没办法处理G而死循环这个注意了（注释就是没有考虑这个挂了一发）。。。<br>给几个反例参考：<br>6 5<br>XBGBX<br>YBBYB<br>BGGXX<br>XYYBG<br>XYBGG<br>YYXYX<br>答案：18<br>如果是12的，你是不是没考虑孤立的G点</p><p>4 4<br>GXXX<br>XGXX<br>XXGX<br>XXXG<br>答案：5<br>先画Y一笔，剩下的画B四笔。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 53</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> mp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> used[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(used[x][y]==<span class="number">2</span>&amp;&amp;mp[x][y]==<span class="string">'G'</span>)used[x][y]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!used[x][y])used[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> xx,yy;</span><br><span class="line">    xx=x<span class="number">-1</span>;yy=y+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!=<span class="string">'X'</span>&amp;&amp;((mp[xx][yy]!=<span class="string">'Y'</span>&amp;&amp;!used[xx][yy])||(mp[xx][yy]==<span class="string">'G'</span>)))</span><br><span class="line">        dfs1(xx,yy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf("(%d,%d)\n",x,y);</span></span><br><span class="line">    <span class="keyword">if</span>(used[x][y]==<span class="number">2</span>&amp;&amp;mp[x][y]==<span class="string">'G'</span>)used[x][y]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!used[x][y])used[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> xx,yy;</span><br><span class="line">    xx=x+<span class="number">1</span>;yy=y<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!=<span class="string">'X'</span>&amp;&amp;((mp[xx][yy]!=<span class="string">'Y'</span>&amp;&amp;!used[xx][yy])||(mp[xx][yy]==<span class="string">'G'</span>)))</span><br><span class="line">        dfs2(xx,yy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf("(%d,%d)\n",x,y);</span></span><br><span class="line">    <span class="keyword">if</span>(used[x][y]==<span class="number">1</span>&amp;&amp;mp[x][y]==<span class="string">'G'</span>)used[x][y]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!used[x][y])used[x][y]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> xx,yy;</span><br><span class="line">    xx=x+<span class="number">1</span>;yy=y+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!=<span class="string">'X'</span>&amp;&amp;((mp[xx][yy]!=<span class="string">'B'</span>&amp;&amp;!used[xx][yy])||(mp[xx][yy]==<span class="string">'G'</span>)))</span><br><span class="line">        dfs3(xx,yy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs4</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf("(%d,%d)\n",x,y);</span></span><br><span class="line">    <span class="keyword">if</span>(used[x][y]==<span class="number">1</span>&amp;&amp;mp[x][y]==<span class="string">'G'</span>)used[x][y]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!used[x][y])used[x][y]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> xx,yy;</span><br><span class="line">    xx=x<span class="number">-1</span>;yy=y<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!=<span class="string">'X'</span>&amp;&amp;((mp[xx][yy]!=<span class="string">'B'</span>&amp;&amp;!used[xx][yy])||(mp[xx][yy]==<span class="string">'G'</span>)))</span><br><span class="line">        dfs4(xx,yy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void dfs(int x,int y,int tag)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    used[x][y]=true;</span></span><br><span class="line"><span class="comment">    int xx,yy;</span></span><br><span class="line"><span class="comment">    printf("(%d,%d) %d\n",x,y,tag);</span></span><br><span class="line"><span class="comment">    if(!tag) //BLUE</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        xx=x-1;yy=y+1;</span></span><br><span class="line"><span class="comment">        //printf("now:(%d,%d)\n",xx,yy);</span></span><br><span class="line"><span class="comment">        if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;(mp[xx][yy]!='Y'&amp;&amp;!used[xx][yy])||(mp[xx][yy]=='G'))</span></span><br><span class="line"><span class="comment">            dfs(xx,yy,0);</span></span><br><span class="line"><span class="comment">        xx=x+1;yy=y-1;</span></span><br><span class="line"><span class="comment">        //printf("now:(%d,%d)\n",xx,yy);</span></span><br><span class="line"><span class="comment">        if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;mp[xx][yy]!='Y'&amp;&amp;!used[xx][yy]||(mp[xx][yy]=='G'))</span></span><br><span class="line"><span class="comment">            dfs(xx,yy,0);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else //YELLOW</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        xx=x+1;yy=y+1;</span></span><br><span class="line"><span class="comment">        //printf("now:(%d,%d)\n",xx,yy);</span></span><br><span class="line"><span class="comment">        if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;mp[xx][yy]!='B'&amp;&amp;!used[xx][yy]||(mp[xx][yy]=='G'))</span></span><br><span class="line"><span class="comment">            dfs(xx,yy,1);</span></span><br><span class="line"><span class="comment">        xx=x-1;yy=y-1;</span></span><br><span class="line"><span class="comment">        //printf("now:(%d,%d)\n",xx,yy);</span></span><br><span class="line"><span class="comment">        if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;mp[xx][yy]!='X'&amp;&amp;mp[xx][yy]!='B'&amp;&amp;!used[xx][yy]||(mp[xx][yy]=='G'))</span></span><br><span class="line"><span class="comment">            dfs(xx,yy,1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i][j]&amp;&amp;mp[i][j]!=<span class="string">'X'</span>&amp;&amp;mp[i][j]!=<span class="string">'G'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printf("start:%d %d\n",i,j);</span></span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'B'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dfs1(i,j);</span><br><span class="line">                    dfs2(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dfs3(i,j);</span><br><span class="line">                    dfs4(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if(mp[i][j]=='G')</span></span><br><span class="line">             <span class="comment">//   printf("(%d,%d):%d\n",i,j,used[i][j]);</span></span><br><span class="line">            <span class="keyword">if</span>(mp[i][j]==<span class="string">'G'</span>&amp;&amp;used[i][j]!=<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(used[i][j]==<span class="number">2</span>||used[i][j]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dfs1(i,j);</span><br><span class="line">                    dfs2(i,j);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//printf("(%d,%d):%d\n",i,j,used[i][j]);</span></span><br><span class="line">                <span class="keyword">if</span>(used[i][j]==<span class="number">0</span>||used[i][j]==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dfs3(i,j);</span><br><span class="line">                    dfs4(i,j);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有更blog，也好久没编程了，先做个简单慢慢学习。&lt;br&gt;
    
    </summary>
    
      <category term="机试" scheme="http://yoursite.com/categories/%E6%9C%BA%E8%AF%95/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/%E6%9C%BA%E8%AF%95/C/"/>
    
    
      <category term="机试" scheme="http://yoursite.com/tags/%E6%9C%BA%E8%AF%95/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #525 div2</title>
    <link href="http://yoursite.com/2018/12/06/Codeforces-Round-525-div2/"/>
    <id>http://yoursite.com/2018/12/06/Codeforces-Round-525-div2/</id>
    <published>2018-12-06T12:31:52.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1088" target="_blank" rel="noopener">http://codeforces.com/contest/1088</a><br>codeforces 525 div2 题解 By usename6<br><a id="more"></a><br>A. Ehab and another construction problem<br><a href="http://codeforces.com/contest/1088/problem/A" target="_blank" rel="noopener">http://codeforces.com/contest/1088/problem/A</a><br>题意：给你一个x，问你在[1,x]范围是否存在两个数a,b，使得$a*b&gt;x$，且$ \frac{a}{b} &lt; x $<br>暴力枚举即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">1</span>;b&lt;=x;b++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=b;a&lt;=x;a+=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a*b&gt;x&amp;&amp;a/b&lt;x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,b);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>B. Ehab and subtraction<br><a href="http://codeforces.com/contest/1088/problem/B" target="_blank" rel="noopener">http://codeforces.com/contest/1088/problem/B</a><br>题意：给你一个长度为n的数组，你可以对它做K次操作，每次选出里面最小非0数，然后用这个数减去所有数，如果最后这个数组只剩0，那么输出0<br>排序，利用前缀累加的性质，乱搞一发就行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    LL sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt==k)<span class="keyword">break</span>;</span><br><span class="line">        a[i]=max(a[i]-sum,<span class="number">0L</span>L);</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        sum=sum+a[i];</span><br><span class="line">        <span class="keyword">int</span> id=upper_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+n,sum)-a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,max(<span class="number">0L</span>L,a[id]-sum));</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt==k)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt+<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C. Ehab and a 2-operation task<br><a href="http://codeforces.com/contest/1088/problem/C" target="_blank" rel="noopener">http://codeforces.com/contest/1088/problem/C</a><br>题意：给你长度为n的数组，然后你可以每次对这个元素进行两个操作，<br>1 x y,表示1~x这段都加y<br>2 x y,表示1~x这段都mody<br>然后你最多能操作n+1次，问你怎么做能把他变成一个递增序列</p><p>简单题，注意是对前缀操作，那我可以指定最后一次对全体数mod n,那么就简单了，那么我可以先对长度为n的做一次前缀操作，使得最后一个数mod n等于n-1，然后遗传对长度为n-1，操作，<br>直到第一个数为止，最后我在把所有的数mod n,这样的序列一定是递增的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        a[i]%=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> d=i<span class="number">-1</span>-a[i];</span><br><span class="line">        <span class="keyword">if</span>(d&lt;<span class="number">0</span>)d+=n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1 %d %d\n"</span>,i,d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            a[j]=(a[j]+d)%n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2 %d %d\n"</span>,n,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>D. Ehab and another another xor problem<br><a href="http://codeforces.com/contest/1088/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1088/problem/D</a><br>题意：交互题，这个题是这样，让你猜数字，你可以输入a,b，要你猜c,d，系统会返回给你一系列的值<br>a ^ c <em> b ^ d (</em>填写&gt; 、 &lt; 、=)<br>如果是a ^ c &gt; b ^ d 那么返回值为1<br>如果是a ^ c &lt; b ^ d 那么返回值为-1<br>相等返回值为0<br>还是一样，你最多只能进行62次操作，但c , d保证是小于$2^{30}$<br>这题看到62次询问，会想到的位操作，每次查询位，<br>假设你现在猜两个数字的最高位是什么？<br>1.如果这两个数字的最高位相同，那么你分别对最高位去异或1：<br>1）如果这两个数的都是1，那么第一个查询结果一定是-1<br>2）如果这两个数都是0，不需要做任何操作<br>2.如果两个数字都不相同，首先设定一个flag表示当前这两个数字大小比较<br>1）如果flag = 1,那么必然a是1<br>2）否则b是1</p><p>如何每次都使得查的是最高位，假设我已经猜出了a的29~i-1的位，那么我只需要那些这些数去异或原数，那么得到一定是i位是最高位，前面的位数都是0<br>flag的修改，因为flag表示当前除去29~i-1位，i~1位的c和d的比较，所以若第i位相同，我则不需要改变flag,如果第i位不相同，那么我就要改变flag,将c,d当前最高位去掉，使得他们最高位第i位不受任何影响，则异或用查询1的结果去更新即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? %d %d\n"</span>,c,d);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,flag;</span><br><span class="line">    flag=ask(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">29</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> f1=ask(a^(<span class="number">1</span>&lt;&lt;i),b);</span><br><span class="line">        <span class="keyword">int</span> f2=ask(a,b^(<span class="number">1</span>&lt;&lt;i));</span><br><span class="line">        <span class="keyword">if</span>(f1==f2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>)a=a^(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="number">-1</span>)b=b^(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            flag=f1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f1==<span class="number">-1</span>)a=a^(<span class="number">1</span>&lt;&lt;i),b=b^(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"! %d %d\n"</span>,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>E. Ehab and a component choosing problem<br><a href="http://codeforces.com/contest/1088/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1088/problem/E</a><br>题意：给你一个n个节点的树，让你求选K个联通快，首先要最大化比例值，即联通块的权值和/k的值，其次最大化K的值<br>如果最大化比例，乍一看有点像01分数规划，但这里选的是联通快，而不是单独节点，这里我们放弃联通块的想法，考虑一种思路<br>没错，就是贪心。<br>设b是平均值<br>若选了k个联通块，权值分别为<br>$a<em>{1}，a</em>{2}，a<em>{3}，a</em>{4}…a<em>{k}$<br>那么$b=1/k*(a</em>{1}+a<em>{2}+…a</em>{k})$<br>即里面$a<em>{i}$可以用b替换<br>如果此时要增加平均值<br>则必须满足$a</em>{k+1}&gt;=b$，那么就是平均值才会增加，于是不如贪心的选最大值，然后找到和最大值相同的有多少个<br>然后这个题就变成如何找最大联通块的问题，可以用树形DP解决，首先思考两个个问题：<br>1.如何求解树上最大联通快<br>2.如何求解树上最大联通快的个数<br>3.如何求解不相交最大联通块个数<br>可以定义状态dp[i]表示以i为根节点的子树的最大联通块的值大小，注意i必须选<br>那么dp[i]=max(dp[i],dp[i]+dp[j]) 这里j是i的儿子节点，往上递归就行，这样就解决了如何求解最大联通块的问题。<br>统计也是如此，当某个子树的联通块的大小等于最大值mx，则令其为0，这样保证了不相交。然后统计一下等于mx的联通快的个数有多少个，这题就做完了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> v,next;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[MAXN],tot,w[MAXN];</span><br><span class="line">Edge e[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[tot].v=v;</span><br><span class="line">    e[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line">LL mx;</span><br><span class="line"><span class="function">LL <span class="title">DP</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL sum=w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v!=pre)</span><br><span class="line">            sum=max(sum,sum+DP(v,u,flag));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)mx=max(mx,sum);</span><br><span class="line">    <span class="keyword">if</span>(sum==mx&amp;&amp;flag)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);</span><br><span class="line">        add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    mx=<span class="number">-1e9</span>;</span><br><span class="line">    DP(<span class="number">1</span>,<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">    DP(<span class="number">1</span>,<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d %d\n"</span>,cnt*mx,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1088&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1088&lt;/a&gt;&lt;br&gt;codeforces 525 div2 题解 By usename6&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="codeforces" scheme="http://yoursite.com/categories/ACM/codeforces/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="codeforces" scheme="http://yoursite.com/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>图的裁剪算法&amp;&amp;曲线算法</title>
    <link href="http://yoursite.com/2018/11/07/%E5%9B%BE%E7%9A%84%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95%E5%92%8C%E6%9B%B2%E7%BA%BF%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/11/07/图的裁剪算法和曲线算法/</id>
    <published>2018-11-07T08:22:39.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>裁剪算法，首先先状压下线段和边界的状态，然后根据斜截式暴力判断一下就好了，没什么难度，单纯模拟暴力，图形学马上就考试，毛线不懂怎么办啊，还没修界面，还没补青岛，还没搞数据库实验，数模还没看（队友会不会打我。。。）<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"graphics.h"</span><span class="comment">// 引用所需要的图形库</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOTTOM 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> XL=<span class="number">100</span>,XR=<span class="number">300</span>,YB=<span class="number">100</span>,YT=<span class="number">300</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;YB)code=code|BOTTOM;</span><br><span class="line">    <span class="keyword">if</span>(y&gt;YT)code=code|TOP;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;XL)code=code|LEFT;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;XR)code=code|RIGHT;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> color)</span>             <span class="comment">//中点划线</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = x1, y = y1;</span><br><span class="line"><span class="keyword">int</span> a = y1 - y2, b = x2 - x1;</span><br><span class="line"><span class="keyword">int</span> cx = (b &gt;= <span class="number">0</span> ? <span class="number">1</span> : (b = -b, <span class="number">-1</span>));</span><br><span class="line"><span class="keyword">int</span> cy = (a &lt;= <span class="number">0</span> ? <span class="number">1</span> : (a = -a, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">putpixel(x, y, color);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d, d1, d2;</span><br><span class="line"><span class="keyword">if</span> (-a &lt;= b)<span class="comment">// 斜率绝对值 &lt;= 1</span></span><br><span class="line">&#123;</span><br><span class="line">d = <span class="number">2</span> * a + b;</span><br><span class="line">d1 = <span class="number">2</span> * a;</span><br><span class="line">d2 = <span class="number">2</span> * (a + b);</span><br><span class="line"><span class="keyword">while</span>(x != x2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">y += cy, d += d2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">d += d1;</span><br><span class="line">x += cx;</span><br><span class="line">putpixel(x, y, color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">// 斜率绝对值 &gt; 1</span></span><br><span class="line">&#123;</span><br><span class="line">d = <span class="number">2</span> * b + a;</span><br><span class="line">d1 = <span class="number">2</span> * b;</span><br><span class="line">d2 = <span class="number">2</span> * (a + b);</span><br><span class="line"><span class="keyword">while</span>(y != y2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(d &lt; <span class="number">0</span>)</span><br><span class="line">d += d1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x += cx, d += d2;</span><br><span class="line">y += cy;</span><br><span class="line">putpixel(x, y, color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; solve(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//circle(300,200,100);</span></span><br><span class="line">    <span class="keyword">int</span> x=x1,y=y1;</span><br><span class="line">    <span class="keyword">int</span> code=encode(x,y);</span><br><span class="line">    <span class="keyword">while</span>(code)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(code&amp;TOP)</span><br><span class="line">        &#123;</span><br><span class="line">            y=YT;</span><br><span class="line">            x=(x1-x2)*(y-y1)/(y1-y2)+x1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(code&amp;BOTTOM)</span><br><span class="line">        &#123;</span><br><span class="line">            y=YB;</span><br><span class="line">            x=(x1-x2)*(y-y1)/(y1-y2)+x1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(code&amp;LEFT)</span><br><span class="line">        &#123;</span><br><span class="line">            x=XL;</span><br><span class="line">            y=(y1-y2)*(x-x1)/(x1-x2)+y1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(code&amp;RIGHT)</span><br><span class="line">        &#123;</span><br><span class="line">            x=XR;</span><br><span class="line">            y=(y1-y2)*(x-x1)/(x1-x2)+y1;</span><br><span class="line">        &#125;</span><br><span class="line">        code=encode(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//circle(300,200,50);</span></span><br><span class="line">    <span class="keyword">return</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cur_line</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; s=solve(x1,y1,x2,y2);</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; e=solve(x2,y2,x1,y1);</span><br><span class="line"></span><br><span class="line">    DisplayLine(s.x,s.y,e.x,e.y,GREEN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initgraph(<span class="number">600</span>, <span class="number">600</span>);<span class="comment">//初始化，显示一个窗口，这里和BGI略有区别</span></span><br><span class="line">    setcaption(<span class="string">"裁剪算法"</span>);<span class="comment">//设置窗口标题。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DisplayLine(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,RED);</span><br><span class="line">    DisplayLine(<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>,<span class="number">300</span>,RED);</span><br><span class="line">    DisplayLine(<span class="number">300</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>,RED);</span><br><span class="line">    DisplayLine(<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">100</span>,RED);</span><br><span class="line"></span><br><span class="line">    DisplayLine(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>,BLUE);</span><br><span class="line">    cur_line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    getch();<span class="comment">//暂停一下等待用户按键</span></span><br><span class="line">    closegraph();<span class="comment">//关闭图形界面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;裁剪算法，首先先状压下线段和边界的状态，然后根据斜截式暴力判断一下就好了，没什么难度，单纯模拟暴力，图形学马上就考试，毛线不懂怎么办啊，还没修界面，还没补青岛，还没搞数据库实验，数模还没看（队友会不会打我。。。）&lt;br&gt;
    
    </summary>
    
      <category term="图形学，裁剪算法" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%8C%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95/"/>
    
      <category term="曲线" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%8C%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95/%E6%9B%B2%E7%BA%BF/"/>
    
    
      <category term="图形学" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="裁剪算法" scheme="http://yoursite.com/tags/%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95/"/>
    
      <category term="曲线" scheme="http://yoursite.com/tags/%E6%9B%B2%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>图形的填充算法</title>
    <link href="http://yoursite.com/2018/11/06/%E5%9B%BE%E5%BD%A2%E7%9A%84%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/11/06/图形的填充算法/</id>
    <published>2018-11-06T15:19:49.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>填充算法一共有三种：一种是扫描线算法，扫描线算法挺简单的，如果取y轴平行线做扫描线，把交点的x坐标丢进y扫描线就行，用几个vector维护，然后有几个条件：扫描在当前点之前到奇数个点，那就不在凸包里面，如果有偶数个点，则反之，然后这其中如果有交点是顶点则分类讨论，如果多边形上连接该点的两条边在扫描线同侧，则加2，否则加1，然后还是应用之前的条件看是否在凸包内部即可<br><a id="more"></a><br>边填充就是取反，从交点开始扫，然后每次对右边取反就完事<br>种子填充更简单，就看有没有打到边界，dfs就行，只要图形不是很大，都不会爆栈吧<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"graphics.h"</span><span class="comment">// 引用所需要的图形库</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> used[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> mark[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    Point()&#123;&#125;</span><br><span class="line">    Point(<span class="keyword">int</span> a,<span class="keyword">int</span> b):x(a),y(b)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Point &amp;tp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==tp.x)<span class="keyword">return</span> y&lt;tp.y;</span><br><span class="line">        <span class="keyword">return</span> x&lt;tp.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Line[<span class="number">505</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; st[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">501</span>+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BreLine</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> dx,dy;</span><br><span class="line"><span class="keyword">int</span> s1,s2;  <span class="comment">//标志点,记录x1与x2、y1与y2的位置关系</span></span><br><span class="line"><span class="keyword">int</span> e;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> tag;  <span class="comment">//记录斜率情况</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    x=x1;</span><br><span class="line">    y=y1;</span><br><span class="line">    dx=<span class="built_in">abs</span>(x1-x2);</span><br><span class="line">    dy=<span class="built_in">abs</span>(y1-y2);</span><br><span class="line">    <span class="keyword">if</span>(x2&gt;x1)</span><br><span class="line">        s1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s1=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y2&gt;y1)</span><br><span class="line">        s2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s2=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dy&gt;dx)</span><br><span class="line">    &#123;</span><br><span class="line">        t=dx;</span><br><span class="line">        dx=dy;</span><br><span class="line">        dy=t;</span><br><span class="line">        tag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tag=<span class="number">0</span>;</span><br><span class="line">    e=<span class="number">2</span>*dy-dx;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=dx;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        putpixel(x,y,RED);</span><br><span class="line">        used[x][y]=<span class="number">1</span>;</span><br><span class="line">        Line[y].push_back(x);</span><br><span class="line">        G.push_back(Point(x,y));</span><br><span class="line">        <span class="keyword">if</span>(e&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span>(tag==<span class="number">0</span>)</span><br><span class="line">            y=y+s2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x=x+s1;</span><br><span class="line">            e=e<span class="number">-2</span>*dx;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(tag==<span class="number">0</span>)</span><br><span class="line">            x=x+s1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y=y+s2;</span><br><span class="line">        e=e+<span class="number">2</span>*dy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Line_paint</span><span class="params">()</span>                           <span class="comment">//边填充算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mark,<span class="number">-1</span>,<span class="keyword">sizeof</span>(mark));</span><br><span class="line">    sort(G.begin(),G.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)G.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Point tp=G[i];</span><br><span class="line">        <span class="keyword">int</span> y=tp.y;</span><br><span class="line">        <span class="keyword">if</span>(used[tp.x][tp.y]==<span class="number">2</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=tp.x;x&lt;=<span class="number">500</span>;x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mark[x][y]==<span class="number">-1</span>)mark[x][y]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> mark[x][y]=!mark[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=<span class="number">500</span>;x++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;=<span class="number">500</span>;y++)</span><br><span class="line">            <span class="keyword">if</span>(mark[x][y]==<span class="number">1</span>)putpixel(x,y,RED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itt=lower_bound(Line[y].begin(),Line[y].end(),x);</span><br><span class="line">    <span class="keyword">if</span>(Line[y].size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(itt==Line[y].begin()&amp;&amp;(*itt)&gt;x)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=Line[y].begin();it!=Line[y].end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx=(*it);</span><br><span class="line">        <span class="keyword">if</span>(xx&gt;x)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> yy=y;</span><br><span class="line">        <span class="keyword">if</span>(used[xx][yy]==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> id=get_id(xx,yy);</span><br><span class="line">            <span class="keyword">if</span>(st[id][<span class="number">0</span>].y&lt;=yy&amp;&amp;st[id][<span class="number">1</span>].y&lt;=yy)</span><br><span class="line">                cnt+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[id][<span class="number">0</span>].y&gt;=yy&amp;&amp;st[id][<span class="number">1</span>].y&gt;=yy)</span><br><span class="line">                cnt+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cnt&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx=x+dx[i];</span><br><span class="line">        <span class="keyword">int</span> yy=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(used[xx][yy]==<span class="number">1</span>||used[xx][yy]==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            putpixel(x,y,GREEN);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis[xx][yy])<span class="keyword">continue</span>;</span><br><span class="line">        putpixel(x,y,GREEN);</span><br><span class="line">        vis[xx][yy]=<span class="literal">true</span>;</span><br><span class="line">        dfs(xx,yy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gram</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">500</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">500</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                putpixel(i,j,GREEN);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ck(i,j))</span><br><span class="line">               putpixel(i,j,GREEN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initgraph(<span class="number">500</span>, <span class="number">500</span>);<span class="comment">//初始化，显示一个窗口，这里和BGI略有区别</span></span><br><span class="line">    <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">500</span>;i++)Line[i].clear();</span><br><span class="line">    setcaption(<span class="string">"填充算法"</span>);<span class="comment">//设置窗口标题。</span></span><br><span class="line"></span><br><span class="line">    BreLine(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">400</span>);</span><br><span class="line">    BreLine(<span class="number">100</span>,<span class="number">400</span>,<span class="number">200</span>,<span class="number">0</span>);</span><br><span class="line">    BreLine(<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">0</span>);</span><br><span class="line">    BreLine(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("yes\n");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">500</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Line[i].size()==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        sort(Line[i].begin(),Line[i].end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st[get_id(<span class="number">0</span>,<span class="number">0</span>)].push_back(Point(<span class="number">100</span>,<span class="number">400</span>));</span><br><span class="line">    st[get_id(<span class="number">0</span>,<span class="number">0</span>)].push_back(Point(<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    st[get_id(<span class="number">100</span>,<span class="number">400</span>)].push_back(Point(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    st[get_id(<span class="number">100</span>,<span class="number">400</span>)].push_back(Point(<span class="number">200</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    st[get_id(<span class="number">200</span>,<span class="number">0</span>)].push_back(Point(<span class="number">100</span>,<span class="number">400</span>));</span><br><span class="line">    st[get_id(<span class="number">200</span>,<span class="number">0</span>)].push_back(Point(<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    st[get_id(<span class="number">100</span>,<span class="number">100</span>)].push_back(Point(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    st[get_id(<span class="number">100</span>,<span class="number">100</span>)].push_back(Point(<span class="number">200</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("yes\n");</span></span><br><span class="line"></span><br><span class="line">    used[<span class="number">0</span>][<span class="number">0</span>]=used[<span class="number">100</span>][<span class="number">400</span>]=used[<span class="number">100</span>][<span class="number">100</span>]=used[<span class="number">200</span>][<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//Line_paint();</span></span><br><span class="line">    <span class="comment">//dfs(100,200);</span></span><br><span class="line">    gram();</span><br><span class="line">    getch();<span class="comment">//暂停一下等待用户按键</span></span><br><span class="line">    closegraph();<span class="comment">//关闭图形界面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;填充算法一共有三种：一种是扫描线算法，扫描线算法挺简单的，如果取y轴平行线做扫描线，把交点的x坐标丢进y扫描线就行，用几个vector维护，然后有几个条件：扫描在当前点之前到奇数个点，那就不在凸包里面，如果有偶数个点，则反之，然后这其中如果有交点是顶点则分类讨论，如果多边形上连接该点的两条边在扫描线同侧，则加2，否则加1，然后还是应用之前的条件看是否在凸包内部即可&lt;br&gt;
    
    </summary>
    
      <category term="图形学，填充算法" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%8C%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图形学" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="填充算法" scheme="http://yoursite.com/tags/%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>NAIPC-C.Greeting</title>
    <link href="http://yoursite.com/2018/11/06/NAIPC-C-Greeting/"/>
    <id>http://yoursite.com/2018/11/06/NAIPC-C-Greeting/</id>
    <published>2018-11-06T09:08:14.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/gym/101002" target="_blank" rel="noopener">http://codeforces.com/gym/101002</a><br>国庆做的NAIPC，usename6来补题<br><a id="more"></a><br>题目意思很简单，就是你给你N种信件，宽度为w，高度为h,数量为q，你可以自定义k种信封，让你求怎么制定信封，浪费的面积最小，信件不能旋转，不然可能还需要处理一下<br>数据范围很小，很容易往折半或者是状压，但是我觉得折半的话，得32这样吧，不然失去意义了，所以往状压DP想，若定义dp[i][s]表示i种信封可以覆盖状态为s的最小信件，预处理信件集合s的最小花费c[s],很明显我先去枚举s，再在s中枚举j，判断s需不需要拆分<br>转移方程为 $dp[i][s] = min(dp[i-1][s-j]+cost[j],dp[i][s])$ 其中j是s的子集，这样就做完了<br>这题有一个个坑点，结果会爆int,于是答案的上界应该处理为1e16左右<br>这题复杂度$O(3^n)$，还没证明出来。。。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN (1&lt;&lt;15)+100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL INF=<span class="number">1e16</span>;</span><br><span class="line">LL dp[<span class="number">16</span>][MAXN],c[MAXN];</span><br><span class="line">LL w[<span class="number">16</span>],h[<span class="number">16</span>],q[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;w[i],&amp;h[i],&amp;q[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL mxw,mxh,need;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        need=mxw=mxh=<span class="number">0L</span>L;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt+=q[i];</span><br><span class="line">                mxw=max(mxw,w[i]);</span><br><span class="line">                mxh=max(mxh,h[i]);</span><br><span class="line">                need+=w[i]*h[i]*q[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c[s]=mxw*mxh*cnt-need;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;                 <span class="comment">//初始化边界条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)       <span class="comment">//枚举能用多少个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=s;j;j=(j<span class="number">-1</span>)&amp;s)</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][s-j]&lt;INF)dp[i][s]=min(dp[i][s],dp[i<span class="number">-1</span>][s-j]+c[j]);</span><br><span class="line">    LL ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)ans=min(ans,dp[i][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/gym/101002&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/gym/101002&lt;/a&gt;&lt;br&gt;国庆做的NAIPC，usename6来补题&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="DP" scheme="http://yoursite.com/categories/ACM/DP/"/>
    
      <category term="状压DP" scheme="http://yoursite.com/categories/ACM/DP/%E7%8A%B6%E5%8E%8BDP/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="状压DP" scheme="http://yoursite.com/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>Red Black Tree</title>
    <link href="http://yoursite.com/2018/11/06/Red-Black-Tree/"/>
    <id>http://yoursite.com/2018/11/06/Red-Black-Tree/</id>
    <published>2018-11-06T04:04:47.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>ZOJ 4048<br>题目意思是给你一颗树，有n个节点，有m个红节点，当然根也是给红节点，给出q次查询，每次查询k个节点，你可以修改树上的一个黑节点为红色，求出所有修改中距离红节点的最大值的最小<br><a id="more"></a><br>最大值最小，一看就是二分，这题如果不带脑袋一想，应该就是求K个点的LCA，然后暴力二分check就行，check的方法很简单吧，就对于当前答案mid，找到所有大于mid，对这些节点求LCA，这样相当于是贪心吧，因为这些点距离最大值要最小，只能尽可能走LCA，于是就很简单了，如果这些点没有LCA，那肯定不行，如果有LCA，那就查看最大值是否小于mid就OK了。<br>据说倍增过不了，还没试，第二次写RMQ+LCA，卡的不行，没想到时间戳是两倍的空间，这个注意到了，然后上网查了一下题解，发现大家都很去掉一个log，于是去学习了下RMQ去掉log的姿势，然后做了排序剪枝二分check，当然是拉出来剪枝的，加了读入优化，硬是优化过去了，昨晚上一直卡，后来发现数组越界，然后发现答案会爆int，刷爆了ZOJ的测评，不知道是不是被ZJU给注意到了，早上起来改了改mid，然后交了一发，2010ms过吧，才发现ZOJ加时<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100015</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 200030</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> v,w,next;&#125;;</span><br><span class="line">Edge e[MAXM];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],tot;</span><br><span class="line"><span class="keyword">int</span> first[MAXN*<span class="number">2</span>],R[<span class="number">2</span>*MAXN],p[MAXN*<span class="number">2</span>],cnt,dep[MAXN];</span><br><span class="line"><span class="keyword">int</span> node[MAXN],k,st[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isred[MAXN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN*<span class="number">2</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> mm[MAXN*<span class="number">2</span>];</span><br><span class="line">LL dis[MAXN],cost[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cost[a]&gt;cost[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;<span class="string">'9'</span>||c&lt;<span class="string">'0'</span>) c=getchar();</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="string">'0'</span>&lt;=c &amp;&amp; c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">x=x*<span class="number">10</span>+c-<span class="string">'0'</span>;   c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[tot].v=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth,<span class="keyword">int</span> red,<span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    first[u]=++cnt;p[cnt]=u;R[cnt]=depth;</span><br><span class="line">    dep[u]=depth;</span><br><span class="line">    cost[u]=dis[u]-dis[red];                              <span class="comment">//每个节点到红色节点的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v!=pre)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[v]=dis[u]+(LL)e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(isred[v])dfs(v,depth+<span class="number">1</span>,v,u);                   <span class="comment">//下传最近的红色点</span></span><br><span class="line">            <span class="keyword">else</span> dfs(v,depth+<span class="number">1</span>,red,u);</span><br><span class="line">            p[++cnt]=u;</span><br><span class="line">            R[cnt]=depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mm[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        mm[i] = ((i&amp;(i<span class="number">-1</span>)) == <span class="number">0</span>) ? mm[i<span class="number">-1</span>]+<span class="number">1</span> : mm[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dp[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=mm[n];j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=dp[i][j<span class="number">-1</span>],b=dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>];</span><br><span class="line">            dp[i][j]=R[a]&lt;R[b]?a:b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=mm[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> a=dp[l][k],b=dp[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k];</span><br><span class="line">    <span class="keyword">return</span> R[a]&lt;R[b]?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=first[u],y=first[v];</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)swap(x,y);</span><br><span class="line">    <span class="keyword">int</span> res=RMQ(x,y);</span><br><span class="line">    <span class="keyword">return</span> p[res];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ck</span><span class="params">(LL mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>;                      <span class="comment">//top的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cost[node[i]]&gt;mid)</span><br><span class="line">            st[++top]=node[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;          <span class="comment">//小于或等于1个点改这个点即可</span></span><br><span class="line">    <span class="keyword">int</span> lca=st[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=top;i++)</span><br><span class="line">        lca=LCA(lca,st[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++)</span><br><span class="line">        <span class="keyword">if</span>(dep[lca]&gt;dep[st[i]])<span class="keyword">return</span> <span class="literal">false</span>;             <span class="comment">//不存在LCA</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[st[i]]-dis[lca]&gt;mid)<span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">//大于答案的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t=read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=read();m=read();q=read();</span><br><span class="line">        <span class="built_in">memset</span>(isred,<span class="literal">false</span>,<span class="keyword">sizeof</span>(isred));</span><br><span class="line">        cnt=tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> id;</span><br><span class="line">            id=read();</span><br><span class="line">            isred[id]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u,v,w;</span><br><span class="line">            u=read();v=read();w=read();</span><br><span class="line">            add(u,v,w);</span><br><span class="line">            add(v,u,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        ST(<span class="number">2</span>*n<span class="number">-1</span>);              <span class="comment">//dfs序是二倍</span></span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            k=read();</span><br><span class="line">            LL mx=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">                node[i]=read();</span><br><span class="line">            sort(node+<span class="number">1</span>,node+<span class="number">1</span>+k,cmp);</span><br><span class="line">            mx=cost[node[<span class="number">1</span>]];</span><br><span class="line">            LL l=<span class="number">0</span>,r=mx;</span><br><span class="line">            LL ans;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">            &#123;</span><br><span class="line">                LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(ck(mid))</span><br><span class="line">                &#123;</span><br><span class="line">                    ans=mid;</span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ZOJ 4048&lt;br&gt;题目意思是给你一颗树，有n个节点，有m个红节点，当然根也是给红节点，给出q次查询，每次查询k个节点，你可以修改树上的一个黑节点为红色，求出所有修改中距离红节点的最大值的最小&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/ACM/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCA" scheme="http://yoursite.com/categories/ACM/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LCA/"/>
    
      <category term="二分" scheme="http://yoursite.com/categories/ACM/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LCA/%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCA" scheme="http://yoursite.com/tags/LCA/"/>
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Maze Designer</title>
    <link href="http://yoursite.com/2018/11/04/Maze-Designer/"/>
    <id>http://yoursite.com/2018/11/04/Maze-Designer/</id>
    <published>2018-11-04T07:20:17.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目地址:<a href="https://nanti.jisuanke.com/t/31462" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/31462</a><br>题目给你nxm的方阵图，用最小花费建墙，相当于是迷宫，且每个方格互相可达，并且最短路径唯一，相当于是nxm的生成树，给出q次查询，求出任意这两个点的最短距离<br><a id="more"></a><br>首先去建一个最大生成树，因为生成树任意两个点均可达，最大是因为要让其花费最小，把所有花费大的墙拆掉，这样就留下一个唯一的路径，而且花费最小，且任意两点可达<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 250010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 500020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,next,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge &amp;tp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w&gt;tp.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Edge e[MAXM];</span><br><span class="line">    <span class="keyword">int</span> fa[MAXN][<span class="number">25</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> dep[MAXN];</span><br><span class="line">    <span class="keyword">int</span> dis[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        height=<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        e[tot].v=v;</span><br><span class="line">        e[tot].w=w;</span><br><span class="line">        e[tot].next=head[u];</span><br><span class="line">        head[u]=tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=height;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[u][i<span class="number">-1</span>]!=<span class="number">-1</span>)fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(fa[u][<span class="number">0</span>]!=v)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                fa[v][<span class="number">0</span>]=u;</span><br><span class="line">                dfs(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[u]&lt;dep[v])swap(u,v);</span><br><span class="line">        <span class="keyword">int</span> d=dep[u]-dep[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=height;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;d)</span><br><span class="line">                u=fa[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==v)<span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> h=height;h&gt;=<span class="number">0</span>;h--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[u][h]!=fa[v][h])</span><br><span class="line">            &#123;</span><br><span class="line">                u=fa[u][h];</span><br><span class="line">                v=fa[v][h];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[u]+dis[v]<span class="number">-2</span>*dis[lca(u,v)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">LCA L;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Krusal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Edge e[MAXM];</span><br><span class="line">    <span class="keyword">int</span> f[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tot;                        <span class="comment">//多少条边</span></span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)f[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        e[tot].u=u;                 <span class="comment">//记录起点</span></span><br><span class="line">        e[tot].v=v;</span><br><span class="line">        e[tot].w=w;</span><br><span class="line">        tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fid</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="keyword">return</span> f[u]==u?u:f[u]=fid(f[u]);&#125;    <span class="comment">//并查集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">krusal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(e,e+tot);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> f1=fid(e[i].u);</span><br><span class="line">            <span class="keyword">int</span> f2=fid(e[i].v);</span><br><span class="line">            <span class="keyword">if</span>(f1!=f2)</span><br><span class="line">            &#123;</span><br><span class="line">                f[f1]=f2;</span><br><span class="line">                <span class="comment">//记录最大生成树的边</span></span><br><span class="line">                L.add(e[i].u,e[i].v,<span class="number">1</span>);</span><br><span class="line">                L.add(e[i].v,e[i].u,<span class="number">1</span>);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=N<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Krusal K;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        K.N=n*m;</span><br><span class="line">        K.init();</span><br><span class="line">        L.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> s1[<span class="number">10</span>],s2[<span class="number">10</span>];</span><br><span class="line">                <span class="keyword">int</span> w1,w2;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s%d%s%d"</span>,s1,&amp;w1,s2,&amp;w2);</span><br><span class="line">                <span class="keyword">if</span>(s1[<span class="number">0</span>]==<span class="string">'D'</span>)</span><br><span class="line">                    K.add((i<span class="number">-1</span>)*m+j,i*m+j,w1);</span><br><span class="line">                <span class="keyword">if</span>(s2[<span class="number">0</span>]==<span class="string">'R'</span>)</span><br><span class="line">                    K.add((i<span class="number">-1</span>)*m+j,(i<span class="number">-1</span>)*m+j+<span class="number">1</span>,w2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        K.krusal();</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">        L.dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            <span class="keyword">int</span> u=(x1<span class="number">-1</span>)*m+y1;</span><br><span class="line">            <span class="keyword">int</span> v=(x2<span class="number">-1</span>)*m+y2;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,L.query(u,v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目地址:&lt;a href=&quot;https://nanti.jisuanke.com/t/31462&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nanti.jisuanke.com/t/31462&lt;/a&gt;&lt;br&gt;题目给你nxm的方阵图，用最小花费建墙，相当于是迷宫，且每个方格互相可达，并且最短路径唯一，相当于是nxm的生成树，给出q次查询，求出任意这两个点的最短距离&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/ACM/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCA" scheme="http://yoursite.com/categories/ACM/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LCA/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCA" scheme="http://yoursite.com/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>Bresenham算法</title>
    <link href="http://yoursite.com/2018/10/29/Bresenham%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/29/Bresenham算法/</id>
    <published>2018-10-29T11:46:36.000Z</published>
    <updated>2021-08-02T07:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Bresenham算法是第三种基于扫描线的算法，第一种是DDA算法，非常简单，直接强制转化y（四舍五入）然后绘点，而中点画线法，通过将函数隐式化，通过不等式关系，查看点与直线的关系，选择最近的像素点<br><a id="more"></a><br>那么Bresenham算法又是怎么做的呢？<br>假设$dx = x2 - x1 $, $dy = y2 - y1$,那么直线方程可以表示为<br>$(\frac{dy}{dx})x + b = y$<br>取$k = \frac{dy}{dx}$<br>若假设点$p<em>{i}$坐标为$(x</em>{i},y_{i})$,则<br>分类对直线斜率进行分类讨论<br>k &gt; 0 时，若直线是按坐标序枚举，很容易发现相邻两个坐标之间的增量是正值<br>若$|dx| &gt; |dy|$<br>剩下的过程其实和中点画线差不多，详细过程改日再补<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenham</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,dx,dy,d,d1,d2,inc;</span><br><span class="line">    dx=x2-x1;</span><br><span class="line">    dy=y2-y1;</span><br><span class="line">    <span class="keyword">if</span>(dx*dy&gt;=<span class="number">0</span>)inc=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> inc=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(dx)&gt;<span class="built_in">abs</span>(dy))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dx&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(x1,x2);</span><br><span class="line">            <span class="built_in">std</span>::swap(y1,y2);</span><br><span class="line">            dx=-dx;dy=-dy;</span><br><span class="line">        &#125;</span><br><span class="line">        d=<span class="number">2</span>*dy-dx;</span><br><span class="line">        d1=<span class="number">2</span>*dy;</span><br><span class="line">        d2=<span class="number">2</span>*(dy-dx);</span><br><span class="line">        x=x1;</span><br><span class="line">        y=y1;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;x2)</span><br><span class="line">        &#123;</span><br><span class="line">            glPointSize(<span class="number">5.0</span>);</span><br><span class="line">            glBegin(GL_POINTS);</span><br><span class="line">            glVertex2i(x,y);</span><br><span class="line">            glEnd();</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">if</span>(d&lt;<span class="number">0</span>)d+=d1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                y+=inc;</span><br><span class="line">                d+=d2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dy&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(x1,x2);</span><br><span class="line">            <span class="built_in">std</span>::swap(y1,y2);</span><br><span class="line">            dx=-dx;dy=-dy;</span><br><span class="line">        &#125;</span><br><span class="line">        d=<span class="number">2</span>*dy-dx;</span><br><span class="line">        d1=<span class="number">2</span>*dy;</span><br><span class="line">        d2=<span class="number">2</span>*(dy-dx);</span><br><span class="line">        x=x1;</span><br><span class="line">        y=y1;</span><br><span class="line">        <span class="keyword">while</span>(y&lt;y2)</span><br><span class="line">        &#123;</span><br><span class="line">            glPointSize(<span class="number">5.0</span>);</span><br><span class="line">            glBegin(GL_POINTS);</span><br><span class="line">            glVertex2i(x,y);</span><br><span class="line">            glEnd();</span><br><span class="line">            y++;</span><br><span class="line">            <span class="keyword">if</span>(d&lt;<span class="number">0</span>)d+=d1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                x+=inc;</span><br><span class="line">                d+=d2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    Bresenham(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">100</span>);</span><br><span class="line">    Bresenham(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">200</span>);</span><br><span class="line">    Bresenham(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">300</span>);</span><br><span class="line">    Bresenham(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    Bresenham(<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//printf("over\n");</span></span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInit(&amp;argc,argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE|GLUT_RED);</span><br><span class="line">    glutInitWindowSize(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">    glutInitWindowPosition(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    glutCreateWindow(<span class="string">"MPLine"</span>);</span><br><span class="line">    glutDisplayFunc(display);               <span class="comment">//调用里面函数的绘图函数（当然是你定义）</span></span><br><span class="line"></span><br><span class="line">    glColor3f(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    gluOrtho2D(<span class="number">0.0</span>, <span class="number">500.0</span>, <span class="number">0.0</span>, <span class="number">500.0</span>);</span><br><span class="line"></span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bresenham算法是第三种基于扫描线的算法，第一种是DDA算法，非常简单，直接强制转化y（四舍五入）然后绘点，而中点画线法，通过将函数隐式化，通过不等式关系，查看点与直线的关系，选择最近的像素点&lt;br&gt;
    
    </summary>
    
      <category term="图形学" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Open GL" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Open-GL/"/>
    
    
      <category term="图形学" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Open GL" scheme="http://yoursite.com/tags/Open-GL/"/>
    
  </entry>
  
  <entry>
    <title>DP优化专题二</title>
    <link href="http://yoursite.com/2018/10/29/DP%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/10/29/DP优化专题二/</id>
    <published>2018-10-29T04:49:52.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾usename6又来更新DP专题了。。。<br><a id="more"></a><br>今天要讲的是DP的第二个专题优化，倍增优化，之前在专题一中，我们已经说过了，DP优化无非从时间，即DP转移入手，或是从空间入手。<br>下面我来看一道这样题目（来源HDU 2157）<br>给定一个有向图，问从A点恰好走k步（允许重复经过边）到达B点的方案数mod p的值<br>乍一看是图论，实际上可以从DP角度去考虑这个题，定义状态dp[u][k]表示走k步走到u这个节点的方案数是多少，很明显根据图的性质和加法原理，转移为dp[v][k]+=dp[u][k-1] （存在u—-&gt; v的 有向边）<br>但是若这个k很大的时候，难免就要进行很大计算，我们发现不管走多少步，只要你从k节点出发，转移是固定的，转移的方程也是固定的（！这个很重要）于是，我们可以采用倍增去加速一阶线性递推式，即矩阵快速幂去倍增优化转移<br>两个状态到两个状态之间转移应该是邻接矩阵，于是对邻接矩阵进行快速幂优化转移即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line">&#125;Martix;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000</span>;</span><br><span class="line">Martix unit;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">Martix <span class="keyword">operator</span>*(Martix a,Martix b)</span><br><span class="line">&#123;</span><br><span class="line">    Martix res;</span><br><span class="line">    <span class="built_in">memset</span>(res.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(res.a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.a[i][j]=(res.a[i][j]+a.a[i][k]*b.a[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(unit.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(unit.a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        unit.a[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Martix <span class="title">qpow_mod</span><span class="params">(Martix a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Martix res=unit;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            res=res*a;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=a*a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s,e,k,cnt,t,A,B;</span><br><span class="line">    Martix res,tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n&amp;&amp;!m)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tmp.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp.a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;e);</span><br><span class="line">            tmp.a[s][e]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//printf("%d %d\n",s,e);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        <span class="keyword">while</span>(t--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;A,&amp;B,&amp;k);</span><br><span class="line">            init();</span><br><span class="line">            res=qpow_mod(tmp,k);</span><br><span class="line">            cnt=res.a[A][B];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一开始我一直错误的认为矩阵的倍增优化转移只能在一阶线性递推式解决，知道发现了这道题：<br>有n天，m件衣服，如果某一天穿了第i件衣服，第二天穿了第j件衣服，那么就会获得f[i][j]的权值。然后给你矩阵f，每件衣服可以穿无限多次，问第n天能获得的最大权值是多少。<br>同样的我们发现，若是定义状态dp[u][k]表示第k天穿了u这件服装，那么转移式子只需把上面的式子进行小小的改动：dp[v][k] = max(dp[u][k-1] + f[u][v])   (u—-&gt;v相连)<br>同样的不管k是多少，对于每个节点的u的转移是不变的，每次都会用到这个矩阵去转移，于是我们采用了模仿矩阵快速幂的方向，做倍增优化，其实是取max和+运算的结合律导致的，这个不做证明，需要用到离散数学的群论和代数系统的知识，有兴趣自行证明，于是导致我们可以先算后面在和前面合并<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL a[MAXN][MAXN];</span><br><span class="line">&#125;Martix;</span><br><span class="line">Martix unit;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">Martix <span class="keyword">operator</span>*(Martix a,Martix b)</span><br><span class="line">&#123;</span><br><span class="line">    Martix ans;</span><br><span class="line">    <span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans.a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.a[i][j]=max(ans.a[i][j],a.a[i][k]+b.a[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(unit.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(unit.a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            unit.a[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Martix <span class="title">qpow_mod</span><span class="params">(Martix a,LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Martix res;</span><br><span class="line">    <span class="built_in">memset</span>(res.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(res.a));</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)res=res*a;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=a*a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">Martix tmp,ret;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tmp.a[i][j]);</span><br><span class="line">        ret=qpow_mod(tmp,(LL)m<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//        for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            for(int j=1;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">//            &#123;</span></span><br><span class="line"><span class="comment">//                printf("%lld ",ret.a[i][j]);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            puts("");</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                ans=max(ans,ret.a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述两个都是类似分层图的DP，因此没有后效性，可以自己思考一下，状态有二维，尽管图上有环也不会导致后效性</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾usename6又来更新DP专题了。。。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="DP" scheme="http://yoursite.com/categories/ACM/DP/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>DP优化专题一</title>
    <link href="http://yoursite.com/2018/10/28/DP%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98%E4%B8%80/"/>
    <id>http://yoursite.com/2018/10/28/DP优化专题一/</id>
    <published>2018-10-28T15:10:17.000Z</published>
    <updated>2021-08-02T07:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>DP优化专题<br>虽然不是DP的选手，但是可见DP的重要性，DP这个东西高深的很，打算写一写关于DP的事情，usename6 DP 水平有限？dalao求轻喷<br><a id="more"></a><br>DP优化一 枚举优化<br>曾经在一次暑假集训的讲课中，选择了讲DP，本来就不是很懂DP这个东西，于是随便选了几个题讲讲，没想到就讲出了DP的其中一个优化，枚举优化，若不是雨神说，我可能都不知道这是什么。。。<br>枚举优化是什么？<br>DP的优化有两种方向，第一种是选择优化时间，第二种是优化空间，如果从时间的角度去考虑优化，那么就要从转移上考虑，如何优化转移，是优化时间重要的思想<br>首先思考这样一个问题：<br>给一个nxm的矩阵，要求你求出一个子矩阵，使得这个矩阵的和最大这个题的传统做法就是枚举起点(x1,y1)、终点(x2,y2)，然后套两重循环，复杂度O($n^6$)<br>一个优化就是加上二维前缀和，这样省去了两个循环，复杂度O($n^4$)<br>固定行的上下界，然后将一列压成一个元素，这题就变成了最大子段和的问题，DP即可O($n^3$)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 600</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">LL sum[maxn][maxn],a[maxn],dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            sum[i][j]=sum[i<span class="number">-1</span>][j]+x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k]=sum[j][k]-sum[i<span class="number">-1</span>][k];</span><br><span class="line">                dp[k]=max(a[k],dp[k<span class="number">-1</span>]+a[k]);</span><br><span class="line">                mx=max(mx,dp[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是这个题还有一种优化，就是可以枚举优化掉这个东西转移<br>假设你换一种角度去思考这道题<br>我都把矩阵的上下界固定了，左右的界能不能固定，对应每个矩阵右端列，我能不能快速找到左端列，使得以该右端列结尾的最大连续子矩阵和<br>单调队列去优化转移，每次存该列的前缀子矩阵和（类似扫描线推进），然后在1~当前枚举右端列i-1中从单调队列快速提出来<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 600</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">LL sum[maxn][maxn],q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            sum[i][j]=sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> qs,qe;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            qs=<span class="number">0</span>;qe=<span class="number">1</span>;</span><br><span class="line">            q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//printf("%d %d\n",i,j);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printf("k = %d\n",k);</span></span><br><span class="line">                LL data=sum[j][k]-sum[i<span class="number">-1</span>][k];</span><br><span class="line">                <span class="comment">//printf("data = %I64d\n",data);</span></span><br><span class="line">                <span class="keyword">if</span>(qs&lt;qe)mx=max(mx,data-q[qs]);</span><br><span class="line">                <span class="keyword">while</span>(qs&lt;qe)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(data&gt;=q[qe<span class="number">-1</span>])<span class="keyword">break</span>;</span><br><span class="line">                    qe--;</span><br><span class="line">                &#125;</span><br><span class="line">                q[qe]=data;</span><br><span class="line">                qe++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于是前缀，于是可以做枚举优化？<br>由于每次转移需要都是1~i-1的前缀子矩阵和，于是只需要开个数mx维护1~i-1的最小值即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 600</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">LL sum[maxn][maxn],q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            sum[i][j]=sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL mx=<span class="number">0</span>,mm;</span><br><span class="line">    <span class="keyword">int</span> qs,qe;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            mm=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                LL data=sum[j][k]-sum[i<span class="number">-1</span>][k];</span><br><span class="line">                <span class="keyword">if</span>(k!=<span class="number">1</span>)mx=max(mx,data-mm);</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">1</span>)mx=max(mx,data);</span><br><span class="line">                mm=min(mm,data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DP优化专题&lt;br&gt;虽然不是DP的选手，但是可见DP的重要性，DP这个东西高深的很，打算写一写关于DP的事情，usename6 DP 水平有限？dalao求轻喷&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="DP" scheme="http://yoursite.com/categories/ACM/DP/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
</feed>
