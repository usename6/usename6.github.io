---
title: C++ 网络编程（二） --- TCP传输
date: 2020-04-28 09:32:46
tags: [C++,网络编程]
categories: [C++,网络编程]
---
国际投资学作业公布了，要写小论文，然后还得赶毕设，最近有可能会咕咕一段时间？
<!--more-->
一、TCP 传输的基本概念
1.1 TCP报文格式
![alt](/images/winsock-2/figure1.png)
在本节，我们重点关注的是SYN、ACK、FIN选项。
1）SYN介绍
先介绍一个概念叫ISN（Initial Sequence Number），在三次连接过程中，客户端和服务端在建立TCP连接时，双方都会发送SYN报文，并初始化序号。那么为什么需要初始化序列号呢？
可以举一例说明。假设服务端（A），客户端（B）建立连接，分别使用固定序列号1和2。当A和B建立TCP连接后，B由于一部分原因重启了，那么这条TCP连接将被A废弃。但可能因为网络延迟，B发送给A的数据还在传输，并未送达A。那么在B重启后，B在重新和A建立TCP连接，在发送新的数据包，那这样就会出现A端既接收了废弃连接数据包、同样也接收新数据连接包，导致错误发生。
且注意ISN一般不能取固定值，若ISN固定了，攻击者很容易知道该客户端的ISN是多少，那他就可以根据需要创建和客户端（B）相同的IP和端口，并建立相同的ISN，这样的话就可以进行攻击。
SYN，又称同步序列编号（Synchronize Sequence Numbers），该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。（检查的目的就是防止对废弃连接得到数据包进行错误解释，上面已经说明了）。
参考：
https://zhuanlan.zhihu.com/p/86426969?utm_source=qq&utm_medium=social&utm_oi=852178998824955904
ACK：确认标志，又称（Acknowledgement Number），提示远端系统服务端已经成功接收客户端发送的sequence，期待下一个sequence的到来。
FIN: 主要用于结束一个TCP连接。
1.2 三次握手
![alt](/images/winsock-2/figure2.png)
具体地：
第一次握手：客户端给服务端发送一个SYN报文，并指明客户端的初始序列号(ISN-c),此时客户端处于SYN_SEND状态。同步位SYN = 1,seq = x。**注意：不能携带数据。**
第二次握手：服务端接收到客户端的SYN报文后，会以自己SYN、ACK的报文作为应答，同时指明了自己的初始序列号(ISN-s)。服务端处于SYN_REVD状态。SYN = 1，seq = y, ACK = x+1
第三次握手：客户端接收到SYN数据报之后，会同服务器一样，以SYN、ACK报文作为应答，此时客户端处于ESTABLISHED状态。服务端接收到客户端发来的SYN、ACK报文后，也会处于ESTABLISHED状态。此时双方成功建立连接。
**第三次握手可以携带数据，第一、第二次不行。**
为什么要三次握手？
回答这个问题，需要知道三次握手每一次握手的目的是什么？
第一次握手：服务端能够得出结论：客户端的发送能力、服务端的接收能力都是正常的。
第二次握手：客户端能够得出结论：服务端的发送、发送能力、客户端的发送、接收能力都是正常的。
如果仅仅只是第二次握手，其实服务端并不知道客户端的接收能力是怎么样的。所以需要客户端对这个报文进行响应。
第三次握手：服务端能够得出结论：客户端的发送接收能力、服务端的发送接收能力正常。
所以我们需要经过三次握手才能得出这样的结论。
1.3 四次挥手
![alt](/images/winsock-2/figure3.png)
第一次挥手：客户端发送FIN报文，报文中会指定一个序列号，此时客户端处于FIN_WAIT1状态。即在发出释放连接的报文后，停止发送数据，并进入FIN_WAIT1，并等待服务端的确认。
第二次挥手：服务端接收FIN报文，发送ACK报文响应客户端发送的FIN报文，通知客户端已经收到报文。此时服务器进入CLOSE_WAIT的状态。TCP连接进入半关闭状态（客户端到服务端关闭）。客户端收到服务端的确认后，进入FIN_WAIT2状态，这时主要等待的是服务端发出的连接释放报文段。
第三次挥手：当服务端也想断开连接了（比如说没什么事情要告诉客户端了），服务端也会发送一个FIN报文，并指定一个序列号，此时服务端也处于LAST_ACK的状态。这时候服务端等待客户端的确认。
第四次挥手：客户端收到来自服务端的FIN报文后，发送一个ACK报文作为应答，此时客户端进入TIME_WAIT状态。**（此时TCP连接还没有被释放掉）** 需要经过2 MSL后，客户端进入CLOSED状态。
那么有几个问题需要考虑下：
a. 为什么要进行四次挥手？
第一次、第二次挥手仅仅表示客户端（服务端）不再发送数据，服务端（客户端）可以关闭对客户端（服务端）的接收。而第三次、第四次则是服务端（客户端）不再发送数据。
如果仅仅只是两次挥手就关闭所有连接，可能对方某些想要发送数据被迫中断，容易导致错误的发生。
b. 为什么要等待两个MSL
TIME_WAIT状态设置为2MSL的等待事件。（其中MSL表示Maximum Segment Lifetime，表示任何报文段被丢弃前在网络内的最长时间。）。因为若服务端（客户端）没有收到客户端（服务端）发来ACK请求，可以再重发一次FIN报文，申请断开所有连接。首先服务端（客户端）至多需要经过一个MSL后才能判断是否接收到客户端（服务端）发来ACK，若没有接收到，则需要重新发送FIN报文，而FIN报文到达客户端（服务端）。所以客户端需要等待2MSL，才能判断是否需要关闭连接。若2MSL内，没有收到任何报文，则可以关闭连接。
1.4 超时重传
RTO,Retransmission TimeOut，若对方超过RTO都没有接收到消息，可以申请向我方申请重传。这个RTO不宜过大，若太大了，则会使网络的吞吐率变小，若RTO太小，有些延迟较大的报文则会被认为丢失，造成不必要重传。一般来说，RTO设置依赖于RTT（Round Trip Time），往返时延，这个往返时延可以通过一些算法进行估算，从而设置RTO。
1.5 TCP连接涉及的状态
![alt](/images/winsock-2/figure4.png)
二、winsock - TCP
2.1 状态转换图
![alt](/images/winsock-2/figure5.png)
简单介绍在winsock中，TCP的三次握手和四次挥手在winsock中哪些阶段体现。
1）首先服务端初始化socket后，调用listen函数，进入监听状态。
2）客户端初始化socket后，首先调用connect函数，相当于发送SYN J。
3）服务端监听到这个信号后，在accept阻塞，然后进行后续两次握手（前一次在监听的时候已经做了）。
注：3）的具体过程，在上述状态图已经解释，这里不再详细说明。
4）三次握手之后，新建连接套接字，并返回这个套接字，accept不再被阻塞。
四次挥手：
上述过程，主要是客户端发送FIN先被服务端接收的时候结果。
![alt](/images/winsock-2/figure6.png)
上述情况是服务端先申请关闭连接，可以发现和上面状态刚好反过来。
![alt](/images/winsock-2/figure7.png)
上述情况是同时到达的情况。